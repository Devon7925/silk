NodeKind := enum {
    Empty = {},
    Number = {},
    Identifier = {},
    Binary = {},
    Binding = {},
    Block = {},
    List = {},
};

OpCode := enum {
    None = {},
    Add = {},
    Sub = {},
    Mul = {},
    Div = {},
};

Node := { a = i32, b = i32, c = OpCode, kind = NodeKind, span_end = i32, span_start = i32, value = i32 };

MAX_INPUT := 32;
MAX_NODES := 16;

STATE_COUNT := 0;
STATE_ERROR := 1;
STATE_CURSOR := 2;

EMPTY_NODE := { a = 0, b = 0, c = OpCode::None, kind = NodeKind::Empty, span_end = 0, span_start = 0, value = 0 };

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut state: Box({i32; 3}) := {0; 3};

set_error: (i32 -> i32) := (pos: i32) => (
    if state(STATE_ERROR) == -1 then (
        state(STATE_ERROR) = pos;
    );
    0
);

is_space: (u8 -> i32) := (ch: u8) => (
    if ch == ' ' then 1 else 0
);

is_digit: (u8 -> i32) := (ch: u8) => (
    if ch >= '0' then (
        if ch <= '9' then 1 else 0
    ) else 0
);

is_alpha: (u8 -> i32) := (ch: u8) => (
    if ch >= 'a' then (
        if ch <= 'z' then 1 else 0
    ) else (
        if ch >= 'A' then (
            if ch <= 'Z' then 1 else 0
        ) else (
            if ch == '_' then 1 else 0
        )
    )
);

is_ident_char: (u8 -> i32) := (ch: u8) => (
    if is_alpha(ch) == 1 then 1 else (
        if is_digit(ch) == 1 then 1 else 0
    )
);

op_precedence: (u8 -> i32) := (ch: u8) => (
    if ch == '+' then 1 else (
        if ch == '-' then 1 else (
            if ch == '*' then 2 else (
                if ch == '/' then 2 else 0
            )
        )
    )
);

op_code: (u8 -> OpCode) := (ch: u8) => (
    if ch == '+' then OpCode::Add else (
        if ch == '-' then OpCode::Sub else (
            if ch == '*' then OpCode::Mul else OpCode::Div
        )
    )
);


skip_ws := (ignored: i32) => (
    while is_space(input(state(STATE_CURSOR))) == 1 do (
        state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
    );
    0
);

new_node := (node: Node) => (
    idx := state(STATE_COUNT);
    state(STATE_COUNT) = idx + 1;
    nodes(idx) = node;
    idx
);

scan_identifier_end := (start: i32) => (
    mut pos := start;
    while is_ident_char(input(pos)) == 1 do (
        pos = pos + 1;
    );
    pos
);

parse_number := (ignored: i32) => (
    start := state(STATE_CURSOR);
    mut value := 0;
    while is_digit(input(state(STATE_CURSOR))) == 1 do (
        value = value * 10 + (input(state(STATE_CURSOR)) - '0');
        state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
    );
    end := state(STATE_CURSOR);
    new_node({ a = 0, b = 0, c = OpCode::None, kind = NodeKind::Number, span_end = end, span_start = start, value = value })
);

parse_identifier := (ignored: i32) => (
    start := state(STATE_CURSOR);
    while is_ident_char(input(state(STATE_CURSOR))) == 1 do (
        state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
    );
    end := state(STATE_CURSOR);
    new_node({ a = 0, b = 0, c = OpCode::None, kind = NodeKind::Identifier, span_end = end, span_start = start, value = 0 })
);

parse_basic_operand := (ignored: i32) => (
    skip_ws(0);
    ch := input(state(STATE_CURSOR));
    if is_digit(ch) == 1 then (
        parse_number(0)
    ) else if is_alpha(ch) == 1 then (
        parse_identifier(0)
    ) else (
        set_error(state(STATE_CURSOR));
        -1
    )
);

parse_paren_expr := (ignored: i32) => (
    state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
    left := parse_basic_operand(0);
    if left == -1 then -1 else (
        skip_ws(0);
        op1 := input(state(STATE_CURSOR));
        if op_precedence(op1) == 0 then (
            if input(state(STATE_CURSOR)) == ')' then (
                state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                left
            ) else (
                set_error(state(STATE_CURSOR));
                -1
            )
        ) else (
            state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
            right := parse_basic_operand(0);
            if right == -1 then -1 else (
                skip_ws(0);
                op2 := input(state(STATE_CURSOR));
                if op_precedence(op2) > 0 then (
                    state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                    right2 := parse_basic_operand(0);
                    if right2 == -1 then -1 else (
                        mut combined := -1;
                        if op_precedence(op2) > op_precedence(op1) then (
                            rhs := new_node({ a = right, b = right2, c = op_code(op2), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(right).span_start, value = 0 });
                            combined = new_node({ a = left, b = rhs, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(left).span_start, value = 0 });
                        ) else (
                            lhs := new_node({ a = left, b = right, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right).span_end, span_start = nodes(left).span_start, value = 0 });
                            combined = new_node({ a = lhs, b = right2, c = op_code(op2), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(lhs).span_start, value = 0 });
                        );
                        skip_ws(0);
                        if input(state(STATE_CURSOR)) == ')' then (
                            state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                            combined
                        ) else (
                            set_error(state(STATE_CURSOR));
                            -1
                        )
                    )
                ) else (
                    combined := new_node({ a = left, b = right, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right).span_end, span_start = nodes(left).span_start, value = 0 });
                    skip_ws(0);
                    if input(state(STATE_CURSOR)) == ')' then (
                        state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                        combined
                    ) else (
                        set_error(state(STATE_CURSOR));
                        -1
                    )
                )
            )
        )
    )
);

parse_operand := (ignored: i32) => (
    skip_ws(0);
    if input(state(STATE_CURSOR)) == '(' then (
        parse_paren_expr(0)
    ) else (
        parse_basic_operand(0)
    )
);

parse_expr := (ignored: i32) => (
    left := parse_operand(0);
    if left == -1 then -1 else (
        skip_ws(0);
        op1 := input(state(STATE_CURSOR));
        if op_precedence(op1) == 0 then (
            left
        ) else (
            state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
            right := parse_operand(0);
            if right == -1 then -1 else (
                skip_ws(0);
                op2 := input(state(STATE_CURSOR));
                if op_precedence(op2) > 0 then (
                    state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                    right2 := parse_operand(0);
                    if right2 == -1 then -1 else (
                        mut combined := -1;
                        if op_precedence(op2) > op_precedence(op1) then (
                            rhs := new_node({ a = right, b = right2, c = op_code(op2), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(right).span_start, value = 0 });
                            combined = new_node({ a = left, b = rhs, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(left).span_start, value = 0 });
                        ) else (
                            lhs := new_node({ a = left, b = right, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right).span_end, span_start = nodes(left).span_start, value = 0 });
                            combined = new_node({ a = lhs, b = right2, c = op_code(op2), kind = NodeKind::Binary, span_end = nodes(right2).span_end, span_start = nodes(lhs).span_start, value = 0 });
                        );
                        combined
                    )
                ) else (
                    new_node({ a = left, b = right, c = op_code(op1), kind = NodeKind::Binary, span_end = nodes(right).span_end, span_start = nodes(left).span_start, value = 0 })
                )
            )
        )
    )
);

parse_statement := (ignored: i32) => (
    skip_ws(0);
    start := state(STATE_CURSOR);
    if is_alpha(input(start)) == 1 then (
        id_end := scan_identifier_end(start);
        mut look := id_end;
        while is_space(input(look)) == 1 do (
            look = look + 1;
        );
        if input(look) == ':' then (
            if input(look + 1) == '=' then (
                state(STATE_CURSOR) = start;
                name := parse_identifier(0);
                state(STATE_CURSOR) = look + 2;
                expr := parse_expr(0);
                if expr == -1 then -1 else (
                    new_node({ a = name, b = expr, c = OpCode::None, kind = NodeKind::Binding, span_end = nodes(expr).span_end, span_start = start, value = 0 })
                )
            ) else (
                state(STATE_CURSOR) = start;
                parse_expr(0)
            )
        ) else (
            state(STATE_CURSOR) = start;
            parse_expr(0)
        )
    ) else (
        parse_expr(0)
    )
);

parse_block := (ignored: i32) => (
    skip_ws(0);
    if input(state(STATE_CURSOR)) == 0 then (
        set_error(state(STATE_CURSOR));
        -1
    ) else (
        first_expr := parse_statement(0);
        if first_expr == -1 then -1 else (
            first_list := new_node({ a = first_expr, b = -1, c = OpCode::None, kind = NodeKind::List, span_end = nodes(first_expr).span_end, span_start = nodes(first_expr).span_start, value = 0 });
            mut count := 1;
            mut current := first_list;
            skip_ws(0);
            while input(state(STATE_CURSOR)) == ';' do (
                state(STATE_CURSOR) = state(STATE_CURSOR) + 1;
                skip_ws(0);
                next_expr := parse_statement(0);
                if next_expr == -1 then (
                    state(STATE_CURSOR) = state(STATE_CURSOR);
                ) else (
                    next_list := new_node({ a = next_expr, b = -1, c = OpCode::None, kind = NodeKind::List, span_end = nodes(next_expr).span_end, span_start = nodes(next_expr).span_start, value = 0 });
                    nodes(current).b = next_list;
                    current = next_list;
                    count = count + 1;
                );
                skip_ws(0);
            );
            block_end := nodes(current).span_end;
            new_node({ a = first_list, b = count, c = OpCode::None, kind = NodeKind::Block, span_end = block_end, span_start = 0, value = 0 })
        )
    )
);

(export wasm) parse := {} => (
    state(STATE_COUNT) = 0;
    state(STATE_ERROR) = -1;
    state(STATE_CURSOR) = 0;

    root := parse_block(0);
    skip_ws(0);
    if state(STATE_ERROR) != -1 then (
        -1
    ) else if input(state(STATE_CURSOR)) != 0 then (
        set_error(state(STATE_CURSOR));
        -1
    ) else (
        root
    )
);

{}
