StringRef := { length = i32, start = i32 };
SourceSpan := { length = i32, start = i32 };

Identifier := { name = StringRef, unique = StringRef };

TargetLiteral := enum {
    JSTarget = {},
    WasmTarget = {},
    WgslTarget = {},
};

BindingAnnotationLiteral := enum {
    Mut = {},
    Export = TargetLiteral,
    Target = TargetLiteral,
    Wrap = TargetLiteral,
};

ExpressionLiteral := enum {
    Number = i32,
    Boolean = i32,
    Char = i32,
    String = StringRef,
    Target = TargetLiteral,
    BindingAnnotation = BindingAnnotationLiteral,
};

IntrinsicType := enum {
    I32 = {},
    U8 = {},
    Boolean = {},
    Type = {},
    Target = {},
    BindingAnnotation = {},
};

UnaryIntrinsicOperator := enum {
    BooleanNot = {},
    EnumFromStruct = {},
    MatchFromStruct = {},
    UseFromString = {},
    BoxFromType = {},
    BindingAnnotationExportFromTarget = {},
    BindingAnnotationTargetFromTarget = {},
    BindingAnnotationWrapFromTarget = {},
    AssemblyFromTarget = {},
};

BinaryIntrinsicOperator := enum {
    I32Add = {},
    I32Subtract = {},
    I32Multiply = {},
    I32Divide = {},
    I32Equal = {},
    I32NotEqual = {},
    I32LessThan = {},
    I32GreaterThan = {},
    I32LessThanOrEqual = {},
    I32GreaterThanOrEqual = {},
    BooleanAnd = {},
    BooleanOr = {},
    BooleanXor = {},
};

IntrinsicOperation := enum {
    Binary = { left = i32, right = i32, operator = BinaryIntrinsicOperator },
    Unary = { operand = i32, operator = UnaryIntrinsicOperator },
    InlineAssembly = { target = TargetLiteral, code = i32 },
};

DivergeExpressionType := enum {
    Return = {},
    Break = {},
};

BindingPattern := enum {
    Identifier = { name = Identifier, span = SourceSpan },
    Literal = { literal = ExpressionLiteral, span = SourceSpan },
    Struct = { fields = i32, span = SourceSpan },
    EnumVariant = { enum_type = i32, variant = Identifier, payload = i32, span = SourceSpan },
    TypeHint = { pattern = i32, type_expr = i32, span = SourceSpan },
    Annotated = { annotations = i32, pattern = i32, span = SourceSpan },
};

LValue := enum {
    Identifier = { name = Identifier, span = SourceSpan },
    TypePropertyAccess = { object = i32, property = StringRef, span = SourceSpan },
    ArrayIndex = { array = i32, index = i32, span = SourceSpan },
};

Binding := { pattern = BindingPattern, expr = i32 };

ExpressionList := { count = i32, head = i32 };

FunctionTypeInfo := { parameter = i32, return_type = i32 };
FunctionInfo := { parameter = BindingPattern, return_type = i32, body = i32 };
EnumValueInfo := { enum_type = i32, variant = Identifier, variant_index = i32, payload = i32 };
EnumConstructorInfo := { enum_type = i32, variant = Identifier, variant_index = i32, payload_type = i32 };
IfInfo := { condition = i32, then_branch = i32, else_branch = i32 };
AttachImplementationInfo := { type_expr = i32, implementation = i32 };
ArrayRepeatInfo := { value = i32, count = i32 };
OperationInfo := { operator = StringRef, left = i32, right = i32 };
AssignmentInfo := { target = LValue, expr = i32 };
FunctionCallInfo := { function = i32, argument = i32 };
ArrayIndexInfo := { array = i32, index = i32 };
TypePropertyAccessInfo := { object = i32, property = StringRef };
DivergeInfo := { value = i32, divergance_type = DivergeExpressionType };
LoopInfo := { body = i32 };
MatchInfo := { value = i32, branches = i32 };
StructInfo := { fields = i32 };
EnumTypeInfo := { variants = i32 };

NodeKind := enum {
    IntrinsicType = IntrinsicType,
    BoxType = i32,
    IntrinsicOperation = IntrinsicOperation,
    EnumType = EnumTypeInfo,
    Match = MatchInfo,
    EnumValue = EnumValueInfo,
    EnumConstructor = EnumConstructorInfo,
    If = IfInfo,
    AttachImplementation = AttachImplementationInfo,
    Function = FunctionInfo,
    FunctionType = FunctionTypeInfo,
    Struct = StructInfo,
    ArrayRepeat = ArrayRepeatInfo,
    Literal = ExpressionLiteral,
    Identifier = Identifier,
    Operation = OperationInfo,
    Assignment = AssignmentInfo,
    FunctionCall = FunctionCallInfo,
    ArrayIndex = ArrayIndexInfo,
    TypePropertyAccess = TypePropertyAccessInfo,
    Binding = Binding,
    Block = ExpressionList,
    Diverge = DivergeInfo,
    Loop = LoopInfo,
};

TypeCache := enum { None = {}, Some = i32 };
Node := { kind = NodeKind, span = SourceSpan, type_cache = TypeCache };

ListNode := { next = i32, value = i32 };

MAX_INPUT := 32;
MAX_NODES := 16;
MAX_LIST_NODES := 32;

EMPTY_STRING := { length = 0, start = 0 };
EMPTY_IDENTIFIER := { name = EMPTY_STRING, unique = EMPTY_STRING };
EMPTY_SPAN := { length = 0, start = 0 };
EMPTY_NODE := { kind = NodeKind::Literal(ExpressionLiteral::Number(0)), span = EMPTY_SPAN, type_cache = TypeCache::None };
EMPTY_LIST_NODE := { next = -1, value = -1 };

State := { count = i32, cursor = i32, error = i32, list_count = i32 };

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};

make_span := {start: i32, end: i32} => (
    { start = start, length = end - start }
);

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

make_identifier := {start: i32, end: i32} => (
    len := end - start;
    str := make_string_ref{start, len};
    { name = str, unique = str }
);

span_end := (idx: i32) => (
    nodes(idx).span.start + nodes(idx).span.length
);

set_error: (i32 -> i32) := (pos: i32) => (
    if state.error == -1 then (
        state.error = pos;
    );
    0
);

is_space: (u8 -> i32) := (ch: u8) => (
    if ch == ' ' then 1 else 0
);

is_digit: (u8 -> i32) := (ch: u8) => (
    if ch >= '0' then (
        if ch <= '9' then 1 else 0
    ) else 0
);

is_alpha: (u8 -> i32) := (ch: u8) => (
    if ch >= 'a' then (
        if ch <= 'z' then 1 else 0
    ) else (
        if ch >= 'A' then (
            if ch <= 'Z' then 1 else 0
        ) else (
            if ch == '_' then 1 else 0
        )
    )
);

is_ident_char: (u8 -> i32) := (ch: u8) => (
    if is_alpha(ch) == 1 then 1 else (
        if is_digit(ch) == 1 then 1 else 0
    )
);

op_precedence: (u8 -> i32) := (ch: u8) => (
    if ch == '+' then 1 else (
        if ch == '-' then 1 else (
            if ch == '*' then 2 else (
                if ch == '/' then 2 else 0
            )
        )
    )
);

skip_ws := (ignored: i32) => (
    while is_space(input(state.cursor)) == 1 do (
        state.cursor = state.cursor + 1;
    );
    0
);

new_node := {kind: NodeKind, span: SourceSpan} => (
    idx := state.count;
    state.count = idx + 1;
    nodes(idx) = { kind = kind, span = span, type_cache = TypeCache::None };
    idx
);

new_list_node := {value: i32, next: i32} => (
    idx := state.list_count;
    state.list_count = idx + 1;
    list_nodes(idx) = { next = next, value = value };
    idx
);

scan_identifier_end := (start: i32) => (
    mut pos := start;
    while is_ident_char(input(pos)) == 1 do (
        pos = pos + 1;
    );
    pos
);

parse_number := (ignored: i32) => (
    start := state.cursor;
    mut value := 0;
    while is_digit(input(state.cursor)) == 1 do (
        value = value * 10 + (input(state.cursor) - '0');
        state.cursor = state.cursor + 1;
    );
    end := state.cursor;
    span := make_span{start, end};
    new_node{NodeKind::Literal(ExpressionLiteral::Number(value)), span}
);

parse_identifier := (ignored: i32) => (
    start := state.cursor;
    while is_ident_char(input(state.cursor)) == 1 do (
        state.cursor = state.cursor + 1;
    );
    end := state.cursor;
    identifier := make_identifier{start, end};
    span := make_span{start, end};
    new_node{NodeKind::Identifier(identifier), span}
);

parse_basic_operand := (ignored: i32) => (
    skip_ws(0);
    ch := input(state.cursor);
    if is_digit(ch) == 1 then (
        parse_number(0)
    ) else if is_alpha(ch) == 1 then (
        parse_identifier(0)
    ) else (
        set_error(state.cursor);
        -1
    )
);

new_operation := {left: i32, right: i32, op_pos: i32} => (
    op_ref := make_string_ref{op_pos, 1};
    span := make_span{nodes(left).span.start, span_end(right)};
    new_node{NodeKind::Operation({ operator = op_ref, left = left, right = right }), span}
);

parse_paren_expr := (ignored: i32) => (
    state.cursor = state.cursor + 1;
    left := parse_basic_operand(0);
    if left == -1 then -1 else (
        skip_ws(0);
        op1_pos := state.cursor;
        op1 := input(state.cursor);
        if op_precedence(op1) == 0 then (
            if input(state.cursor) == ')' then (
                state.cursor = state.cursor + 1;
                left
            ) else (
                set_error(state.cursor);
                -1
            )
        ) else (
            state.cursor = state.cursor + 1;
            right := parse_basic_operand(0);
            if right == -1 then -1 else (
                skip_ws(0);
                op2_pos := state.cursor;
                op2 := input(state.cursor);
                if op_precedence(op2) > 0 then (
                    state.cursor = state.cursor + 1;
                    right2 := parse_basic_operand(0);
                    if right2 == -1 then -1 else (
                        mut combined := -1;
                        if op_precedence(op2) > op_precedence(op1) then (
                            rhs := new_operation{right, right2, op2_pos};
                            combined = new_operation{left, rhs, op1_pos};
                        ) else (
                            lhs := new_operation{left, right, op1_pos};
                            combined = new_operation{lhs, right2, op2_pos};
                        );
                        skip_ws(0);
                        if input(state.cursor) == ')' then (
                            state.cursor = state.cursor + 1;
                            combined
                        ) else (
                            set_error(state.cursor);
                            -1
                        )
                    )
                ) else (
                    combined := new_operation{left, right, op1_pos};
                    skip_ws(0);
                    if input(state.cursor) == ')' then (
                        state.cursor = state.cursor + 1;
                        combined
                    ) else (
                        set_error(state.cursor);
                        -1
                    )
                )
            )
        )
    )
);

parse_operand := (ignored: i32) => (
    skip_ws(0);
    if input(state.cursor) == '(' then (
        parse_paren_expr(0)
    ) else (
        parse_basic_operand(0)
    )
);

parse_expr := (ignored: i32) => (
    left := parse_operand(0);
    if left == -1 then -1 else (
        skip_ws(0);
        op1_pos := state.cursor;
        op1 := input(state.cursor);
        if op_precedence(op1) == 0 then (
            left
        ) else (
            state.cursor = state.cursor + 1;
            right := parse_operand(0);
            if right == -1 then -1 else (
                skip_ws(0);
                op2_pos := state.cursor;
                op2 := input(state.cursor);
                if op_precedence(op2) > 0 then (
                    state.cursor = state.cursor + 1;
                    right2 := parse_operand(0);
                    if right2 == -1 then -1 else (
                        mut combined := -1;
                        if op_precedence(op2) > op_precedence(op1) then (
                            rhs := new_operation{right, right2, op2_pos};
                            combined = new_operation{left, rhs, op1_pos};
                        ) else (
                            lhs := new_operation{left, right, op1_pos};
                            combined = new_operation{lhs, right2, op2_pos};
                        );
                        combined
                    )
                ) else (
                    new_operation{left, right, op1_pos}
                )
            )
        )
    )
);

parse_statement := (ignored: i32) => (
    skip_ws(0);
    start := state.cursor;
    if is_alpha(input(start)) == 1 then (
        id_end := scan_identifier_end(start);
        mut look := id_end;
        while is_space(input(look)) == 1 do (
            look = look + 1;
        );
        if input(look) == ':' then (
            if input(look + 1) == '=' then (
                state.cursor = start;
                name := parse_identifier(0);
                state.cursor = look + 2;
                expr := parse_expr(0);
                if expr == -1 then -1 else (
                    name_span := make_span{start, id_end};
                    name_id := make_identifier{start, id_end};
                    binding := { pattern = BindingPattern::Identifier({ name = name_id, span = name_span }), expr = expr };
                    span := make_span{start, span_end(expr)};
                    new_node{NodeKind::Binding(binding), span}
                )
            ) else (
                state.cursor = start;
                parse_expr(0)
            )
        ) else (
            state.cursor = start;
            parse_expr(0)
        )
    ) else (
        parse_expr(0)
    )
);

parse_block := (ignored: i32) => (
    skip_ws(0);
    if input(state.cursor) == 0 then (
        set_error(state.cursor);
        -1
    ) else (
        mut count := 0;
        mut head := -1;
        mut tail := -1;
        mut last_expr := -1;
        expr := parse_statement(0);
        if expr == -1 then -1 else (
            head = new_list_node{expr, -1};
            tail = head;
            last_expr = expr;
            count = 1;
            skip_ws(0);
            while input(state.cursor) == ';' do (
                state.cursor = state.cursor + 1;
                skip_ws(0);
                next_expr := parse_statement(0);
                if next_expr == -1 then (
                    state.cursor = state.cursor;
                ) else (
                    next_node := new_list_node{next_expr, -1};
                    list_nodes(tail).next = next_node;
                    tail = next_node;
                    last_expr = next_expr;
                    count = count + 1;
                );
                skip_ws(0);
            );
            list := { count = count, head = head };
            span := make_span{0, span_end(last_expr)};
            new_node{NodeKind::Block(list), span}
        )
    )
);

(export wasm) parse := {} => (
    state.count = 0;
    state.list_count = 0;
    state.error = -1;
    state.cursor = 0;

    root := parse_block(0);
    skip_ws(0);
    if state.error != -1 then (
        -1
    ) else if input(state.cursor) != 0 then (
        set_error(state.cursor);
        -1
    ) else (
        root
    )
);

(export wasm) get_state_error := {} => (
    state.error
);

(export wasm) get_kind_tag := (idx: i32) => (
    kind := nodes(idx).kind;
    if NodeKind::IntrinsicType(_) := kind then 0 else (
        if NodeKind::BoxType(_) := kind then 1 else (
            if NodeKind::IntrinsicOperation(_) := kind then 2 else (
                if NodeKind::EnumType(_) := kind then 3 else (
                    if NodeKind::Match(_) := kind then 4 else (
                        if NodeKind::EnumValue(_) := kind then 5 else (
                            if NodeKind::EnumConstructor(_) := kind then 6 else (
                                if NodeKind::If(_) := kind then 7 else (
                                    if NodeKind::AttachImplementation(_) := kind then 8 else (
                                        if NodeKind::Function(_) := kind then 9 else (
                                            if NodeKind::FunctionType(_) := kind then 10 else (
                                                if NodeKind::Struct(_) := kind then 11 else (
                                                    if NodeKind::ArrayRepeat(_) := kind then 12 else (
                                                        if NodeKind::Literal(_) := kind then 13 else (
                                                            if NodeKind::Identifier(_) := kind then 14 else (
                                                                if NodeKind::Operation(_) := kind then 15 else (
                                                                    if NodeKind::Assignment(_) := kind then 16 else (
                                                                        if NodeKind::FunctionCall(_) := kind then 17 else (
                                                                            if NodeKind::ArrayIndex(_) := kind then 18 else (
                                                                                if NodeKind::TypePropertyAccess(_) := kind then 19 else (
                                                                                    if NodeKind::Binding(_) := kind then 20 else (
                                                                                        if NodeKind::Block(_) := kind then 21 else (
                                                                                            if NodeKind::Diverge(_) := kind then 22 else 23
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

(export wasm) get_span_start := (idx: i32) => (
    nodes(idx).span.start
);

(export wasm) get_span_length := (idx: i32) => (
    nodes(idx).span.length
);

(export wasm) get_literal_number := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::Number(value)) := nodes(idx).kind then value else -1
);

(export wasm) get_identifier_start := (idx: i32) => (
    if NodeKind::Identifier(id) := nodes(idx).kind then id.name.start else -1
);

(export wasm) get_identifier_length := (idx: i32) => (
    if NodeKind::Identifier(id) := nodes(idx).kind then id.name.length else 0
);

(export wasm) get_operation_left := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.left else -1
);

(export wasm) get_operation_right := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.right else -1
);

(export wasm) get_operation_operator_start := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.operator.start else -1
);

(export wasm) get_operation_operator_length := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.operator.length else 0
);

(export wasm) get_binding_expr := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then binding.expr else -1
);

(export wasm) get_binding_name_start := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.name.name.start else -1
    ) else -1
);

(export wasm) get_binding_name_length := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.name.name.length else 0
    ) else 0
);

(export wasm) get_block_count := (idx: i32) => (
    if NodeKind::Block(list) := nodes(idx).kind then list.count else 0
);

(export wasm) get_block_item := {idx: i32, pos: i32} => (
    if NodeKind::Block(list) := nodes(idx).kind then (
        mut current := list.head;
        mut i := 0;
        while i < pos do (
            if current == -1 then (
                i = pos;
            ) else (
                current = list_nodes(current).next;
                i = i + 1;
            );
        );
        if current == -1 then -1 else list_nodes(current).value
    ) else -1
);

{}
