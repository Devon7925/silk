types := use "types.silk";

StringRef := types.StringRef;
SourceSpan := types.SourceSpan;

Identifier := types.Identifier;

TargetLiteral := types.TargetLiteral;

BindingAnnotationLiteral := types.BindingAnnotationLiteral;

ExpressionLiteral := types.ExpressionLiteral;

IntrinsicType := types.IntrinsicType;

UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;

BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;

IntrinsicOperation := types.IntrinsicOperation;

DivergeExpressionType := types.DivergeExpressionType;

BindingPattern := types.BindingPattern;

LValue := types.LValue;

Binding := types.Binding;

ExpressionList := types.ExpressionList;

FunctionTypeInfo := types.FunctionTypeInfo;
FunctionInfo := types.FunctionInfo;
EnumValueInfo := types.EnumValueInfo;
EnumConstructorInfo := types.EnumConstructorInfo;
IfInfo := types.IfInfo;
AttachImplementationInfo := types.AttachImplementationInfo;
ArrayRepeatInfo := types.ArrayRepeatInfo;
OperationInfo := types.OperationInfo;
AssignmentInfo := types.AssignmentInfo;
FunctionCallInfo := types.FunctionCallInfo;
ArrayIndexInfo := types.ArrayIndexInfo;
TypePropertyAccessInfo := types.TypePropertyAccessInfo;
DivergeInfo := types.DivergeInfo;
LoopInfo := types.LoopInfo;
MatchInfo := types.MatchInfo;
StructInfo := types.StructInfo;
EnumTypeInfo := types.EnumTypeInfo;

NodeKind := types.NodeKind;

TypeCache := types.TypeCache;
Node := types.Node;

ListNode := types.ListNode;

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;

EMPTY_STRING := types.EMPTY_STRING;
SYNTHETIC_MUT_STRING := types.SYNTHETIC_MUT_STRING;
SYNTHETIC_OPTION_STRING := types.SYNTHETIC_OPTION_STRING;
SYNTHETIC_SOME_STRING := types.SYNTHETIC_SOME_STRING;
SYNTHETIC_ITER_TY_STRING := types.SYNTHETIC_ITER_TY_STRING;
SYNTHETIC_NEXT_STRING := types.SYNTHETIC_NEXT_STRING;
SYNTHETIC_FOR_ITER_STRING := types.SYNTHETIC_FOR_ITER_STRING;
EMPTY_IDENTIFIER := types.EMPTY_IDENTIFIER;
EMPTY_SPAN := types.EMPTY_SPAN;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

State := types.State;

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};

make_span := {start: i32, end: i32} => (
    { start = start, length = end - start }
);

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

make_identifier := {start: i32, end: i32} => (
    len := end - start;
    str := make_string_ref{start, len};
    { name = str, unique = str }
);

span_end := (idx: i32) => (
    nodes(idx).span.start + nodes(idx).span.length
);

set_error: (i32 -> i32) := (pos: i32) => (
    if state.error == -1 then (
        state.error = pos;
        0
    ) else (
        0
    );
    0
);

is_space: (u8 -> i32) := (ch: u8) => (
    ch |> match {
        ' ' => 1,
        '\n' => 1,
        '\r' => 1,
        '\t' => 1,
        else => 0
    }
);

is_digit: (u8 -> i32) := (ch: u8) => (
    if ch >= '0' then (
        if ch <= '9' then 1 else 0
    ) else 0
);

is_alpha: (u8 -> i32) := (ch: u8) => (
    if ch == '_' then 1 else (
        if ch >= 'a' then (
            if ch <= 'z' then 1 else 0
        ) else (
            if ch >= 'A' then (
                if ch <= 'Z' then 1 else 0
            ) else 0
        )
    )
);

is_ident_char: (u8 -> i32) := (ch: u8) => (
    if is_alpha(ch) == 1 then 1 else (
        if is_digit(ch) == 1 then 1 else 0
    )
);

op_precedence: (u8 -> i32) := (ch: u8) => (
    if ch == '+' then 1 else (
        if ch == '-' then 1 else (
            if ch == '*' then 2 else (
                if ch == '/' then 2 else 0
            )
        )
    )
);

skip_ws := (ignored: i32) => (
    mut done := 0;
    while done == 0 do (
        while is_space(input(state.cursor)) == 1 do (
            state.cursor = state.cursor + 1;
            {}
        );
        if input(state.cursor) == '/' then (
            if input(state.cursor + 1) == '/' then (
                state.cursor = state.cursor + 2;
                while input(state.cursor) != 0 do (
                    if input(state.cursor) == '\n' then (
                        state.cursor = state.cursor + 1;
                        done = 0;
                        break;
                    ) else (
                        state.cursor = state.cursor + 1;
                    );
                    {}
                );
                {}
            ) else (
                done = 1;
                {}
            )
        ) else (
            done = 1;
            {}
        )
    );
    0
);

new_node := {kind: NodeKind, span: SourceSpan} => (
    idx := state.count;
    if idx >= MAX_NODES then (
        set_error(span.start);
        -1
    ) else (
        state.count = idx + 1;
        nodes(idx) = { kind = kind, span = span, type_cache = TypeCache::None };
        idx
    )
);

new_list_node := {value: i32, next: i32} => (
    idx := state.list_count;
    if idx >= MAX_LIST_NODES then (
        set_error(0);
        -1
    ) else (
        state.list_count = idx + 1;
        list_nodes(idx) = { next = next, value = value };
        idx
    )
);

scan_identifier_end := (start: i32) => (
    mut pos := start;
    while is_ident_char(input(pos)) == 1 do (
        pos = pos + 1;
        {}
    );
    pos
);

is_keyword_if := (pos: i32) => (
    if input(pos) == 'i' then (
        if input(pos + 1) == 'f' then (
            if is_ident_char(input(pos + 2)) == 1 then 0 else 1
        ) else 0
    ) else 0
);

is_keyword_then := (pos: i32) => (
    if input(pos) == 't' then (
        if input(pos + 1) == 'h' then (
            if input(pos + 2) == 'e' then (
                if input(pos + 3) == 'n' then (
                    if is_ident_char(input(pos + 4)) == 1 then 0 else 1
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_else := (pos: i32) => (
    if input(pos) == 'e' then (
        if input(pos + 1) == 'l' then (
            if input(pos + 2) == 's' then (
                if input(pos + 3) == 'e' then (
                    if is_ident_char(input(pos + 4)) == 1 then 0 else 1
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_return := (pos: i32) => (
    if input(pos) == 'r' then (
        if input(pos + 1) == 'e' then (
            if input(pos + 2) == 't' then (
                if input(pos + 3) == 'u' then (
                    if input(pos + 4) == 'r' then (
                        if input(pos + 5) == 'n' then (
                            if is_ident_char(input(pos + 6)) == 1 then 0 else 1
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_break := (pos: i32) => (
    if input(pos) == 'b' then (
        if input(pos + 1) == 'r' then (
            if input(pos + 2) == 'e' then (
                if input(pos + 3) == 'a' then (
                    if input(pos + 4) == 'k' then (
                        if is_ident_char(input(pos + 5)) == 1 then 0 else 1
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_for := (pos: i32) => (
    if input(pos) == 'f' then (
        if input(pos + 1) == 'o' then (
            if input(pos + 2) == 'r' then (
                if is_ident_char(input(pos + 3)) == 1 then 0 else 1
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_in := (pos: i32) => (
    if input(pos) == 'i' then (
        if input(pos + 1) == 'n' then (
            if is_ident_char(input(pos + 2)) == 1 then 0 else 1
        ) else 0
    ) else 0
);

is_keyword_while := (pos: i32) => (
    if input(pos) == 'w' then (
        if input(pos + 1) == 'h' then (
            if input(pos + 2) == 'i' then (
                if input(pos + 3) == 'l' then (
                    if input(pos + 4) == 'e' then (
                        if is_ident_char(input(pos + 5)) == 1 then 0 else 1
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_loop := (pos: i32) => (
    if input(pos) == 'l' then (
        if input(pos + 1) == 'o' then (
            if input(pos + 2) == 'o' then (
                if input(pos + 3) == 'p' then (
                    if is_ident_char(input(pos + 4)) == 1 then 0 else 1
                ) else 0
            ) else 0
        ) else 0
    ) else 0
);

is_keyword_do := (pos: i32) => (
    if input(pos) == 'd' then (
        if input(pos + 1) == 'o' then (
            if is_ident_char(input(pos + 2)) == 1 then 0 else 1
        ) else 0
    ) else 0
);

is_operator_char: (u8 -> i32) := (ch: u8) => (
    ch |> match {
        '+' => 1,
        '-' => 1,
        '*' => 1,
        '/' => 1,
        '=' => 1,
        '!' => 1,
        '<' => 1,
        '>' => 1,
        '&' => 1,
        '|' => 1,
        '^' => 1,
        ':' => 1,
        '.' => 1,
        '@' => 1,
        else => 0
    }
);

op2_match := {pos: i32, ch1: u8, ch2: u8} => (
    if input(pos) == ch1 then (
        if input(pos + 1) == ch2 then 1 else 0
    ) else 0
);

scan_operator_len := (pos: i32) => (
    ch := input(pos);
    if ch == 0 then -1 else (
        if ch == ';' then -1 else (
            if ch == ')' then -1 else (
                if ch == ',' then -1 else (
                    if ch == '}' then -1 else (
                        if ch == ']' then -1 else (
                            if is_keyword_if(pos) == 1 then -1 else (
                                if is_keyword_then(pos) == 1 then -1 else (
                                    if is_keyword_else(pos) == 1 then -1 else (
                                        if is_keyword_return(pos) == 1 then -1 else (
                                            if is_keyword_break(pos) == 1 then -1 else (
                                                if is_keyword_for(pos) == 1 then -1 else (
                                                    if is_keyword_in(pos) == 1 then -1 else (
                                                        if is_keyword_while(pos) == 1 then -1 else (
                                                            if is_keyword_loop(pos) == 1 then -1 else (
                                                                if is_keyword_do(pos) == 1 then -1 else (
                                                                    if is_operator_char(ch) == 1 then (
                                                                        mut len := 0;
                                                                        mut cursor := pos;
                                                                        while is_operator_char(input(cursor)) == 1 do (
                                                                            len = len + 1;
                                                                            cursor = cursor + 1;
                                                                            {}
                                                                        );
                                                                        len
                                                                    ) else 0
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

op_is0 := (op_len: i32) => (
    if op_len == 0 then 1 else 0
);

op_is1 := {op_start: i32, op_len: i32, ch: u8} => (
    if op_len == 1 then (
        if input(op_start) == ch then 1 else 0
    ) else 0
);

op_is2 := {op_start: i32, op_len: i32, ch1: u8, ch2: u8} => (
    if op_len == 2 then (
        if input(op_start) == ch1 then (
            if input(op_start + 1) == ch2 then 1 else 0
        ) else 0
    ) else 0
);

op_precedence_ref := {op_start: i32, op_len: i32} => (
    if op_is0(op_len) == 1 then 8 else (
        if op_is2{op_start, op_len, ':', ':'} == 1 then 8 else (
            if op_is1{op_start, op_len, '.'} == 1 then 8 else (
                if op_is1{op_start, op_len, '@'} == 1 then 8 else (
                    if op_is1{op_start, op_len, ':'} == 1 then 7 else (
                        if op_is1{op_start, op_len, '*'} == 1 then 6 else (
                            if op_is1{op_start, op_len, '/'} == 1 then 6 else (
                                if op_is1{op_start, op_len, '+'} == 1 then 5 else (
                                    if op_is1{op_start, op_len, '-'} == 1 then 5 else (
                                        if op_is2{op_start, op_len, '=', '='} == 1 then 4 else (
                                            if op_is2{op_start, op_len, '!', '='} == 1 then 4 else (
                                                if op_is1{op_start, op_len, '<'} == 1 then 4 else (
                                                    if op_is1{op_start, op_len, '>'} == 1 then 4 else (
                                                        if op_is2{op_start, op_len, '<', '='} == 1 then 4 else (
                                                            if op_is2{op_start, op_len, '>', '='} == 1 then 4 else (
                                                                if op_is2{op_start, op_len, '.', '.'} == 1 then 4 else (
                                                                    if op_is2{op_start, op_len, '&', '&'} == 1 then 3 else (
                                                                        if op_is2{op_start, op_len, '|', '|'} == 1 then 2 else (
                                                                            if op_is1{op_start, op_len, '^'} == 1 then 2 else (
                                                                                if op_is2{op_start, op_len, '=', '>'} == 1 then 1 else (
                                                                                    if op_is2{op_start, op_len, '-', '>'} == 1 then 1 else (
                                                                                        if op_is2{op_start, op_len, '|', '>'} == 1 then 1 else (
                                                                                            if op_is2{op_start, op_len, ':', '='} == 1 then 0 else (
                                                                                                if op_is1{op_start, op_len, '='} == 1 then 0 else 5
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

parse_number := (ignored: i32) => (
    start := state.cursor;
    mut sign := 1;
    if input(state.cursor) == '-' then (
        sign = -1;
        state.cursor = state.cursor + 1;
        0
    ) else (
        0
    );
    mut value := 0;
    if is_digit(input(state.cursor)) == 0 then (
        set_error(state.cursor);
        -1
    ) else (
        while is_digit(input(state.cursor)) == 1 do (
            value = value * 10 + (input(state.cursor) - '0');
            state.cursor = state.cursor + 1;
            {}
        );
        end := state.cursor;
        span := make_span{start, end};
        new_node{NodeKind::Literal(ExpressionLiteral::Number(value * sign)), span}
    )
);

parse_identifier := (ignored: i32) => (
    start := state.cursor;
    while is_ident_char(input(state.cursor)) == 1 do (
        state.cursor = state.cursor + 1;
        {}
    );
    end := state.cursor;
    identifier := make_identifier{start, end};
    span := make_span{start, end};
    new_node{NodeKind::Identifier(identifier), span}
);

parse_boolean_literal := (ignored: i32) => (
    start := state.cursor;
    if input(start) == 't' then (
        if input(start + 1) == 'r' then (
            if input(start + 2) == 'u' then (
                if input(start + 3) == 'e' then (
                    if is_ident_char(input(start + 4)) == 0 then (
                        state.cursor = start + 4;
                        span := make_span{start, state.cursor};
                        new_node{NodeKind::Literal(ExpressionLiteral::Boolean(1)), span}
                    ) else -1
                ) else -1
            ) else -1
        ) else -1
    ) else if input(start) == 'f' then (
        if input(start + 1) == 'a' then (
            if input(start + 2) == 'l' then (
                if input(start + 3) == 's' then (
                    if input(start + 4) == 'e' then (
                        if is_ident_char(input(start + 5)) == 0 then (
                            state.cursor = start + 5;
                            span := make_span{start, state.cursor};
                            new_node{NodeKind::Literal(ExpressionLiteral::Boolean(0)), span}
                        ) else -1
                    ) else -1
                ) else -1
            ) else -1
        ) else -1
    ) else (
        -1
    )
);

parse_char_literal := (ignored: i32) => (
    start := state.cursor;
    if input(start) != '\'' then -1 else (
        state.cursor = start + 1;
        mut value := 0;
        value = input(state.cursor);
        if value == '\\' then (
            state.cursor = state.cursor + 1;
            esc := input(state.cursor);
            if esc == 'n' then value = 10 else (
                if esc == 'r' then value = 13 else (
                    if esc == 't' then value = 9 else (
                        if esc == '0' then value = 0 else (
                            if esc == '\'' then value = 39 else (
                                if esc == '"' then value = 34 else (
                                    if esc == '\\' then value = 92 else value
                                )
                            )
                        )
                    )
                )
            );
            0
        ) else (
            0
        );
        state.cursor = state.cursor + 1;
        if input(state.cursor) != '\'' then (
            set_error(state.cursor);
            -1
        ) else (
            state.cursor = state.cursor + 1;
            span := make_span{start, state.cursor};
            new_node{NodeKind::Literal(ExpressionLiteral::Char(value)), span}
        )
    )
);

parse_string_literal := (ignored: i32) => (
    start := state.cursor;
    if input(start) != '"' then -1 else (
        state.cursor = start + 1;
        content_start := state.cursor;
        mut done := 0;
        mut result := -1;
        while done == 0 do (
            if input(state.cursor) == 0 then (
                done = 1;
                0
            ) else (
                if input(state.cursor) == '"' then (
                    content_end := state.cursor;
                    state.cursor = state.cursor + 1;
                    span := make_span{start, state.cursor};
                    str_ref := make_string_ref{content_start, content_end - content_start};
                    result = new_node{NodeKind::Literal(ExpressionLiteral::String(str_ref)), span};
                    done = 1;
                    0
                ) else (
                    if input(state.cursor) == '\\' then (
                        state.cursor = state.cursor + 1;
                        if input(state.cursor) != 0 then (
                            state.cursor = state.cursor + 1;
                            0
                        ) else (
                            0
                        );
                        0
                    ) else (
                        state.cursor = state.cursor + 1;
                        0
                    )
                )
            );
            {}
        );
        if result == -1 then (
            set_error(state.cursor);
            -1
        ) else (
            result
        )
    )
);

parse_literal := (ignored: i32) => (
    if input(state.cursor) == '\'' then (
        parse_char_literal(0)
    ) else (
        if input(state.cursor) == '"' then (
            parse_string_literal(0)
        ) else (
            if input(state.cursor) == '-' then (
                if is_digit(input(state.cursor + 1)) == 1 then parse_number(0) else parse_boolean_literal(0)
            ) else (
                if is_digit(input(state.cursor)) == 1 then parse_number(0) else parse_boolean_literal(0)
            )
        )
    )
);

parse_basic_operand_no_group := (ignored: i32) => (
    skip_ws(0);
    ch := input(state.cursor);
    lit := parse_literal(0);
    if lit != -1 then lit else (
        if is_alpha(ch) == 1 then (
            parse_identifier(0)
        ) else (
            set_error(state.cursor);
            -1
        )
    )
);

new_operation := {left: i32, right: i32, op_pos: i32} => (
    op_ref := make_string_ref{op_pos, 1};
    span := make_span{nodes(left).span.start, span_end(right)};
    new_node{NodeKind::Operation({ operator = op_ref, left = left, right = right }), span}
);

make_empty_struct := (pos: i32) => (
    span := make_span{pos, pos};
    new_node{NodeKind::Struct({ fields = -1 }), span}
);

list_append := {head: i32, value: i32} => (
    if head == -1 then (
        new_list_node{value, -1}
    ) else (
        mut cur := head;
        while list_nodes(cur).next != -1 do (
            cur = list_nodes(cur).next;
            {}
        );
        new_idx := new_list_node{value, -1};
        list_nodes(cur).next = new_idx;
        head
    )
);



extract_binding_annotations := (expr_idx: i32) => (
    mut current := expr_idx;
    mut args_head := -1;
    mut continue := 1;
    while continue == 1 do (
        if NodeKind::FunctionCall(info) := nodes(current).kind then (
            if NodeKind::FunctionCall(_) := nodes(info.function).kind then (
                args_head = new_list_node{info.argument, args_head};
                current = info.function;
            ) else (
                continue = 0;
            )
        ) else (
            continue = 0;
        );
        {}
    );
    mut head := new_list_node{current, -1};
    mut arg_cur := args_head;
    while arg_cur != -1 do (
        head = list_append{head, list_nodes(arg_cur).value};
        arg_cur = list_nodes(arg_cur).next;
        {}
    );
    head
);

pattern_from_expression := (expr_idx: i32) => (
    span := nodes(expr_idx).span;
    if NodeKind::Literal(lit) := nodes(expr_idx).kind then (
        BindingPattern::Literal({ literal = lit, span = span })
    ) else if NodeKind::Identifier(id) := nodes(expr_idx).kind then (
        BindingPattern::Identifier({ name = id, span = span })
    ) else if NodeKind::Struct(info) := nodes(expr_idx).kind then (
        BindingPattern::Struct({ fields = info.fields, span = span })
    ) else if NodeKind::Operation(op) := nodes(expr_idx).kind then (
        if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
            BindingPattern::TypeHint({ pattern = op.left, type_expr = op.right, span = span })
        ) else (
            BindingPattern::Identifier({ name = EMPTY_IDENTIFIER, span = span })
        )
    ) else if NodeKind::TypePropertyAccess(info) := nodes(expr_idx).kind then (
        variant_id := { name = info.property, unique = info.property };
        BindingPattern::EnumVariant({ enum_type = info.object, variant = variant_id, payload = -1, span = span })
    ) else if NodeKind::FunctionCall(call) := nodes(expr_idx).kind then (
        if NodeKind::TypePropertyAccess(info) := nodes(call.function).kind then (
            variant_id := { name = info.property, unique = info.property };
            BindingPattern::EnumVariant({ enum_type = info.object, variant = variant_id, payload = call.argument, span = span })
        ) else (
            annotations := extract_binding_annotations(call.function);
            BindingPattern::Annotated({ annotations = annotations, pattern = call.argument, span = span })
        )
    ) else (
        set_error(span.start);
        BindingPattern::Identifier({ name = EMPTY_IDENTIFIER, span = span })
    )
);

string_ref_is_box := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 3 then 0 else (
        if input(value.start) == 'B' then (
            if input(value.start + 1) == 'o' then (
                if input(value.start + 2) == 'x' then 1 else 0
            ) else 0
        ) else 0
    )
);

get_property_from_node := (expr_idx: i32) => (
    if NodeKind::Identifier(id) := nodes(expr_idx).kind then (
        id.name
    ) else if NodeKind::Literal(ExpressionLiteral::Number(_)) := nodes(expr_idx).kind then (
        make_string_ref{nodes(expr_idx).span.start, nodes(expr_idx).span.length}
    ) else (
        set_error(nodes(expr_idx).span.start);
        EMPTY_STRING
    )
);

expression_to_lvalue := (expr_idx: i32) => (
    if NodeKind::Identifier(id) := nodes(expr_idx).kind then (
        LValue::Identifier({ name = id, span = nodes(expr_idx).span })
    ) else if NodeKind::TypePropertyAccess(info) := nodes(expr_idx).kind then (
        LValue::TypePropertyAccess({ object = info.object, property = info.property, span = nodes(expr_idx).span })
    ) else if NodeKind::FunctionCall(call) := nodes(expr_idx).kind then (
        if NodeKind::TypePropertyAccess(info) := nodes(call.function).kind then (
            LValue::TypePropertyAccess({ object = info.object, property = info.property, span = nodes(expr_idx).span })
        ) else (
            LValue::ArrayIndex({ array = call.function, index = call.argument, span = nodes(expr_idx).span })
        )
    ) else (
        set_error(nodes(expr_idx).span.start);
        LValue::Identifier({ name = EMPTY_IDENTIFIER, span = nodes(expr_idx).span })
    )
);

new_binary_operation := {left: i32, right: i32, op_start: i32, op_len: i32} => (
    op_ref := make_string_ref{op_start, op_len};
    span := make_span{nodes(left).span.start, span_end(right)};
    if op_is2{op_start, op_len, ':', '='} == 1 then (
        pattern := pattern_from_expression(left);
        binding := { pattern = pattern, expr = right };
        new_node{NodeKind::Binding(binding), span}
    ) else if op_is1{op_start, op_len, '='} == 1 then (
        target := expression_to_lvalue(left);
        assignment := { target = target, expr = right };
        new_node{NodeKind::Assignment(assignment), span}
    ) else if op_is2{op_start, op_len, '=', '>'} == 1 then (
        param := pattern_from_expression(left);
        func := { parameter = param, return_type = -1, body = right };
        new_node{NodeKind::Function(func), span}
    ) else if op_is2{op_start, op_len, '-', '>'} == 1 then (
        func_ty := { parameter = left, return_type = right };
        new_node{NodeKind::FunctionType(func_ty), span}
    ) else if op_is2{op_start, op_len, ':', ':'} == 1 then (
        prop := get_property_from_node(right);
        new_node{NodeKind::TypePropertyAccess({ object = left, property = prop }), span}
    ) else if op_is1{op_start, op_len, '.'} == 1 then (
        prop := get_property_from_node(right);
        access := new_node{NodeKind::TypePropertyAccess({ object = left, property = prop }), span};
        new_node{NodeKind::FunctionCall({ function = access, argument = left }), span}
    ) else if op_is0(op_len) == 1 then (
        if NodeKind::Identifier(id) := nodes(left).kind then (
            if string_ref_is_box(id.name) == 1 then (
                new_node{NodeKind::BoxType(right), span}
            ) else (
                new_node{NodeKind::FunctionCall({ function = left, argument = right }), span}
            )
        ) else (
            new_node{NodeKind::FunctionCall({ function = left, argument = right }), span}
        )
    ) else if op_is2{op_start, op_len, '|', '>'} == 1 then (
        new_node{NodeKind::FunctionCall({ function = right, argument = left }), span}
    ) else if op_is1{op_start, op_len, '@'} == 1 then (
        new_node{NodeKind::AttachImplementation({ type_expr = left, implementation = right }), span}
    ) else (
        new_node{NodeKind::Operation({ operator = op_ref, left = left, right = right }), span}
    )
);

parse_expr_prec_no_group := (min_prec: i32) => (
    left := parse_basic_operand(0);
    if left == -1 then -1 else (
        mut op_head := -1;
        mut val_head := -1;
        val_head = new_list_node{left, -1};
        mut done := 0;
        while done == 0 do (
            skip_ws(0);
            op_start := state.cursor;
            op_len := scan_operator_len(state.cursor);
            if op_len == -1 then (
                done = 1;
            ) else (
                op_prec := op_precedence_ref{op_start, op_len};
                if op_prec < min_prec then (
                    done = 1;
                ) else (
                    while op_head != -1 do (
                        top_packed := list_nodes(op_head).value;
                        top_start := top_packed / 4;
                        top_len := top_packed - (top_start * 4);
                        top_prec := op_precedence_ref{top_start, top_len};
                        if top_prec < op_prec then (
                            break;
                            0
                        ) else (
                            0
                        );
                        right := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        left_val := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        combined := new_binary_operation{left_val, right, top_start, top_len};
                        val_head = new_list_node{combined, val_head};
                        op_head = list_nodes(op_head).next;
                        {}
                    );
                    op_head = new_list_node{(op_start * 4 + op_len), op_head};
                    if op_len > 0 then (
                        state.cursor = state.cursor + op_len;
                        0
                    ) else (
                        0
                    );
                    right := parse_basic_operand(0);
                    if right == -1 then (
                        val_head = -1;
                        done = 1;
                    ) else (
                        val_head = new_list_node{right, val_head};
                    )
                )
            );
            {}
        );
        if val_head == -1 then -1 else (
            while op_head != -1 do (
                top_packed := list_nodes(op_head).value;
                top_start := top_packed / 4;
                top_len := top_packed - (top_start * 4);
                right := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                left_val := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                combined := new_binary_operation{left_val, right, top_start, top_len};
                val_head = new_list_node{combined, val_head};
                op_head = list_nodes(op_head).next;
                {}
            );
            list_nodes(val_head).value
        )
    )
);

parse_basic_operand_with_paren := (ignored: i32) => (
    skip_ws(0);
    ch := input(state.cursor);
    if ch == '(' then (
        state.cursor = state.cursor + 1;
        expr := parse_block(0);
        if expr == -1 then -1 else (
            skip_ws(0);
            if input(state.cursor) == ')' then (
                state.cursor = state.cursor + 1;
                expr
            ) else (
                set_error(state.cursor);
                -1
            )
        )
    ) else (
        parse_basic_operand(0)
    )
);

parse_expr_prec_with_paren := (min_prec: i32) => (
    left := parse_basic_operand_with_paren(0);
    if left == -1 then -1 else (
        mut op_head := -1;
        mut val_head := -1;
        val_head = new_list_node{left, -1};
        mut done := 0;
        while done == 0 do (
            skip_ws(0);
            op_start := state.cursor;
            op_len := scan_operator_len(state.cursor);
            if op_len == -1 then (
                done = 1;
            ) else (
                op_prec := op_precedence_ref{op_start, op_len};
                if op_prec < min_prec then (
                    done = 1;
                ) else (
                    while op_head != -1 do (
                        top_packed := list_nodes(op_head).value;
                        top_start := top_packed / 4;
                        top_len := top_packed - (top_start * 4);
                        top_prec := op_precedence_ref{top_start, top_len};
                        if top_prec < op_prec then (
                            break;
                            0
                        ) else (
                            0
                        );
                        right := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        left_val := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        combined := new_binary_operation{left_val, right, top_start, top_len};
                        val_head = new_list_node{combined, val_head};
                        op_head = list_nodes(op_head).next;
                        {}
                    );
                    op_head = new_list_node{(op_start * 4 + op_len), op_head};
                    if op_len > 0 then (
                        state.cursor = state.cursor + op_len;
                        0
                    ) else (
                        0
                    );
                    right := parse_basic_operand_with_paren(0);
                    if right == -1 then (
                        val_head = -1;
                        done = 1;
                    ) else (
                        val_head = new_list_node{right, val_head};
                    )
                )
            );
            {}
        );
        if val_head == -1 then -1 else (
            while op_head != -1 do (
                top_packed := list_nodes(op_head).value;
                top_start := top_packed / 4;
                top_len := top_packed - (top_start * 4);
                right := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                left_val := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                combined := new_binary_operation{left_val, right, top_start, top_len};
                val_head = new_list_node{combined, val_head};
                op_head = list_nodes(op_head).next;
                {}
            );
            list_nodes(val_head).value
        )
    )
);

parse_paren_expr := (ignored: i32) => (
    if input(state.cursor) != '(' then -1 else (
        state.cursor = state.cursor + 1;
        expr := parse_block(0);
        if expr == -1 then -1 else (
            skip_ws(0);
            if input(state.cursor) == ')' then (
                state.cursor = state.cursor + 1;
                expr
            ) else (
                set_error(state.cursor);
                -1
            )
        )
    )
);

parse_struct_expr := (ignored: i32) => (
    start := state.cursor;
    if input(state.cursor) != '{' then -1 else (
        state.cursor = state.cursor + 1;
        skip_ws(0);
        if input(state.cursor) == '}' then (
            state.cursor = state.cursor + 1;
            span := make_span{start, state.cursor};
            new_node{NodeKind::Struct({ fields = -1 }), span}
        ) else (
            mut fields_head := -1;
            mut field_count := 0;
            mut done := 0;
            mut result := -1;
            while done == 0 do (
                skip_ws(0);
                mut named := 0;
                mut name_id := EMPTY_IDENTIFIER;
                mut name_span := EMPTY_SPAN;
                if is_alpha(input(state.cursor)) == 1 then (
                    id_start := state.cursor;
                    id_end := scan_identifier_end(id_start);
                    mut look := id_end;
                    while is_space(input(look)) == 1 do (
                        look = look + 1;
                        {}
                    );
                    if input(look) == '=' then (
                        if input(look + 1) == '>' || input(look + 1) == '=' then (
                            named = 0;
                        ) else (
                            named = 1;
                            name_id = make_identifier{id_start, id_end};
                            name_span = make_span{id_start, id_end};
                            state.cursor = look + 1;
                        );
                        0
                    ) else (
                        0
                    );
                    0
                ) else (
                    0
                );
                mut value_expr := -1;
                if named == 1 then (
                    value_expr = parse_expr_prec_with_paren(0);
                    0
                ) else (
                    value_expr = parse_expr_prec_with_paren(0);
                    name_id = EMPTY_IDENTIFIER;
                    name_span = make_span{state.cursor, state.cursor};
                    0
                );
                if value_expr == -1 then (
                    done = 1;
                    0
                ) else (
                    binding := { pattern = BindingPattern::Identifier({ name = name_id, span = name_span }), expr = value_expr };
                    span := make_span{start, span_end(value_expr)};
                    binding_node := new_node{NodeKind::Binding(binding), span};
                    fields_head = list_append{fields_head, binding_node};
                    field_count = field_count + 1;
                    skip_ws(0);
                    if input(state.cursor) == ';' then (
                        if field_count != 1 || named == 1 then (
                            set_error(state.cursor);
                            done = 1;
                            0
                        ) else (
                            state.cursor = state.cursor + 1;
                            repeat_count := parse_expr_prec_with_paren(0);
                            skip_ws(0);
                            if input(state.cursor) != '}' then (
                                set_error(state.cursor);
                                done = 1;
                                0
                            ) else (
                                state.cursor = state.cursor + 1;
                                span := make_span{start, state.cursor};
                                array_repeat := { value = value_expr, count = repeat_count };
                                result = new_node{NodeKind::ArrayRepeat(array_repeat), span};
                                done = 1;
                                0
                            )
                        )
                    ) else (
                        ch := input(state.cursor);
                        ch |> match {
                            '}' => (
                                state.cursor = state.cursor + 1;
                                done = 1;
                                0
                            ),
                            ',' => (
                                state.cursor = state.cursor + 1;
                                skip_ws(0);
                                if input(state.cursor) == '}' then (
                                    state.cursor = state.cursor + 1;
                                    done = 1;
                                    0
                                ) else (
                                    0
                                );
                                0
                            ),
                            else => (
                                set_error(state.cursor);
                                done = 1;
                                0
                            )
                        }
                    )
                );
                {}
            );
            if result != -1 then (
                result
            ) else (
                span := make_span{start, state.cursor};
                new_node{NodeKind::Struct({ fields = fields_head }), span}
            )
        )
    )
);

parse_if_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_if(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 2;
        skip_ws(0);
        condition := parse_expr_prec_no_group(0);
        if condition == -1 then -1 else (
            skip_ws(0);
            if is_keyword_then(state.cursor) == 0 then (
                set_error(state.cursor);
                -1
            ) else (
                state.cursor = state.cursor + 4;
                skip_ws(0);
                then_branch := parse_expr_prec_no_group(0);
                if then_branch == -1 then -1 else (
                    skip_ws(0);
                    mut else_branch := -1;
                    if is_keyword_else(state.cursor) == 1 then (
                        state.cursor = state.cursor + 4;
                        skip_ws(0);
                        else_branch = parse_expr_prec_no_group(0);
                    ) else (
                        else_branch = make_empty_struct(state.cursor);
                    );
                    span := make_span{start, span_end(then_branch)};
                    new_node{NodeKind::If({ condition = condition, then_branch = then_branch, else_branch = else_branch }), span}
                )
            )
        )
    )
);

parse_loop_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_loop(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 4;
        skip_ws(0);
        body := parse_paren_expr(0);
        if body == -1 then -1 else (
            span := make_span{start, span_end(body)};
            new_node{NodeKind::Loop({ body = body }), span}
        )
    )
);

parse_while_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_while(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 5;
        skip_ws(0);
        condition := parse_expr_prec_no_group(0);
        if condition == -1 then -1 else (
            skip_ws(0);
            if is_keyword_do(state.cursor) == 0 then (
                set_error(state.cursor);
                -1
            ) else (
                state.cursor = state.cursor + 2;
                skip_ws(0);
                body := parse_paren_expr(0);
                if body == -1 then -1 else (
                    break_node := new_node{NodeKind::Diverge({ value = make_empty_struct(state.cursor), divergance_type = DivergeExpressionType::Break }), make_span{start, start}};
                    if_node := new_node{NodeKind::If({ condition = condition, then_branch = body, else_branch = break_node }), make_span{start, span_end(body)}};
                    span := make_span{start, span_end(body)};
                    new_node{NodeKind::Loop({ body = if_node }), span}
                )
            )
        )
    )
);

parse_for_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_for(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 3;
        skip_ws(0);
        pattern_expr := parse_expr_prec_with_paren(0);
        if pattern_expr == -1 then -1 else (
            skip_ws(0);
            if is_keyword_in(state.cursor) == 0 then (
                set_error(state.cursor);
                -1
            ) else (
                state.cursor = state.cursor + 2;
                skip_ws(0);
                iterator_expr := parse_expr_prec_with_paren(0);
                if iterator_expr == -1 then -1 else (
                    skip_ws(0);
                    if is_keyword_do(state.cursor) == 0 then (
                        set_error(state.cursor);
                        -1
                    ) else (
                        state.cursor = state.cursor + 2;
                        skip_ws(0);
                        body := parse_paren_expr(0);
                        if body == -1 then -1 else (
                            overall_span := make_span{start, state.cursor};
                            iter_span := nodes(iterator_expr).span;
                            mut iter_id := EMPTY_IDENTIFIER;
                            if NodeKind::Identifier(id) := nodes(iterator_expr).kind then (
                                iter_id = id;
                            ) else (
                                iter_id = { name = SYNTHETIC_FOR_ITER_STRING, unique = SYNTHETIC_FOR_ITER_STRING };
                            );
                            mut_id := { name = SYNTHETIC_MUT_STRING, unique = SYNTHETIC_MUT_STRING };
                            mut_node := new_node{NodeKind::Identifier(mut_id), iter_span};
                            annotations_head := new_list_node{mut_node, -1};
                            iter_pattern_expr := new_node{NodeKind::Identifier(iter_id), iter_span};
                            iter_binding_pattern := BindingPattern::Annotated({
                                annotations = annotations_head,
                                pattern = iter_pattern_expr,
                                span = iter_span
                            });
                            iter_binding := { pattern = iter_binding_pattern, expr = iterator_expr };
                            iter_binding_node := new_node{NodeKind::Binding(iter_binding), iter_span};

                            iter_ident_expr := new_node{NodeKind::Identifier(iter_id), overall_span};
                            iter_arg_expr := new_node{NodeKind::Identifier(iter_id), overall_span};
                            iter_ty_access := new_node{NodeKind::TypePropertyAccess({
                                object = iter_ident_expr,
                                property = SYNTHETIC_ITER_TY_STRING
                            }), overall_span};
                            option_id := { name = SYNTHETIC_OPTION_STRING, unique = SYNTHETIC_OPTION_STRING };
                            option_node := new_node{NodeKind::Identifier(option_id), overall_span};
                            option_call := new_node{NodeKind::FunctionCall({
                                function = option_node,
                                argument = iter_ty_access
                            }), overall_span};
                            some_id := { name = SYNTHETIC_SOME_STRING, unique = SYNTHETIC_SOME_STRING };
                            condition_pattern := BindingPattern::EnumVariant({
                                enum_type = option_call,
                                variant = some_id,
                                payload = pattern_expr,
                                span = overall_span
                            });
                            next_access := new_node{NodeKind::TypePropertyAccess({
                                object = iter_ident_expr,
                                property = SYNTHETIC_NEXT_STRING
                            }), overall_span};
                            next_call := new_node{NodeKind::FunctionCall({
                                function = next_access,
                                argument = iter_arg_expr
                            }), overall_span};
                            condition_binding := { pattern = condition_pattern, expr = next_call };
                            condition_expr := new_node{NodeKind::Binding(condition_binding), overall_span};
                            empty_struct := new_node{NodeKind::Struct({ fields = -1 }), overall_span};
                            break_node := new_node{NodeKind::Diverge({
                                value = empty_struct,
                                divergance_type = DivergeExpressionType::Break
                            }), overall_span};
                            if_node := new_node{NodeKind::If({
                                condition = condition_expr,
                                then_branch = body,
                                else_branch = break_node
                            }), overall_span};
                            loop_node := new_node{NodeKind::Loop({ body = if_node }), overall_span};

                            mut list_head := new_list_node{iter_binding_node, -1};
                            list_head = list_append{list_head, loop_node};
                            list := { count = 2, head = list_head };
                            new_node{NodeKind::Block(list), overall_span}
                        )
                    )
                )
            )
        )
    )
);

parse_return_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_return(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 6;
        skip_ws(0);
        if input(state.cursor) == 0 || input(state.cursor) == ';' || input(state.cursor) == ')' || input(state.cursor) == '}' || input(state.cursor) == ',' then (
            value := make_empty_struct(state.cursor);
            span := make_span{start, span_end(value)};
            new_node{NodeKind::Diverge({ value = value, divergance_type = DivergeExpressionType::Return }), span}
        ) else (
            value := parse_expr_prec_no_group(0);
            if value == -1 then -1 else (
                span := make_span{start, span_end(value)};
                new_node{NodeKind::Diverge({ value = value, divergance_type = DivergeExpressionType::Return }), span}
            )
        )
    )
);

parse_break_expr := (ignored: i32) => (
    start := state.cursor;
    if is_keyword_break(state.cursor) == 0 then -1 else (
        state.cursor = state.cursor + 5;
        skip_ws(0);
        if input(state.cursor) == 0 || input(state.cursor) == ';' || input(state.cursor) == ')' || input(state.cursor) == '}' || input(state.cursor) == ',' then (
            value := make_empty_struct(state.cursor);
            span := make_span{start, span_end(value)};
            new_node{NodeKind::Diverge({ value = value, divergance_type = DivergeExpressionType::Break }), span}
        ) else (
            value := parse_expr_prec_no_group(0);
            if value == -1 then -1 else (
                span := make_span{start, span_end(value)};
                new_node{NodeKind::Diverge({ value = value, divergance_type = DivergeExpressionType::Break }), span}
            )
        )
    )
);

parse_basic_operand := (ignored: i32) => (
    skip_ws(0);
    ch := input(state.cursor);
    if ch == '(' then (
        parse_paren_expr(0)
    ) else if ch == '{' then (
        parse_struct_expr(0)
    ) else if is_keyword_if(state.cursor) == 1 then (
        parse_if_expr(0)
    ) else if is_keyword_for(state.cursor) == 1 then (
        parse_for_expr(0)
    ) else if is_keyword_while(state.cursor) == 1 then (
        parse_while_expr(0)
    ) else if is_keyword_loop(state.cursor) == 1 then (
        parse_loop_expr(0)
    ) else if is_keyword_return(state.cursor) == 1 then (
        parse_return_expr(0)
    ) else if is_keyword_break(state.cursor) == 1 then (
        parse_break_expr(0)
    ) else (
        parse_basic_operand_no_group(0)
    )
);

parse_operand := (ignored: i32) => (
    parse_basic_operand(0)
);

parse_expr_prec := (min_prec: i32) => (
    left := parse_operand(0);
    if left == -1 then -1 else (
        mut op_head := -1;
        mut val_head := -1;
        val_head = new_list_node{left, -1};
        mut done := 0;
        while done == 0 do (
            skip_ws(0);
            op_start := state.cursor;
            op_len := scan_operator_len(state.cursor);
            if op_len == -1 then (
                done = 1;
            ) else (
                op_prec := op_precedence_ref{op_start, op_len};
                if op_prec < min_prec then (
                    done = 1;
                ) else (
                    while op_head != -1 do (
                        top_packed := list_nodes(op_head).value;
                        top_start := top_packed / 4;
                        top_len := top_packed - (top_start * 4);
                        top_prec := op_precedence_ref{top_start, top_len};
                        if top_prec < op_prec then (
                            break;
                            0
                        ) else (
                            0
                        );
                        right := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        left_val := list_nodes(val_head).value;
                        val_head = list_nodes(val_head).next;
                        combined := new_binary_operation{left_val, right, top_start, top_len};
                        val_head = new_list_node{combined, val_head};
                        op_head = list_nodes(op_head).next;
                        {}
                    );
                    op_head = new_list_node{(op_start * 4 + op_len), op_head};
                    if op_len > 0 then (
                        state.cursor = state.cursor + op_len;
                        0
                    ) else (
                        0
                    );
                    right := parse_operand(0);
                    if right == -1 then (
                        val_head = -1;
                        done = 1;
                    ) else (
                        val_head = new_list_node{right, val_head};
                    )
                )
            );
            {}
        );
        if val_head == -1 then -1 else (
            while op_head != -1 do (
                top_packed := list_nodes(op_head).value;
                top_start := top_packed / 4;
                top_len := top_packed - (top_start * 4);
                right := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                left_val := list_nodes(val_head).value;
                val_head = list_nodes(val_head).next;
                combined := new_binary_operation{left_val, right, top_start, top_len};
                val_head = new_list_node{combined, val_head};
                op_head = list_nodes(op_head).next;
                {}
            );
            list_nodes(val_head).value
        )
    )
);

parse_operand := (ignored: i32) => (
    parse_basic_operand(0)
);

parse_expr := (ignored: i32) => (
    parse_expr_prec(0)
);

parse_statement := (ignored: i32) => (
    parse_expr(0)
);

parse_block := (ignored: i32) => (
    block_start := state.cursor;
    skip_ws(0);
    if input(state.cursor) == 0 then (
        set_error(state.cursor);
        -1
    ) else (
        mut count := 0;
        mut head := -1;
        mut tail := -1;
        mut last_expr := -1;
        mut ended_with_semicolon := 0;
        expr := parse_statement(0);
        if expr == -1 then -1 else (
            head = new_list_node{expr, -1};
            tail = head;
            last_expr = expr;
            count = 1;
            skip_ws(0);
            while input(state.cursor) == ';' do (
                state.cursor = state.cursor + 1;
                skip_ws(0);
                if input(state.cursor) == 0 || input(state.cursor) == ')' || input(state.cursor) == '}' then (
                    ended_with_semicolon = 1;
                    break;
                    0
                ) else (
                    0
                );
                next_expr := parse_statement(0);
                if next_expr == -1 then (
                    ended_with_semicolon = 1;
                ) else (
                    next_node := new_list_node{next_expr, -1};
                    list_nodes(tail).next = next_node;
                    tail = next_node;
                    last_expr = next_expr;
                    count = count + 1;
                );
                skip_ws(0);
                {};
            );
            if ended_with_semicolon == 0 then (
                if input(state.cursor) == 0 || input(state.cursor) == ')' || input(state.cursor) == '}' then (
                    mut back := state.cursor - 1;
                    while back >= 0 && is_space(input(back)) == 1 do (
                        back = back - 1;
                        {}
                    );
                    if back >= 0 && input(back) == ';' then (
                        ended_with_semicolon = 1;
                        0
                    ) else (
                        0
                    );
                    0
                ) else (
                    0
                );
                0
            ) else (
                0
            );
            if ended_with_semicolon == 1 then (
                empty_span := make_span{span_end(last_expr), span_end(last_expr)};
                empty_expr := new_node{NodeKind::Struct({ fields = -1 }), empty_span};
                new_tail := new_list_node{empty_expr, -1};
                list_nodes(tail).next = new_tail;
                tail = new_tail;
                last_expr = empty_expr;
                count = count + 1;
                0
            ) else (
                0
            );
            if count == 1 && ended_with_semicolon == 0 then (
                expr
            ) else (
                list := { count = count, head = head };
                span := make_span{block_start, span_end(last_expr)};
                new_node{NodeKind::Block(list), span}
            )
        )
    )
);

(export wasm) parse := {} => (
    state.count = 0;
    state.list_count = 0;
    state.error = -1;
    state.cursor = 0;

    root := parse_block(0);
    skip_ws(0);
    if state.error != -1 then (
        -1
    ) else if input(state.cursor) != 0 then (
        set_error(state.cursor);
        -1
    ) else (
        root
    )
);

(export wasm) parse_at := (start: i32) => (
    state.error = -1;
    state.cursor = start;

    root := parse_block(0);
    skip_ws(0);
    if state.error != -1 then (
        -1
    ) else if input(state.cursor) != 0 then (
        set_error(state.cursor);
        -1
    ) else (
        root
    )
);

(export wasm) get_state_error := {} => (
    state.error
);

(export wasm) get_kind_tag := (idx: i32) => (
    kind := nodes(idx).kind;
    kind |> match {
        NodeKind::IntrinsicType(_) => 0,
        NodeKind::BoxType(_) => 1,
        NodeKind::IntrinsicOperation(_) => 2,
        NodeKind::EnumType(_) => 3,
        NodeKind::Match(_) => 4,
        NodeKind::EnumValue(_) => 5,
        NodeKind::EnumConstructor(_) => 6,
        NodeKind::If(_) => 7,
        NodeKind::AttachImplementation(_) => 8,
        NodeKind::Function(_) => 9,
        NodeKind::FunctionType(_) => 10,
        NodeKind::Struct(_) => 11,
        NodeKind::ArrayRepeat(_) => 12,
        NodeKind::Literal(_) => 13,
        NodeKind::Identifier(_) => 14,
        NodeKind::Operation(_) => 15,
        NodeKind::Assignment(_) => 16,
        NodeKind::FunctionCall(_) => 17,
        NodeKind::ArrayIndex(_) => 18,
        NodeKind::TypePropertyAccess(_) => 19,
        NodeKind::Binding(_) => 20,
        NodeKind::Block(_) => 21,
        NodeKind::Diverge(_) => 22,
        else => 23
    }
);

(export wasm) get_span_start := (idx: i32) => (
    nodes(idx).span.start
);

(export wasm) get_span_length := (idx: i32) => (
    nodes(idx).span.length
);

(export wasm) get_literal_number := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::Number(value)) := nodes(idx).kind then value else -1
);

(export wasm) get_literal_boolean := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::Boolean(value)) := nodes(idx).kind then value else -1
);

(export wasm) get_literal_char := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::Char(value)) := nodes(idx).kind then value else -1
);

(export wasm) get_literal_string_start := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::String(value)) := nodes(idx).kind then value.start else -1
);

(export wasm) get_literal_string_length := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::String(value)) := nodes(idx).kind then value.length else 0
);

literal_tag := (lit: ExpressionLiteral) => (
    lit |> match {
        ExpressionLiteral::Number(_) => 0,
        ExpressionLiteral::Boolean(_) => 1,
        ExpressionLiteral::Char(_) => 2,
        ExpressionLiteral::String(_) => 3,
        ExpressionLiteral::Target(_) => 4,
        ExpressionLiteral::BindingAnnotation(_) => 5,
        else => -1
    }
);

(export wasm) get_literal_tag := (idx: i32) => (
    if NodeKind::Literal(lit) := nodes(idx).kind then literal_tag(lit) else -1
);

target_literal_tag := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => 0,
        TargetLiteral::WasmTarget => 1,
        TargetLiteral::WgslTarget => 2,
        else => -1
    }
);

(export wasm) get_literal_target_tag := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::Target(value)) := nodes(idx).kind then (
        target_literal_tag(value)
    ) else -1
);

binding_annotation_tag := (ann: BindingAnnotationLiteral) => (
    ann |> match {
        BindingAnnotationLiteral::Mut => 0,
        BindingAnnotationLiteral::Export(_) => 1,
        BindingAnnotationLiteral::Target(_) => 2,
        BindingAnnotationLiteral::Wrap(_) => 3,
        else => -1
    }
);

(export wasm) get_literal_binding_annotation_tag := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) := nodes(idx).kind then (
        binding_annotation_tag(value)
    ) else -1
);

(export wasm) get_literal_binding_annotation_target_tag := (idx: i32) => (
    if NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) := nodes(idx).kind then (
        value |> match {
            BindingAnnotationLiteral::Export(target) => target_literal_tag(target),
            BindingAnnotationLiteral::Target(target) => target_literal_tag(target),
            BindingAnnotationLiteral::Wrap(target) => target_literal_tag(target),
            else => -1
        }
    ) else -1
);

(export wasm) get_identifier_start := (idx: i32) => (
    if NodeKind::Identifier(id) := nodes(idx).kind then id.name.start else -1
);

(export wasm) get_identifier_length := (idx: i32) => (
    if NodeKind::Identifier(id) := nodes(idx).kind then id.name.length else 0
);

(export wasm) get_operation_left := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.left else -1
);

(export wasm) get_operation_right := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.right else -1
);

(export wasm) get_operation_operator_start := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.operator.start else -1
);

(export wasm) get_operation_operator_length := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then op.operator.length else 0
);

(export wasm) get_operation_is_typehint := (idx: i32) => (
    if NodeKind::Operation(op) := nodes(idx).kind then (
        if op_is1{op.operator.start, op.operator.length, ':'} == 1 then 1 else 0
    ) else 0
);

binding_pattern_literal_tag := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => literal_tag(info.literal),
        else => -1
    }
);

binding_pattern_literal_number := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::Number(value) := info.literal then value else 0
        ),
        else => 0
    }
);

binding_pattern_literal_boolean := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::Boolean(value) := info.literal then value else 0
        ),
        else => 0
    }
);

binding_pattern_literal_char := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::Char(value) := info.literal then value else 0
        ),
        else => 0
    }
);

binding_pattern_literal_string_start := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::String(value) := info.literal then value.start else -1
        ),
        else => -1
    }
);

binding_pattern_literal_string_length := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::String(value) := info.literal then value.length else 0
        ),
        else => 0
    }
);

binding_pattern_literal_target_tag := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::Target(value) := info.literal then target_literal_tag(value) else -1
        ),
        else => -1
    }
);

binding_pattern_literal_binding_annotation_tag := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::BindingAnnotation(value) := info.literal then binding_annotation_tag(value) else -1
        ),
        else => -1
    }
);

binding_pattern_literal_binding_annotation_target_tag := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Literal(info) => (
            if ExpressionLiteral::BindingAnnotation(value) := info.literal then (
                value |> match {
                    BindingAnnotationLiteral::Export(target) => target_literal_tag(target),
                    BindingAnnotationLiteral::Target(target) => target_literal_tag(target),
                    BindingAnnotationLiteral::Wrap(target) => target_literal_tag(target),
                    else => -1
                }
            ) else -1
        ),
        else => -1
    }
);

(export wasm) get_binding_expr := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then binding.expr else -1
);

(export wasm) get_binding_pattern_literal_tag := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_tag(binding.pattern)
    ) else -1
);

(export wasm) get_binding_pattern_literal_number := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_number(binding.pattern)
    ) else 0
);

(export wasm) get_binding_pattern_literal_boolean := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_boolean(binding.pattern)
    ) else 0
);

(export wasm) get_binding_pattern_literal_char := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_char(binding.pattern)
    ) else 0
);

(export wasm) get_binding_pattern_literal_string_start := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_string_start(binding.pattern)
    ) else -1
);

(export wasm) get_binding_pattern_literal_string_length := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_string_length(binding.pattern)
    ) else 0
);

(export wasm) get_binding_pattern_literal_target_tag := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_target_tag(binding.pattern)
    ) else -1
);

(export wasm) get_binding_pattern_literal_binding_annotation_tag := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_binding_annotation_tag(binding.pattern)
    ) else -1
);

(export wasm) get_binding_pattern_literal_binding_annotation_target_tag := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding_pattern_literal_binding_annotation_target_tag(binding.pattern)
    ) else -1
);

(export wasm) get_binding_pattern_tag := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        binding.pattern |> match {
            BindingPattern::Identifier(_) => 0,
            BindingPattern::Literal(_) => 1,
            BindingPattern::Struct(_) => 2,
            BindingPattern::EnumVariant(_) => 3,
            BindingPattern::TypeHint(_) => 4,
            else => 5
        }
    ) else -1
);

(export wasm) get_binding_pattern_span_start := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.span.start else (
            if BindingPattern::Literal(info) := binding.pattern then info.span.start else (
                if BindingPattern::Struct(info) := binding.pattern then info.span.start else (
                    if BindingPattern::EnumVariant(info) := binding.pattern then info.span.start else (
                        if BindingPattern::TypeHint(info) := binding.pattern then info.span.start else (
                            if BindingPattern::Annotated(info) := binding.pattern then info.span.start else -1
                        )
                    )
                )
            )
        )
    ) else -1
);

(export wasm) get_binding_pattern_span_length := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.span.length else (
            if BindingPattern::Literal(info) := binding.pattern then info.span.length else (
                if BindingPattern::Struct(info) := binding.pattern then info.span.length else (
                    if BindingPattern::EnumVariant(info) := binding.pattern then info.span.length else (
                        if BindingPattern::TypeHint(info) := binding.pattern then info.span.length else (
                            if BindingPattern::Annotated(info) := binding.pattern then info.span.length else 0
                        )
                    )
                )
            )
        )
    ) else 0
);

(export wasm) get_binding_pattern_struct_fields := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Struct(info) := binding.pattern then info.fields else -1
    ) else -1
);

(export wasm) get_binding_pattern_typehint_pattern := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::TypeHint(info) := binding.pattern then info.pattern else -1
    ) else -1
);

(export wasm) get_binding_pattern_typehint_type := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::TypeHint(info) := binding.pattern then info.type_expr else -1
    ) else -1
);

(export wasm) get_binding_pattern_annotations := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Annotated(info) := binding.pattern then info.annotations else -1
    ) else -1
);

(export wasm) get_binding_pattern_annotated_pattern := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Annotated(info) := binding.pattern then info.pattern else -1
    ) else -1
);

(export wasm) get_binding_pattern_enum_type := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(info) := binding.pattern then info.enum_type else -1
    ) else -1
);

(export wasm) get_binding_pattern_enum_variant_start := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(info) := binding.pattern then info.variant.name.start else -1
    ) else -1
);

(export wasm) get_binding_pattern_enum_variant_length := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(info) := binding.pattern then info.variant.name.length else 0
    ) else 0
);

(export wasm) get_binding_pattern_enum_payload := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(info) := binding.pattern then info.payload else -1
    ) else -1
);

(export wasm) get_binding_name_start := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.name.name.start else -1
    ) else -1
);

(export wasm) get_binding_name_length := (idx: i32) => (
    if NodeKind::Binding(binding) := nodes(idx).kind then (
        if BindingPattern::Identifier(info) := binding.pattern then info.name.name.length else 0
    ) else 0
);

(export wasm) get_block_count := (idx: i32) => (
    if NodeKind::Block(list) := nodes(idx).kind then list.count else 0
);

(export wasm) get_block_item := {idx: i32, pos: i32} => (
    if NodeKind::Block(list) := nodes(idx).kind then (
        mut current := list.head;
        mut i := 0;
        while i < pos do (
            if current == -1 then (
                i = pos;
            ) else (
                current = list_nodes(current).next;
                i = i + 1;
            );
            {};
        );
        if current == -1 then -1 else list_nodes(current).value
    ) else -1
);

(export wasm) get_list_next := (idx: i32) => (
    if idx == -1 then -1 else list_nodes(idx).next
);

(export wasm) get_list_value := (idx: i32) => (
    if idx == -1 then -1 else list_nodes(idx).value
);

(export wasm) get_struct_fields := (idx: i32) => (
    if NodeKind::Struct(info) := nodes(idx).kind then info.fields else -1
);

(export wasm) get_array_repeat_value := (idx: i32) => (
    if NodeKind::ArrayRepeat(info) := nodes(idx).kind then info.value else -1
);

(export wasm) get_array_repeat_count := (idx: i32) => (
    if NodeKind::ArrayRepeat(info) := nodes(idx).kind then info.count else -1
);

(export wasm) get_assignment_target_kind := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::Identifier(_) := info.target then 0 else (
            if LValue::TypePropertyAccess(_) := info.target then 1 else 2
        )
    ) else -1
);

(export wasm) get_assignment_expr := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then info.expr else -1
);

(export wasm) get_assignment_target_identifier_start := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::Identifier(value) := info.target then value.name.name.start else -1
    ) else -1
);

(export wasm) get_assignment_target_identifier_length := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::Identifier(value) := info.target then value.name.name.length else 0
    ) else 0
);

(export wasm) get_assignment_target_property_start := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::TypePropertyAccess(value) := info.target then value.property.start else -1
    ) else -1
);

(export wasm) get_assignment_target_property_length := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::TypePropertyAccess(value) := info.target then value.property.length else 0
    ) else 0
);

(export wasm) get_assignment_target_index_expr := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::ArrayIndex(value) := info.target then value.index else -1
    ) else -1
);

(export wasm) get_assignment_target_property_object := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::TypePropertyAccess(value) := info.target then value.object else -1
    ) else -1
);

(export wasm) get_assignment_target_array_expr := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::ArrayIndex(value) := info.target then value.array else -1
    ) else -1
);

(export wasm) get_assignment_target_span_start := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::Identifier(value) := info.target then value.span.start else (
            if LValue::TypePropertyAccess(value) := info.target then value.span.start else (
                if LValue::ArrayIndex(value) := info.target then value.span.start else -1
            )
        )
    ) else -1
);

(export wasm) get_assignment_target_span_length := (idx: i32) => (
    if NodeKind::Assignment(info) := nodes(idx).kind then (
        if LValue::Identifier(value) := info.target then value.span.length else (
            if LValue::TypePropertyAccess(value) := info.target then value.span.length else (
                if LValue::ArrayIndex(value) := info.target then value.span.length else 0
            )
        )
    ) else 0
);

(export wasm) get_function_param_pattern_tag := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        info.parameter |> match {
            BindingPattern::Identifier(_) => 0,
            BindingPattern::Literal(_) => 1,
            BindingPattern::Struct(_) => 2,
            BindingPattern::EnumVariant(_) => 3,
            BindingPattern::TypeHint(_) => 4,
            else => 5
        }
    ) else -1
);

(export wasm) get_function_param_pattern_literal_tag := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_tag(info.parameter)
    ) else -1
);

(export wasm) get_function_param_pattern_literal_number := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_number(info.parameter)
    ) else 0
);

(export wasm) get_function_param_pattern_literal_boolean := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_boolean(info.parameter)
    ) else 0
);

(export wasm) get_function_param_pattern_literal_char := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_char(info.parameter)
    ) else 0
);

(export wasm) get_function_param_pattern_literal_string_start := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_string_start(info.parameter)
    ) else -1
);

(export wasm) get_function_param_pattern_literal_string_length := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_string_length(info.parameter)
    ) else 0
);

(export wasm) get_function_param_pattern_literal_target_tag := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_target_tag(info.parameter)
    ) else -1
);

(export wasm) get_function_param_pattern_literal_binding_annotation_tag := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_binding_annotation_tag(info.parameter)
    ) else -1
);

(export wasm) get_function_param_pattern_literal_binding_annotation_target_tag := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        binding_pattern_literal_binding_annotation_target_tag(info.parameter)
    ) else -1
);

(export wasm) get_function_param_pattern_span_start := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Identifier(pattern) := info.parameter then pattern.span.start else (
            if BindingPattern::Literal(pattern) := info.parameter then pattern.span.start else (
                if BindingPattern::Struct(pattern) := info.parameter then pattern.span.start else (
                    if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.span.start else (
                        if BindingPattern::TypeHint(pattern) := info.parameter then pattern.span.start else (
                            if BindingPattern::Annotated(pattern) := info.parameter then pattern.span.start else -1
                        )
                    )
                )
            )
        )
    ) else -1
);

(export wasm) get_function_param_pattern_span_length := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Identifier(pattern) := info.parameter then pattern.span.length else (
            if BindingPattern::Literal(pattern) := info.parameter then pattern.span.length else (
                if BindingPattern::Struct(pattern) := info.parameter then pattern.span.length else (
                    if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.span.length else (
                        if BindingPattern::TypeHint(pattern) := info.parameter then pattern.span.length else (
                            if BindingPattern::Annotated(pattern) := info.parameter then pattern.span.length else 0
                        )
                    )
                )
            )
        )
    ) else 0
);

(export wasm) get_function_param_pattern_struct_fields := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Struct(pattern) := info.parameter then pattern.fields else -1
    ) else -1
);

(export wasm) get_function_param_pattern_typehint_pattern := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::TypeHint(pattern) := info.parameter then pattern.pattern else -1
    ) else -1
);

(export wasm) get_function_param_pattern_typehint_type := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::TypeHint(pattern) := info.parameter then pattern.type_expr else -1
    ) else -1
);

(export wasm) get_function_param_pattern_annotations := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Annotated(pattern) := info.parameter then pattern.annotations else -1
    ) else -1
);

(export wasm) get_function_param_pattern_annotated_pattern := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Annotated(pattern) := info.parameter then pattern.pattern else -1
    ) else -1
);

(export wasm) get_function_param_pattern_enum_type := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.enum_type else -1
    ) else -1
);

(export wasm) get_function_param_pattern_enum_variant_start := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.variant.name.start else -1
    ) else -1
);

(export wasm) get_function_param_pattern_enum_variant_length := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.variant.name.length else 0
    ) else 0
);

(export wasm) get_function_param_pattern_enum_payload := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::EnumVariant(pattern) := info.parameter then pattern.payload else -1
    ) else -1
);

(export wasm) get_function_param_pattern_identifier_start := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Identifier(pattern) := info.parameter then pattern.name.name.start else -1
    ) else -1
);

(export wasm) get_function_param_pattern_identifier_length := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then (
        if BindingPattern::Identifier(pattern) := info.parameter then pattern.name.name.length else 0
    ) else 0
);

(export wasm) get_function_body := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then info.body else -1
);

(export wasm) get_function_return_type := (idx: i32) => (
    if NodeKind::Function(info) := nodes(idx).kind then info.return_type else -1
);

(export wasm) get_function_type_param := (idx: i32) => (
    if NodeKind::FunctionType(info) := nodes(idx).kind then info.parameter else -1
);

(export wasm) get_function_type_return := (idx: i32) => (
    if NodeKind::FunctionType(info) := nodes(idx).kind then info.return_type else -1
);

(export wasm) get_box_type_inner := (idx: i32) => (
    if NodeKind::BoxType(inner) := nodes(idx).kind then inner else -1
);

(export wasm) get_if_condition := (idx: i32) => (
    if NodeKind::If(info) := nodes(idx).kind then info.condition else -1
);

(export wasm) get_if_then := (idx: i32) => (
    if NodeKind::If(info) := nodes(idx).kind then info.then_branch else -1
);

(export wasm) get_if_else := (idx: i32) => (
    if NodeKind::If(info) := nodes(idx).kind then info.else_branch else -1
);

(export wasm) get_loop_body := (idx: i32) => (
    if NodeKind::Loop(info) := nodes(idx).kind then info.body else -1
);

(export wasm) get_diverge_type := (idx: i32) => (
    if NodeKind::Diverge(info) := nodes(idx).kind then (
        if DivergeExpressionType::Return := info.divergance_type then 0 else 1
    ) else -1
);

(export wasm) get_diverge_value := (idx: i32) => (
    if NodeKind::Diverge(info) := nodes(idx).kind then info.value else -1
);

(export wasm) get_function_call_function := (idx: i32) => (
    if NodeKind::FunctionCall(info) := nodes(idx).kind then info.function else -1
);

(export wasm) get_function_call_argument := (idx: i32) => (
    if NodeKind::FunctionCall(info) := nodes(idx).kind then info.argument else -1
);

(export wasm) get_type_property_access_object := (idx: i32) => (
    if NodeKind::TypePropertyAccess(info) := nodes(idx).kind then info.object else -1
);

(export wasm) get_type_property_access_property_start := (idx: i32) => (
    if NodeKind::TypePropertyAccess(info) := nodes(idx).kind then info.property.start else -1
);

(export wasm) get_type_property_access_property_length := (idx: i32) => (
    if NodeKind::TypePropertyAccess(info) := nodes(idx).kind then info.property.length else 0
);

(export wasm) get_attach_type_expr := (idx: i32) => (
    if NodeKind::AttachImplementation(info) := nodes(idx).kind then info.type_expr else -1
);

(export wasm) get_attach_implementation := (idx: i32) => (
    if NodeKind::AttachImplementation(info) := nodes(idx).kind then info.implementation else -1
);

{}
