types := use "types.silk";

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;
MAX_VALUES := 8192;
MAX_BINDINGS := 4096;
MAX_OUTPUT_GLOBALS := 4096;
MAX_OUTPUT_EXPORTS := 12288;
MAX_OUTPUT_WRAPPERS := 12288;

StringRef := types.StringRef;
TargetLiteral := types.TargetLiteral;
BindingAnnotationLiteral := types.BindingAnnotationLiteral;
ExpressionLiteral := types.ExpressionLiteral;
BindingPattern := types.BindingPattern;
NodeKind := types.NodeKind;
Node := types.Node;
ListNode := types.ListNode;
State := types.State;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

INPUT_VALUE_NUMBER := 0;
INPUT_VALUE_BOOLEAN := 1;
INPUT_VALUE_CHAR := 2;

TARGET_MASK_JS := types.TARGET_MASK_JS;
TARGET_MASK_WASM := types.TARGET_MASK_WASM;
TARGET_MASK_WGSL := types.TARGET_MASK_WGSL;

VALUE_TAG_UNKNOWN := 0;
VALUE_TAG_NUMBER := 1;
VALUE_TAG_BOOLEAN := 2;
VALUE_TAG_CHAR := 3;

OUTPUT_TARGET_JS := types.TARGET_JS;
OUTPUT_TARGET_WASM := types.TARGET_WASM;
OUTPUT_TARGET_WGSL := types.TARGET_WGSL;

OUTPUT_EXPORT_TYPE_FUNCTION := 0;
OUTPUT_EXPORT_TYPE_GLOBAL := 1;

OUTPUT_GLOBAL_TYPE_I32 := 0;
OUTPUT_GLOBAL_TYPE_U8 := 1;

LowerStatus := enum {
    Ok = {},
    Unimplemented = {},
    Error = {},
};

LowerError := enum {
    None = {},
    InputTooSmall = {},
    BadMagic = {},
    BadVersion = {},
    HeaderCountMismatch = {},
    BodyParseFailed = {},
    BodyCountMismatch = {},
    OutputEncodeFailed = {},
};

InputValueSlot := {
    tag = i32,
    payload_i32 = i32,
};

InputBindingSlot := {
    name_start = i32,
    name_length = i32,
    value_idx = i32,
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
};

OutputGlobalSlot := {
    name_start = i32,
    name_length = i32,
    ty_tag = i32,
    value_tag = i32,
    value_i32 = i32,
};

OutputExportSlot := {
    target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputWrapperSlot := {
    source_target_tag = i32,
    wrap_target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

EMPTY_INPUT_VALUE_SLOT := {
    tag = -1,
    payload_i32 = 0,
};

EMPTY_INPUT_BINDING_SLOT := {
    name_start = 0,
    name_length = 0,
    value_idx = -1,
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
};

EMPTY_OUTPUT_GLOBAL_SLOT := {
    name_start = 0,
    name_length = 0,
    ty_tag = 0,
    value_tag = 0,
    value_i32 = 0,
};

EMPTY_OUTPUT_EXPORT_SLOT := {
    target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_WRAPPER_SLOT := {
    source_target_tag = 0,
    wrap_target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

lower_status_ok := {} => (
    0
);

lower_status_unimplemented := {} => (
    1
);

lower_status_error := {} => (
    2
);

lower_error_none := {} => (
    0
);

lower_error_input_too_small := {} => (
    1
);

lower_error_bad_magic := {} => (
    2
);

lower_error_bad_version := {} => (
    3
);

lower_error_header_count_mismatch := {} => (
    4
);

lower_error_body_parse_failed := {} => (
    5
);

lower_error_body_count_mismatch := {} => (
    6
);

lower_error_output_encode_failed := {} => (
    7
);

(export wasm) intermediate_payload_version := {} => (
    4
);

(export wasm) intermediate_output_version := {} => (
    2
);

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

(export wasm) mut input_values: Box({InputValueSlot; MAX_VALUES}) := {EMPTY_INPUT_VALUE_SLOT; MAX_VALUES};
(export wasm) mut input_bindings: Box({InputBindingSlot; MAX_BINDINGS}) := {EMPTY_INPUT_BINDING_SLOT; MAX_BINDINGS};

(export wasm) mut output_globals: Box({OutputGlobalSlot; MAX_OUTPUT_GLOBALS}) := {EMPTY_OUTPUT_GLOBAL_SLOT; MAX_OUTPUT_GLOBALS};
(export wasm) mut output_exports: Box({OutputExportSlot; MAX_OUTPUT_EXPORTS}) := {EMPTY_OUTPUT_EXPORT_SLOT; MAX_OUTPUT_EXPORTS};
(export wasm) mut output_wrappers: Box({OutputWrapperSlot; MAX_OUTPUT_WRAPPERS}) := {EMPTY_OUTPUT_WRAPPER_SLOT; MAX_OUTPUT_WRAPPERS};

LowerState := {
    error_code = i32,
    last_scope_count = i32,
    last_binding_count = i32,
    last_input_len = i32,
    input_magic_ok = i32,
    header_version = i32,
    header_scope_count = i32,
    header_binding_count = i32,
    header_annotated_binding_count = i32,
    parsed_binding_count = i32,
    parsed_annotated_binding_count = i32,
    parse_cursor = i32,
    body_ok = i32,
    header_ok = i32,
    output_len = i32,
    output_global_count = i32,
    output_export_count = i32,
    output_wrapper_count = i32,
    input_binding_count = i32,
    input_value_count = i32,
    lowering_unimplemented = i32,
};

(export wasm) mut lower_state: Box(LowerState) := {
    error_code = 0,
    last_scope_count = 0,
    last_binding_count = 0,
    last_input_len = 0,
    input_magic_ok = 0,
    header_version = 0,
    header_scope_count = 0,
    header_binding_count = 0,
    header_annotated_binding_count = 0,
    parsed_binding_count = 0,
    parsed_annotated_binding_count = 0,
    parse_cursor = 0,
    body_ok = 0,
    header_ok = 0,
    output_len = 0,
    output_global_count = 0,
    output_export_count = 0,
    output_wrapper_count = 0,
    input_binding_count = 0,
    input_value_count = 0,
    lowering_unimplemented = 0,
};

AnnotationState := {
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
};

BindingExtractState := {
    ok = i32,
    name_start = i32,
    name_length = i32,
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
};

LiteralExtractState := {
    tag = i32,
    payload_i32 = i32,
};

mut annotation_state: Box(AnnotationState) := {
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
};
mut binding_extract_state: Box(BindingExtractState) := {
    ok = 0,
    name_start = 0,
    name_length = 0,
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
};
mut literal_extract_state: Box(LiteralExtractState) := {
    tag = -1,
    payload_i32 = 0,
};

(export wasm) intermediate_stage_version := {} => (
    3
);

target_mask_has := {mask: i32, bit: i32} => (
    if bit <= 0 then 0 else (
        q := mask / bit;
        if q - (q / 2) * 2 == 1 then 1 else 0
    )
);

target_mask_or := {left: i32, right: i32} => (
    js := if target_mask_has{left, TARGET_MASK_JS} == 1 || target_mask_has{right, TARGET_MASK_JS} == 1 then TARGET_MASK_JS else 0;
    wasm := if target_mask_has{left, TARGET_MASK_WASM} == 1 || target_mask_has{right, TARGET_MASK_WASM} == 1 then TARGET_MASK_WASM else 0;
    wgsl := if target_mask_has{left, TARGET_MASK_WGSL} == 1 || target_mask_has{right, TARGET_MASK_WGSL} == 1 then TARGET_MASK_WGSL else 0;
    js + wasm + wgsl
);

target_count := (mask: i32) => (
    target_mask_has{mask, TARGET_MASK_JS}
        + target_mask_has{mask, TARGET_MASK_WASM}
        + target_mask_has{mask, TARGET_MASK_WGSL}
);

first_target_tag := (mask: i32) => (
    if target_mask_has{mask, TARGET_MASK_JS} == 1 then OUTPUT_TARGET_JS
    else if target_mask_has{mask, TARGET_MASK_WASM} == 1 then OUTPUT_TARGET_WASM
    else if target_mask_has{mask, TARGET_MASK_WGSL} == 1 then OUTPUT_TARGET_WGSL
    else -1
);

string_ref_matches_2 := {value: StringRef, c0: u8, c1: u8} => (
    if value.start < 0 || value.length != 2 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 then 1 else 0
);

string_ref_matches_4 := {value: StringRef, c0: u8, c1: u8, c2: u8, c3: u8} => (
    if value.start < 0 || value.length != 4 then 0
    else if input(value.start) == c0
        && input(value.start + 1) == c1
        && input(value.start + 2) == c2
        && input(value.start + 3) == c3
    then 1 else 0
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'm' && input(value.start + 1) == 'u' && input(value.start + 2) == 't' then 1 else 0
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 'e'
        && input(value.start + 1) == 'x'
        && input(value.start + 2) == 'p'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 't'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_wrap := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 4 then 0
    else if input(value.start) == 'w'
        && input(value.start + 1) == 'r'
        && input(value.start + 2) == 'a'
        && input(value.start + 3) == 'p'
    then 1 else 0
);

string_ref_is_js := (value: StringRef) => (
    string_ref_matches_2{value, 'j', 's'}
);

string_ref_is_wasm := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'a', 's', 'm'}
);

string_ref_is_wgsl := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'g', 's', 'l'}
);

target_mask_from_target_literal := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TARGET_MASK_JS,
        TargetLiteral::WasmTarget => TARGET_MASK_WASM,
        TargetLiteral::WgslTarget => TARGET_MASK_WGSL,
        else => 0
    }
);

target_mask_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_js(id.name) == 1 then TARGET_MASK_JS
                else if string_ref_is_wasm(id.name) == 1 then TARGET_MASK_WASM
                else if string_ref_is_wgsl(id.name) == 1 then TARGET_MASK_WGSL
                else 0
            ),
            NodeKind::Literal(ExpressionLiteral::Target(target)) => target_mask_from_target_literal(target),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Export(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Target(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Wrap(target) => target_mask_from_target_literal(target),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

reset_annotation_state := {} => (
    annotation_state.is_mut = 0;
    annotation_state.target_mask = 0;
    annotation_state.export_mask = 0;
    annotation_state.wrap_mask = 0;
    1
);

apply_annotation_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_mut(id.name) == 1 then (
                    annotation_state.is_mut = 1;
                    1
                ) else (
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                target_mask := target_mask_from_expr(info.argument);
                if target_mask == 0 then (
                    0
                ) else if NodeKind::Identifier(id) := nodes(info.function).kind then (
                    if string_ref_is_export(id.name) == 1 then (
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, target_mask};
                        1
                    ) else if string_ref_is_target(id.name) == 1 then (
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, target_mask};
                        1
                    ) else if string_ref_is_wrap(id.name) == 1 then (
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, target_mask};
                        1
                    ) else (
                        0
                    )
                ) else (
                    0
                )
            ),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => (
                        annotation_state.is_mut = 1;
                        1
                    ),
                    BindingAnnotationLiteral::Export(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Target(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Wrap(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, ann_mask};
                        1
                    ),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

apply_annotation_list := (head: i32) => (
    mut current := head;
    mut ok := 1;
    while current != -1 && ok == 1 do (
        ann_idx := list_nodes(current).value;
        if apply_annotation_expr(ann_idx) == 1 then (
            current = list_nodes(current).next;
        ) else (
            ok = 0;
            current = -1;
        );
        {}
    );
    ok
);

reset_binding_extract_state := {} => (
    binding_extract_state.ok = 0;
    binding_extract_state.name_start = 0;
    binding_extract_state.name_length = 0;
    binding_extract_state.is_mut = 0;
    binding_extract_state.target_mask = 0;
    binding_extract_state.export_mask = 0;
    binding_extract_state.wrap_mask = 0;
    1
);

set_binding_name := {start: i32, length: i32} => (
    if start < 0 || length < 0 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        binding_extract_state.ok = 1;
        binding_extract_state.name_start = start;
        binding_extract_state.name_length = length;
        1
    )
);

resolve_binding_name_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => set_binding_name{id.name.start, id.name.length},
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    resolve_binding_name_from_expr(info.left)
                ) else (
                    binding_extract_state.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => resolve_binding_name_from_expr(info.argument),
            else => (
                binding_extract_state.ok = 0;
                0
            )
        }
    )
);

resolve_binding_pattern := (pattern: BindingPattern) => (
    reset_binding_extract_state{};
    pattern |> match {
        BindingPattern::Identifier(info) => (
            set_binding_name{info.name.name.start, info.name.name.length};
            binding_extract_state.ok
        ),
        BindingPattern::TypeHint(info) => resolve_binding_name_from_expr(info.pattern),
        BindingPattern::Annotated(info) => (
            if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotation_list(info.annotations) == 0 then (
                0
            ) else if resolve_binding_name_from_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.ok
            )
        ),
        else => (
            binding_extract_state.ok = 0;
            0
        )
    }
);

extract_literal_value := (expr_idx: i32) => (
    literal_extract_state.tag = -1;
    literal_extract_state.payload_i32 = 0;
    if expr_idx == -1 then (
        1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(value) => (
                value |> match {
                    ExpressionLiteral::Number(number) => (
                        literal_extract_state.tag = INPUT_VALUE_NUMBER;
                        literal_extract_state.payload_i32 = number;
                        1
                    ),
                    ExpressionLiteral::Boolean(boolean) => (
                        literal_extract_state.tag = INPUT_VALUE_BOOLEAN;
                        literal_extract_state.payload_i32 = boolean;
                        1
                    ),
                    ExpressionLiteral::Char(ch) => (
                        literal_extract_state.tag = INPUT_VALUE_CHAR;
                        literal_extract_state.payload_i32 = ch;
                        1
                    ),
                    else => 1
                }
            ),
            else => 1
        }
    )
);

append_binding_from_node := (node_idx: i32) => (
    if node_idx < 0 || node_idx >= MAX_NODES then (
        0
    ) else if lower_state.input_binding_count < 0 || lower_state.input_binding_count >= MAX_BINDINGS then (
        0
    ) else if lower_state.input_value_count < 0 || lower_state.input_value_count >= MAX_VALUES then (
        0
    ) else (
        if NodeKind::Binding(binding) := nodes(node_idx).kind then (
            binding_idx := lower_state.input_binding_count;
            value_idx := lower_state.input_value_count;
            extract_literal_value(binding.expr);
            input_values(value_idx).tag = literal_extract_state.tag;
            input_values(value_idx).payload_i32 = literal_extract_state.payload_i32;

            input_bindings(binding_idx).name_start = 0;
            input_bindings(binding_idx).name_length = 0;
            input_bindings(binding_idx).value_idx = value_idx;
            input_bindings(binding_idx).is_mut = 0;
            input_bindings(binding_idx).target_mask = 0;
            input_bindings(binding_idx).export_mask = 0;
            input_bindings(binding_idx).wrap_mask = 0;

            if resolve_binding_pattern(binding.pattern) == 1 then (
                input_bindings(binding_idx).name_start = binding_extract_state.name_start;
                input_bindings(binding_idx).name_length = binding_extract_state.name_length;
                input_bindings(binding_idx).is_mut = binding_extract_state.is_mut;
                input_bindings(binding_idx).target_mask = binding_extract_state.target_mask;
                input_bindings(binding_idx).export_mask = binding_extract_state.export_mask;
                input_bindings(binding_idx).wrap_mask = binding_extract_state.wrap_mask;
                {}
            ) else (
                {}
            );

            lower_state.input_binding_count = binding_idx + 1;
            lower_state.input_value_count = value_idx + 1;
            1
        ) else (
            1
        )
    )
);

populate_input_slots_from_ast := (root: i32) => (
    if reset_input_slots{} == 0 then (
        0
    ) else if root < 0 || root >= MAX_NODES then (
        0
    ) else (
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut count := 0;
            mut ok := 1;
            while count < list.count && current != -1 && ok == 1 do (
                ok = append_binding_from_node(list_nodes(current).value);
                current = list_nodes(current).next;
                count = count + 1;
                {}
            );
            ok
        ) else (
            append_binding_from_node(root)
        )
    )
);

binding_has_any_annotations := (binding: InputBindingSlot) => (
    if binding.is_mut != 0
        || binding.target_mask != 0
        || binding.export_mask != 0
        || binding.wrap_mask != 0
    then 1 else 0
);

binding_should_materialize := (binding: InputBindingSlot) => (
    if binding.is_mut != 0 || binding.export_mask != 0 || binding.wrap_mask != 0 then 1 else 0
);

output_value_tag_from_input_tag := (tag: i32) => (
    if tag == INPUT_VALUE_NUMBER then VALUE_TAG_NUMBER
    else if tag == INPUT_VALUE_BOOLEAN then VALUE_TAG_BOOLEAN
    else if tag == INPUT_VALUE_CHAR then VALUE_TAG_CHAR
    else VALUE_TAG_UNKNOWN
);

safe_name_bounds := {start: i32, length: i32, input_len: i32} => (
    if start < 0 || length < 0 || input_len < 0 then 0
    else if start + length > input_len then 0
    else if start + length > MAX_INPUT then 0
    else 1
);

reset_output_slots := {} => (
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    1
);

emit_global_entry := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32
} => (
    idx := lower_state.output_global_count;
    if idx < 0 || idx >= MAX_OUTPUT_GLOBALS then -1 else (
        ty_tag := if value_tag == VALUE_TAG_CHAR then OUTPUT_GLOBAL_TYPE_U8 else OUTPUT_GLOBAL_TYPE_I32;
        output_globals(idx).name_start = name_start;
        output_globals(idx).name_length = name_length;
        output_globals(idx).ty_tag = ty_tag;
        output_globals(idx).value_tag = value_tag;
        output_globals(idx).value_i32 = value_i32;
        lower_state.output_global_count = idx + 1;
        idx
    )
);

emit_export_entry := {
    target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_export_count;
    if idx < 0 || idx >= MAX_OUTPUT_EXPORTS then 0 else (
        output_exports(idx).target_tag = target_tag;
        output_exports(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_exports(idx).index = global_index;
        output_exports(idx).name_start = name_start;
        output_exports(idx).name_length = name_length;
        lower_state.output_export_count = idx + 1;
        1
    )
);

emit_wrapper_entry := {
    source_target_tag: i32,
    wrap_target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_wrapper_count;
    if idx < 0 || idx >= MAX_OUTPUT_WRAPPERS then 0 else (
        output_wrappers(idx).source_target_tag = source_target_tag;
        output_wrappers(idx).wrap_target_tag = wrap_target_tag;
        output_wrappers(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_wrappers(idx).index = global_index;
        output_wrappers(idx).name_start = name_start;
        output_wrappers(idx).name_length = name_length;
        lower_state.output_wrapper_count = idx + 1;
        1
    )
);

lower_binding_record := {
    binding_idx: i32,
    input_len: i32,
    value_count: i32
} => (
    if binding_idx < 0 || binding_idx >= MAX_BINDINGS then 3 else (
        binding := input_bindings(binding_idx);
        if safe_name_bounds{binding.name_start, binding.name_length, input_len} == 0 then 3
        else if binding.export_mask < 0 || binding.wrap_mask < 0 || binding.target_mask < 0 then 3
        else if binding_should_materialize(binding) == 0 then 0
        else if binding.value_idx < 0 || binding.value_idx >= value_count || binding.value_idx >= MAX_VALUES then 1
        else (
            value := input_values(binding.value_idx);
            value_tag := output_value_tag_from_input_tag(value.tag);
            if value_tag == VALUE_TAG_UNKNOWN then 1 else (
                export_count := target_count(binding.export_mask);
                wrap_count := target_count(binding.wrap_mask);
                source_target_tag := first_target_tag(binding.export_mask);
                global_index := emit_global_entry{
                    binding.name_start,
                    binding.name_length,
                    value_tag,
                    value.payload_i32
                };
                if global_index < 0 then 2 else (
                    mut emit_ok := 1;
                    if emit_ok == 1 && target_mask_has{binding.export_mask, TARGET_MASK_JS} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_JS,
                            global_index,
                            binding.name_start,
                            binding.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding.export_mask, TARGET_MASK_WASM} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WASM,
                            global_index,
                            binding.name_start,
                            binding.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding.export_mask, TARGET_MASK_WGSL} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WGSL,
                            global_index,
                            binding.name_start,
                            binding.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 0 then 2
                    else if wrap_count == 0 then 0
                    else if export_count != 1 || source_target_tag < 0 then 1
                    else (
                        if emit_ok == 1 && target_mask_has{binding.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_JS,
                                global_index,
                                binding.name_start,
                                binding.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_WASM,
                                global_index,
                                binding.name_start,
                                binding.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_WGSL,
                                global_index,
                                binding.name_start,
                                binding.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 then 0 else 2
                    )
                )
            )
        )
    )
);

finalize_output_payload := {} => (
    if lower_state.output_global_count == 0
        && lower_state.output_export_count == 0
        && lower_state.output_wrapper_count == 0
    then (
        lower_state.output_len = 0;
        1
    ) else (
        lower_state.output_len = lower_state.output_global_count
            + lower_state.output_export_count
            + lower_state.output_wrapper_count;
        1
    )
);

parse_body_records := {binding_count: i32, input_len: i32, value_count: i32} => (
    mut idx := 0;
    mut parsed_bindings := 0;
    mut parsed_annotated := 0;
    mut body_ok := 1;
    mut output_ok := reset_output_slots{};
    mut lowering_unimplemented := 0;

    while idx < binding_count && body_ok == 1 do (
        if idx < 0 || idx >= MAX_BINDINGS then (
            body_ok = 0;
        ) else (
            binding := input_bindings(idx);
            if binding_has_any_annotations(binding) == 1 then (
                parsed_annotated = parsed_annotated + 1;
            ) else (
                {}
            );

            if output_ok == 1 && lowering_unimplemented == 0 then (
                lowering_result := lower_binding_record{idx, input_len, value_count};
                if lowering_result == 1 then (
                    lowering_unimplemented = 1;
                ) else if lowering_result == 2 then (
                    output_ok = 0;
                ) else if lowering_result == 3 then (
                    body_ok = 0;
                ) else (
                    {}
                )
            ) else (
                {}
            );

            parsed_bindings = parsed_bindings + 1;
        );
        idx = idx + 1;
    );

    lower_state.parse_cursor = idx;
    lower_state.parsed_binding_count = parsed_bindings;
    lower_state.parsed_annotated_binding_count = parsed_annotated;
    lower_state.header_annotated_binding_count = parsed_annotated;
    lower_state.body_ok = body_ok;
    lower_state.lowering_unimplemented = lowering_unimplemented;

    if body_ok == 0 then 0
    else if parsed_bindings != binding_count then 0
    else if output_ok == 0 then 2
    else 1
);

(export wasm) reset_input_slots := {} => (
    lower_state.input_binding_count = 0;
    lower_state.input_value_count = 0;
    1
);

(export wasm) set_input_counts := {binding_count: i32, value_count: i32} => (
    if binding_count < 0 || binding_count > MAX_BINDINGS then 0
    else if value_count < 0 || value_count > MAX_VALUES then 0
    else (
        lower_state.input_binding_count = binding_count;
        lower_state.input_value_count = value_count;
        1
    )
);

(export wasm) set_input_value := {idx: i32, tag: i32, payload_i32: i32} => (
    if idx < 0 || idx >= MAX_VALUES then 0
    else (
        input_values(idx).tag = tag;
        input_values(idx).payload_i32 = payload_i32;
        1
    )
);

(export wasm) set_input_binding := {
    idx: i32,
    name_start: i32,
    name_length: i32,
    value_idx: i32,
    is_mut: i32,
    target_mask: i32,
    export_mask: i32,
    wrap_mask: i32
} => (
    if idx < 0 || idx >= MAX_BINDINGS then 0
    else (
        input_bindings(idx).name_start = name_start;
        input_bindings(idx).name_length = name_length;
        input_bindings(idx).value_idx = value_idx;
        input_bindings(idx).is_mut = is_mut;
        input_bindings(idx).target_mask = target_mask;
        input_bindings(idx).export_mask = export_mask;
        input_bindings(idx).wrap_mask = wrap_mask;
        1
    )
);

run_lower_context := {scope_count: i32, binding_count: i32, input_len: i32} => (
    lower_state.error_code = lower_error_none{};
    lower_state.last_scope_count = scope_count;
    lower_state.last_binding_count = binding_count;
    lower_state.last_input_len = input_len;
    lower_state.input_magic_ok = 0;
    lower_state.header_version = 0;
    lower_state.header_scope_count = 0;
    lower_state.header_binding_count = 0;
    lower_state.header_annotated_binding_count = 0;
    lower_state.parsed_binding_count = 0;
    lower_state.parsed_annotated_binding_count = 0;
    lower_state.parse_cursor = 0;
    lower_state.body_ok = 0;
    lower_state.header_ok = 0;
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.lowering_unimplemented = 0;

    lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
    lower_state.header_version = intermediate_payload_version{};
    lower_state.header_scope_count = scope_count;
    lower_state.header_binding_count = binding_count;

    if lower_state.input_magic_ok == 0 then (
        lower_state.error_code = lower_error_input_too_small{};
        lower_status_error{}
    ) else if binding_count < 0 || binding_count > MAX_BINDINGS then (
        lower_state.error_code = lower_error_header_count_mismatch{};
        lower_status_error{}
    ) else if binding_count != lower_state.input_binding_count then (
        lower_state.error_code = lower_error_header_count_mismatch{};
        lower_status_error{}
    ) else if lower_state.input_value_count < 0 || lower_state.input_value_count > MAX_VALUES then (
        lower_state.error_code = lower_error_body_parse_failed{};
        lower_status_error{}
    ) else (
        parse_ok := parse_body_records{binding_count, input_len, lower_state.input_value_count};
        if parse_ok == 0 then (
            if lower_state.body_ok == 0 then (
                lower_state.error_code = lower_error_body_parse_failed{};
            ) else (
                lower_state.error_code = lower_error_body_count_mismatch{};
            );
            lower_status_error{}
        ) else if parse_ok == 2 then (
            lower_state.error_code = lower_error_output_encode_failed{};
            lower_status_error{}
        ) else (
            lower_state.header_ok = 1;
            if lower_state.lowering_unimplemented == 1 then (
                lower_status_unimplemented{}
            ) else (
                finalize_ok := finalize_output_payload{};
                if finalize_ok == 0 then (
                    lower_state.error_code = lower_error_output_encode_failed{};
                    lower_status_error{}
                ) else (
                    lower_status_ok{}
                )
            )
        )
    )
);

(export wasm) lower_context_from_slots := {scope_count: i32, binding_count: i32, input_len: i32} => (
    run_lower_context{scope_count, binding_count, input_len}
);

(export wasm) lower_context := (root: i32) => (
    input_len := if state.cursor >= 0 && state.cursor <= MAX_INPUT then state.cursor else MAX_INPUT;
    if populate_input_slots_from_ast(root) == 0 then (
        lower_state.error_code = lower_error_body_parse_failed{};
        lower_state.last_scope_count = 1;
        lower_state.last_binding_count = 0;
        lower_state.last_input_len = input_len;
        lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
        lower_state.header_version = intermediate_payload_version{};
        lower_state.header_scope_count = 1;
        lower_state.header_binding_count = 0;
        lower_state.header_annotated_binding_count = 0;
        lower_state.parsed_binding_count = 0;
        lower_state.parsed_annotated_binding_count = 0;
        lower_state.parse_cursor = 0;
        lower_state.body_ok = 0;
        lower_state.header_ok = 0;
        lower_state.output_len = 0;
        lower_state.output_global_count = 0;
        lower_state.output_export_count = 0;
        lower_state.output_wrapper_count = 0;
        lower_state.lowering_unimplemented = 0;
        lower_status_error{}
    ) else (
        run_lower_context{1, lower_state.input_binding_count, input_len}
    )
);

(export wasm) get_lower_error_code := {} => (
    lower_state.error_code
);

(export wasm) get_lower_last_scope_count := {} => (
    lower_state.last_scope_count
);

(export wasm) get_lower_last_binding_count := {} => (
    lower_state.last_binding_count
);

(export wasm) get_lower_last_input_len := {} => (
    lower_state.last_input_len
);

(export wasm) get_lower_input_magic_ok := {} => (
    lower_state.input_magic_ok
);

(export wasm) get_lower_header_version := {} => (
    lower_state.header_version
);

(export wasm) get_lower_header_scope_count := {} => (
    lower_state.header_scope_count
);

(export wasm) get_lower_header_binding_count := {} => (
    lower_state.header_binding_count
);

(export wasm) get_lower_header_annotated_binding_count := {} => (
    lower_state.header_annotated_binding_count
);

(export wasm) get_lower_header_ok := {} => (
    lower_state.header_ok
);

(export wasm) get_lower_parsed_binding_count := {} => (
    lower_state.parsed_binding_count
);

(export wasm) get_lower_parsed_annotated_binding_count := {} => (
    lower_state.parsed_annotated_binding_count
);

(export wasm) get_lower_parse_cursor := {} => (
    lower_state.parse_cursor
);

(export wasm) get_lower_body_ok := {} => (
    lower_state.body_ok
);

(export wasm) get_lower_output_len := {} => (
    lower_state.output_len
);

(export wasm) get_lower_output_global_count := {} => (
    lower_state.output_global_count
);

(export wasm) get_lower_output_export_count := {} => (
    lower_state.output_export_count
);

(export wasm) get_lower_output_wrapper_count := {} => (
    lower_state.output_wrapper_count
);

(export wasm) get_lower_lowering_unimplemented := {} => (
    lower_state.lowering_unimplemented
);

(export wasm) get_lower_output_global_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_start
);

(export wasm) get_lower_output_global_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_length
);

(export wasm) get_lower_output_global_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).ty_tag
);

(export wasm) get_lower_output_global_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_tag
);

(export wasm) get_lower_output_global_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_i32
);

(export wasm) get_lower_output_export_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).target_tag
);

(export wasm) get_lower_output_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).export_type
);

(export wasm) get_lower_output_export_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).index
);

(export wasm) get_lower_output_export_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_start
);

(export wasm) get_lower_output_export_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_length
);

(export wasm) get_lower_output_wrapper_source_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).source_target_tag
);

(export wasm) get_lower_output_wrapper_wrap_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).wrap_target_tag
);

(export wasm) get_lower_output_wrapper_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).export_type
);

(export wasm) get_lower_output_wrapper_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).index
);

(export wasm) get_lower_output_wrapper_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_start
);

(export wasm) get_lower_output_wrapper_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_length
);
