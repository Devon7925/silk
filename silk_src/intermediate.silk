types := use "types.silk";

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;
MAX_OUTPUT_GLOBALS := 4096;
MAX_OUTPUT_EXPORTS := 12288;
MAX_OUTPUT_WRAPPERS := 12288;
MAX_OUTPUT_INLINE_BINDINGS := 8192;
MAX_KNOWN_TYPE_ALIASES := 2048;
MAX_KNOWN_SCALAR_ALIASES := 2048;

StringRef := types.StringRef;
TargetLiteral := types.TargetLiteral;
BindingAnnotationLiteral := types.BindingAnnotationLiteral;
ExpressionLiteral := types.ExpressionLiteral;
IntrinsicType := types.IntrinsicType;
BindingPattern := types.BindingPattern;
NodeKind := types.NodeKind;
Node := types.Node;
ListNode := types.ListNode;
State := types.State;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

INPUT_VALUE_TYPE_UNKNOWN := 0;
INPUT_VALUE_TYPE_I32 := 1;
INPUT_VALUE_TYPE_U8 := 2;

TARGET_MASK_JS := types.TARGET_MASK_JS;
TARGET_MASK_WASM := types.TARGET_MASK_WASM;
TARGET_MASK_WGSL := types.TARGET_MASK_WGSL;

VALUE_TAG_UNKNOWN := 0;
VALUE_TAG_NUMBER := 1;
VALUE_TAG_BOOLEAN := 2;
VALUE_TAG_CHAR := 3;

OUTPUT_TARGET_JS := types.TARGET_JS;
OUTPUT_TARGET_WASM := types.TARGET_WASM;
OUTPUT_TARGET_WGSL := types.TARGET_WGSL;

OUTPUT_EXPORT_TYPE_FUNCTION := 0;
OUTPUT_EXPORT_TYPE_GLOBAL := 1;

OUTPUT_GLOBAL_TYPE_I32 := 0;
OUTPUT_GLOBAL_TYPE_U8 := 1;

LowerStatus := enum {
    Ok = {},
    Unimplemented = {},
    Error = {},
};

LowerError := enum {
    None = {},
    InputTooSmall = {},
    BadMagic = {},
    BadVersion = {},
    HeaderCountMismatch = {},
    BodyParseFailed = {},
    BodyCountMismatch = {},
    OutputEncodeFailed = {},
};

LowerBindingResult := enum {
    Ok = {},
    Unimplemented = {},
    OutputError = {},
    InputError = {},
};

WrapperSourceTarget := enum {
    Missing = {},
    Target = i32,
};

OutputGlobalSlot := {
    name_start = i32,
    name_length = i32,
    ty_tag = i32,
    value_tag = i32,
    value_i32 = i32,
};

OutputExportSlot := {
    target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputWrapperSlot := {
    source_target_tag = i32,
    wrap_target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputInlineBindingSlot := {
    name_start = i32,
    name_length = i32,
    value_tag = i32,
    value_i32 = i32,
};

EMPTY_OUTPUT_GLOBAL_SLOT := {
    name_start = 0,
    name_length = 0,
    ty_tag = 0,
    value_tag = 0,
    value_i32 = 0,
};

EMPTY_OUTPUT_EXPORT_SLOT := {
    target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_WRAPPER_SLOT := {
    source_target_tag = 0,
    wrap_target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_INLINE_BINDING_SLOT := {
    name_start = 0,
    name_length = 0,
    value_tag = VALUE_TAG_UNKNOWN,
    value_i32 = 0,
};

lower_status_ok := {} => (
    0
);

lower_status_unimplemented := {} => (
    1
);

lower_status_error := {} => (
    2
);

lower_error_none := {} => (
    0
);

lower_error_input_too_small := {} => (
    1
);

lower_error_bad_magic := {} => (
    2
);

lower_error_bad_version := {} => (
    3
);

lower_error_header_count_mismatch := {} => (
    4
);

lower_error_body_parse_failed := {} => (
    5
);

lower_error_body_count_mismatch := {} => (
    6
);

lower_error_output_encode_failed := {} => (
    7
);

(export wasm) intermediate_payload_version := {} => (
    6
);

(export wasm) intermediate_output_version := {} => (
    3
);

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

(export wasm) mut output_globals: Box({OutputGlobalSlot; MAX_OUTPUT_GLOBALS}) := {EMPTY_OUTPUT_GLOBAL_SLOT; MAX_OUTPUT_GLOBALS};
(export wasm) mut output_exports: Box({OutputExportSlot; MAX_OUTPUT_EXPORTS}) := {EMPTY_OUTPUT_EXPORT_SLOT; MAX_OUTPUT_EXPORTS};
(export wasm) mut output_wrappers: Box({OutputWrapperSlot; MAX_OUTPUT_WRAPPERS}) := {EMPTY_OUTPUT_WRAPPER_SLOT; MAX_OUTPUT_WRAPPERS};
(export wasm) mut output_inline_bindings: Box({OutputInlineBindingSlot; MAX_OUTPUT_INLINE_BINDINGS}) := {EMPTY_OUTPUT_INLINE_BINDING_SLOT; MAX_OUTPUT_INLINE_BINDINGS};

LowerState := {
    error_code = i32,
    last_scope_count = i32,
    last_binding_count = i32,
    last_input_len = i32,
    input_magic_ok = i32,
    header_version = i32,
    header_scope_count = i32,
    header_binding_count = i32,
    header_annotated_binding_count = i32,
    parsed_binding_count = i32,
    parsed_annotated_binding_count = i32,
    parse_cursor = i32,
    body_ok = i32,
    header_ok = i32,
    output_len = i32,
    output_global_count = i32,
    output_export_count = i32,
    output_wrapper_count = i32,
    output_inline_binding_count = i32,
    lowering_unimplemented = i32,
};

(export wasm) mut lower_state: Box(LowerState) := {
    error_code = 0,
    last_scope_count = 0,
    last_binding_count = 0,
    last_input_len = 0,
    input_magic_ok = 0,
    header_version = 0,
    header_scope_count = 0,
    header_binding_count = 0,
    header_annotated_binding_count = 0,
    parsed_binding_count = 0,
    parsed_annotated_binding_count = 0,
    parse_cursor = 0,
    body_ok = 0,
    header_ok = 0,
    output_len = 0,
    output_global_count = 0,
    output_export_count = 0,
    output_wrapper_count = 0,
    output_inline_binding_count = 0,
    lowering_unimplemented = 0,
};

AnnotationState := {
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
};

BindingExtractState := {
    ok = i32,
    name_start = i32,
    name_length = i32,
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
    value_type_tag = i32,
};

KnownTypeAliasSlot := {
    name_start = i32,
    name_length = i32,
    value_type_tag = i32,
};

BindingLookupState := {
    type_alias_count = i32,
    scalar_alias_count = i32,
};

ScalarValue := {
    value_tag = i32,
    value_i32 = i32,
    value_type_tag = i32,
};

ScalarValueLookup := enum {
    Missing = {},
    Value = ScalarValue,
    InputError = {},
};

EMPTY_KNOWN_TYPE_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};

KnownScalarAliasSlot := {
    name_start = i32,
    name_length = i32,
    value_tag = i32,
    value_i32 = i32,
    value_type_tag = i32,
};

EMPTY_KNOWN_SCALAR_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
    value_tag = VALUE_TAG_UNKNOWN,
    value_i32 = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};

(export wasm) mut annotation_state: Box(AnnotationState) := {
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
};
(export wasm) mut binding_extract_state: Box(BindingExtractState) := {
    ok = 0,
    name_start = 0,
    name_length = 0,
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};
(export wasm) mut binding_lookup_state: Box(BindingLookupState) := {
    type_alias_count = 0,
    scalar_alias_count = 0,
};
(export wasm) mut known_type_aliases: Box({KnownTypeAliasSlot; MAX_KNOWN_TYPE_ALIASES}) := {EMPTY_KNOWN_TYPE_ALIAS_SLOT; MAX_KNOWN_TYPE_ALIASES};
(export wasm) mut known_scalar_aliases: Box({KnownScalarAliasSlot; MAX_KNOWN_SCALAR_ALIASES}) := {EMPTY_KNOWN_SCALAR_ALIAS_SLOT; MAX_KNOWN_SCALAR_ALIASES};

(export wasm) intermediate_stage_version := {} => (
    7
);

target_mask_has := {mask: i32, bit: i32} => (
    if bit <= 0 then 0 else (
        q := mask / bit;
        if q - (q / 2) * 2 == 1 then 1 else 0
    )
);

target_mask_or := {left: i32, right: i32} => (
    js := if target_mask_has{left, TARGET_MASK_JS} == 1 || target_mask_has{right, TARGET_MASK_JS} == 1 then TARGET_MASK_JS else 0;
    wasm := if target_mask_has{left, TARGET_MASK_WASM} == 1 || target_mask_has{right, TARGET_MASK_WASM} == 1 then TARGET_MASK_WASM else 0;
    wgsl := if target_mask_has{left, TARGET_MASK_WGSL} == 1 || target_mask_has{right, TARGET_MASK_WGSL} == 1 then TARGET_MASK_WGSL else 0;
    js + wasm + wgsl
);

target_count := (mask: i32) => (
    target_mask_has{mask, TARGET_MASK_JS}
        + target_mask_has{mask, TARGET_MASK_WASM}
        + target_mask_has{mask, TARGET_MASK_WGSL}
);

first_target_tag := (mask: i32) => (
    if target_mask_has{mask, TARGET_MASK_JS} == 1 then OUTPUT_TARGET_JS
    else if target_mask_has{mask, TARGET_MASK_WASM} == 1 then OUTPUT_TARGET_WASM
    else if target_mask_has{mask, TARGET_MASK_WGSL} == 1 then OUTPUT_TARGET_WGSL
    else -1
);

string_ref_matches_2 := {value: StringRef, c0: u8, c1: u8} => (
    if value.start < 0 || value.length != 2 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 then 1 else 0
);

string_ref_matches_4 := {value: StringRef, c0: u8, c1: u8, c2: u8, c3: u8} => (
    if value.start < 0 || value.length != 4 then 0
    else if input(value.start) == c0
        && input(value.start + 1) == c1
        && input(value.start + 2) == c2
        && input(value.start + 3) == c3
    then 1 else 0
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'm' && input(value.start + 1) == 'u' && input(value.start + 2) == 't' then 1 else 0
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 'e'
        && input(value.start + 1) == 'x'
        && input(value.start + 2) == 'p'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 't'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_wrap := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 4 then 0
    else if input(value.start) == 'w'
        && input(value.start + 1) == 'r'
        && input(value.start + 2) == 'a'
        && input(value.start + 3) == 'p'
    then 1 else 0
);

string_ref_is_js := (value: StringRef) => (
    string_ref_matches_2{value, 'j', 's'}
);

string_ref_is_wasm := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'a', 's', 'm'}
);

string_ref_is_wgsl := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'g', 's', 'l'}
);

string_ref_is_u8 := (value: StringRef) => (
    string_ref_matches_2{value, 'u', '8'}
);

string_ref_is_i32 := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'i' && input(value.start + 1) == '3' && input(value.start + 2) == '2' then 1 else 0
);

string_ref_is_boolean_type := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 7 then 0
    else if input(value.start) == 'b'
        && input(value.start + 1) == 'o'
        && input(value.start + 2) == 'o'
        && input(value.start + 3) == 'l'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 'a'
        && input(value.start + 6) == 'n'
    then 1 else 0
);

target_mask_from_target_literal := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TARGET_MASK_JS,
        TargetLiteral::WasmTarget => TARGET_MASK_WASM,
        TargetLiteral::WgslTarget => TARGET_MASK_WGSL,
        else => 0
    }
);

target_mask_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_js(id.name) == 1 then TARGET_MASK_JS
                else if string_ref_is_wasm(id.name) == 1 then TARGET_MASK_WASM
                else if string_ref_is_wgsl(id.name) == 1 then TARGET_MASK_WGSL
                else 0
            ),
            NodeKind::Literal(ExpressionLiteral::Target(target)) => target_mask_from_target_literal(target),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Export(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Target(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Wrap(target) => target_mask_from_target_literal(target),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

reset_annotation_state := {} => (
    annotation_state.is_mut = 0;
    annotation_state.target_mask = 0;
    annotation_state.export_mask = 0;
    annotation_state.wrap_mask = 0;
    1
);

apply_annotation_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_mut(id.name) == 1 then (
                    annotation_state.is_mut = 1;
                    1
                ) else (
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                target_mask := target_mask_from_expr(info.argument);
                if target_mask == 0 then (
                    0
                ) else if NodeKind::Identifier(id) := nodes(info.function).kind then (
                    if string_ref_is_export(id.name) == 1 then (
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, target_mask};
                        1
                    ) else if string_ref_is_target(id.name) == 1 then (
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, target_mask};
                        1
                    ) else if string_ref_is_wrap(id.name) == 1 then (
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, target_mask};
                        1
                    ) else (
                        0
                    )
                ) else (
                    0
                )
            ),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => (
                        annotation_state.is_mut = 1;
                        1
                    ),
                    BindingAnnotationLiteral::Export(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Target(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Wrap(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, ann_mask};
                        1
                    ),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

apply_annotation_list := (head: i32) => (
    mut current := head;
    mut ok := 1;
    while current != -1 && ok == 1 do (
        ann_idx := list_nodes(current).value;
        if apply_annotation_expr(ann_idx) == 1 then (
            current = list_nodes(current).next;
        ) else (
            ok = 0;
            current = -1;
        );
        {}
    );
    ok
);

reset_binding_extract_state := {} => (
    binding_extract_state.ok = 0;
    binding_extract_state.name_start = 0;
    binding_extract_state.name_length = 0;
    binding_extract_state.is_mut = 0;
    binding_extract_state.target_mask = 0;
    binding_extract_state.export_mask = 0;
    binding_extract_state.wrap_mask = 0;
    binding_extract_state.value_type_tag = INPUT_VALUE_TYPE_UNKNOWN;
    1
);

set_binding_name := {start: i32, length: i32} => (
    if start < 0 || length < 0 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        binding_extract_state.ok = 1;
        binding_extract_state.name_start = start;
        binding_extract_state.name_length = length;
        1
    )
);

resolve_binding_name_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => set_binding_name{id.name.start, id.name.length},
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    resolve_binding_name_from_expr(info.left)
                ) else (
                    binding_extract_state.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => resolve_binding_name_from_expr(info.argument),
            else => (
                binding_extract_state.ok = 0;
                0
            )
        }
    )
);

value_type_tag_from_type_expr := {expr_idx: i32, input_len: i32} => (
    resolve_scalar_type_expr{expr_idx, input_len}
);

value_type_tag_from_pattern_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN else (
        nodes(expr_idx).kind |> match {
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    value_type_tag_from_type_expr{info.right, input_len}
                ) else (
                    INPUT_VALUE_TYPE_UNKNOWN
                )
            ),
            NodeKind::FunctionCall(info) => value_type_tag_from_pattern_expr{info.argument, input_len},
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

apply_annotation_chain_expr := (node_idx: i32) => (
    if node_idx == -1 then 0
    else if node_idx < 0 || node_idx >= MAX_NODES then 0
    else if NodeKind::FunctionCall(info) := nodes(node_idx).kind then (
        if NodeKind::FunctionCall(_) := nodes(info.function).kind then (
            if apply_annotation_chain_expr(info.function) == 0 then 0 else apply_annotation_expr(info.argument)
        ) else (
            apply_annotation_expr(node_idx)
        )
    ) else 0
);

apply_annotations_from_pattern_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 1
    else if expr_idx < 0 || expr_idx >= MAX_NODES then 0
    else if NodeKind::FunctionCall(info) := nodes(expr_idx).kind then (
        if NodeKind::TypePropertyAccess(_) := nodes(info.function).kind then 1 else apply_annotation_chain_expr(info.function)
    ) else 1
);

resolve_binding_pattern := {pattern: BindingPattern, input_len: i32} => (
    reset_binding_extract_state{};
    pattern |> match {
        BindingPattern::Identifier(info) => (
            set_binding_name{info.name.name.start, info.name.name.length};
            binding_extract_state.ok
        ),
        BindingPattern::TypeHint(info) => (
            if resolve_binding_name_from_expr(info.pattern) == 0 then 0 else if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotations_from_pattern_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.value_type_tag = value_type_tag_from_type_expr{info.type_expr, input_len};
                binding_extract_state.ok
            )
        ),
        BindingPattern::Annotated(info) => (
            if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotation_list(info.annotations) == 0 then (
                0
            ) else if resolve_binding_name_from_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.value_type_tag = value_type_tag_from_pattern_expr{info.pattern, input_len};
                binding_extract_state.ok
            )
        ),
        else => (
            binding_extract_state.ok = 0;
            0
        )
    }
);

binding_has_any_annotations := {} => (
    if binding_extract_state.is_mut != 0
        || binding_extract_state.target_mask != 0
        || binding_extract_state.export_mask != 0
        || binding_extract_state.wrap_mask != 0
    then 1 else 0
);

binding_should_materialize := {} => (
    if binding_extract_state.is_mut != 0 || binding_extract_state.export_mask != 0 then 1 else 0
);

safe_name_bounds := {start: i32, length: i32, input_len: i32} => (
    if start < 0 || length < 0 || input_len < 0 then 0
    else if start + length > input_len then 0
    else if start + length > MAX_INPUT then 0
    else 1
);

reset_binding_lookup_state := {} => (
    binding_lookup_state.type_alias_count = 0;
    binding_lookup_state.scalar_alias_count = 0;
    1
);

input_spans_equal := {
    left_start: i32,
    left_length: i32,
    right_start: i32,
    right_length: i32,
    input_len: i32
} => (
    if safe_name_bounds{left_start, left_length, input_len} == 0 then 0
    else if safe_name_bounds{right_start, right_length, input_len} == 0 then 0
    else if left_length != right_length then 0
    else (
        mut idx := 0;
        mut same := 1;
        while idx < left_length && same == 1 do (
            if input(left_start + idx) != input(right_start + idx) then (
                same = 0;
            ) else (
                {}
            );
            idx = idx + 1;
            {}
        );
        same
    )
);

find_known_type_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.type_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_type_aliases(idx).name_start,
            known_type_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_type_alias := {
    name_start: i32,
    name_length: i32,
    value_type_tag: i32,
    input_len: i32
} => (
    existing := find_known_type_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_type_aliases(existing).name_start = name_start;
        known_type_aliases(existing).name_length = name_length;
        known_type_aliases(existing).value_type_tag = value_type_tag;
        1
    ) else (
        idx := binding_lookup_state.type_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_TYPE_ALIASES then 0 else (
            known_type_aliases(idx).name_start = name_start;
            known_type_aliases(idx).name_length = name_length;
            known_type_aliases(idx).value_type_tag = value_type_tag;
            binding_lookup_state.type_alias_count = idx + 1;
            1
        )
    )
);

clear_known_type_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_type_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.type_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.type_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_type_aliases(idx).name_start = known_type_aliases(last).name_start;
                known_type_aliases(idx).name_length = known_type_aliases(last).name_length;
                known_type_aliases(idx).value_type_tag = known_type_aliases(last).value_type_tag;
            ) else (
                {}
            );
            binding_lookup_state.type_alias_count = last;
            1
        )
    )
);

lookup_known_type_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then INPUT_VALUE_TYPE_UNKNOWN
    else (
        idx := find_known_type_alias_index{name_start, name_length, input_len};
        if idx < 0 then INPUT_VALUE_TYPE_UNKNOWN else known_type_aliases(idx).value_type_tag
    )
);

find_known_scalar_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.scalar_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_scalar_aliases(idx).name_start,
            known_scalar_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_scalar_alias := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32,
    value_type_tag: i32,
    input_len: i32
} => (
    existing := find_known_scalar_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_scalar_aliases(existing).name_start = name_start;
        known_scalar_aliases(existing).name_length = name_length;
        known_scalar_aliases(existing).value_tag = value_tag;
        known_scalar_aliases(existing).value_i32 = value_i32;
        known_scalar_aliases(existing).value_type_tag = value_type_tag;
        1
    ) else (
        idx := binding_lookup_state.scalar_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_SCALAR_ALIASES then 0 else (
            known_scalar_aliases(idx).name_start = name_start;
            known_scalar_aliases(idx).name_length = name_length;
            known_scalar_aliases(idx).value_tag = value_tag;
            known_scalar_aliases(idx).value_i32 = value_i32;
            known_scalar_aliases(idx).value_type_tag = value_type_tag;
            binding_lookup_state.scalar_alias_count = idx + 1;
            1
        )
    )
);

clear_known_scalar_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_scalar_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.scalar_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.scalar_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_scalar_aliases(idx).name_start = known_scalar_aliases(last).name_start;
                known_scalar_aliases(idx).name_length = known_scalar_aliases(last).name_length;
                known_scalar_aliases(idx).value_tag = known_scalar_aliases(last).value_tag;
                known_scalar_aliases(idx).value_i32 = known_scalar_aliases(last).value_i32;
                known_scalar_aliases(idx).value_type_tag = known_scalar_aliases(last).value_type_tag;
            ) else (
                {}
            );
            binding_lookup_state.scalar_alias_count = last;
            1
        )
    )
);

lookup_known_scalar_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then ScalarValueLookup::InputError
    else (
        idx := find_known_scalar_alias_index{name_start, name_length, input_len};
        if idx < 0 then (
            ScalarValueLookup::Missing
        ) else (
            ScalarValueLookup::Value({
                value_tag = known_scalar_aliases(idx).value_tag,
                value_i32 = known_scalar_aliases(idx).value_i32,
                value_type_tag = known_scalar_aliases(idx).value_type_tag
            })
        )
    )
);

resolve_scalar_type_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN
    else if expr_idx < 0 || expr_idx >= MAX_NODES then INPUT_VALUE_TYPE_UNKNOWN
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::IntrinsicType(ty) => (
                ty |> match {
                    IntrinsicType::U8 => INPUT_VALUE_TYPE_U8,
                    IntrinsicType::I32 => INPUT_VALUE_TYPE_I32,
                    IntrinsicType::Boolean => INPUT_VALUE_TYPE_I32,
                    else => INPUT_VALUE_TYPE_UNKNOWN
                }
            ),
            NodeKind::Identifier(id) => (
                if string_ref_is_u8(id.name) == 1 then INPUT_VALUE_TYPE_U8
                else if string_ref_is_i32(id.name) == 1 then INPUT_VALUE_TYPE_I32
                else if string_ref_is_boolean_type(id.name) == 1 then INPUT_VALUE_TYPE_I32
                else lookup_known_type_alias{id.name.start, id.name.length, input_len}
            ),
            NodeKind::AttachImplementation(info) => resolve_scalar_type_expr{info.type_expr, input_len},
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

default_scalar_type_tag := (value_tag: i32) => (
    if value_tag == VALUE_TAG_CHAR then INPUT_VALUE_TYPE_U8
    else INPUT_VALUE_TYPE_I32
);

resolve_scalar_value_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then ScalarValueLookup::Missing
    else if expr_idx < 0 || expr_idx >= MAX_NODES then ScalarValueLookup::InputError
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(value) => (
                value |> match {
                    ExpressionLiteral::Number(number) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_NUMBER,
                            value_i32 = number,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Boolean(boolean) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_BOOLEAN,
                            value_i32 = boolean,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Char(ch) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_CHAR,
                            value_i32 = ch,
                            value_type_tag = INPUT_VALUE_TYPE_U8
                        })
                    ),
                    else => ScalarValueLookup::Missing
                }
            ),
            NodeKind::Identifier(id) => lookup_known_scalar_alias{id.name.start, id.name.length, input_len},
            else => ScalarValueLookup::Missing
        }
    )
);

update_known_type_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        value_type_tag := resolve_scalar_type_expr{expr_idx, input_len};
        if value_type_tag == INPUT_VALUE_TYPE_UNKNOWN then (
            clear_known_type_alias{binding_extract_state.name_start, binding_extract_state.name_length, input_len}
        ) else (
            set_known_type_alias{
                binding_extract_state.name_start,
                binding_extract_state.name_length,
                value_type_tag,
                input_len
            }
        )
    )
);

update_known_scalar_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        value_lookup := resolve_scalar_value_expr{expr_idx, input_len};
        value_lookup |> match {
            ScalarValueLookup::InputError => 0,
            ScalarValueLookup::Missing => (
                clear_known_scalar_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    input_len
                }
            ),
            ScalarValueLookup::Value(value) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                resolved_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                    else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                    else default_scalar_type_tag(value.value_tag);
                set_known_scalar_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    value.value_tag,
                    value.value_i32,
                    resolved_type_tag,
                    input_len
                }
            ),
            else => 0
        }
    )
);

resolve_wrapper_source_target := {} => (
    if target_count(binding_extract_state.wrap_mask) == 0 then WrapperSourceTarget::Missing else (
        source_target_tag := first_target_tag(binding_extract_state.export_mask);
        if source_target_tag < 0 then WrapperSourceTarget::Missing else WrapperSourceTarget::Target(source_target_tag)
    )
);

reset_output_slots := {} => (
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.output_inline_binding_count = 0;
    1
);

emit_global_entry := {
    name_start: i32,
    name_length: i32,
    ty_tag: i32,
    value_tag: i32,
    value_i32: i32
} => (
    idx := lower_state.output_global_count;
    if idx < 0 || idx >= MAX_OUTPUT_GLOBALS then -1 else (
        output_globals(idx).name_start = name_start;
        output_globals(idx).name_length = name_length;
        output_globals(idx).ty_tag = ty_tag;
        output_globals(idx).value_tag = value_tag;
        output_globals(idx).value_i32 = value_i32;
        lower_state.output_global_count = idx + 1;
        idx
    )
);

emit_export_entry := {
    target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_export_count;
    if idx < 0 || idx >= MAX_OUTPUT_EXPORTS then 0 else (
        output_exports(idx).target_tag = target_tag;
        output_exports(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_exports(idx).index = global_index;
        output_exports(idx).name_start = name_start;
        output_exports(idx).name_length = name_length;
        lower_state.output_export_count = idx + 1;
        1
    )
);

emit_wrapper_entry := {
    source_target_tag: i32,
    wrap_target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_wrapper_count;
    if idx < 0 || idx >= MAX_OUTPUT_WRAPPERS then 0 else (
        output_wrappers(idx).source_target_tag = source_target_tag;
        output_wrappers(idx).wrap_target_tag = wrap_target_tag;
        output_wrappers(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_wrappers(idx).index = global_index;
        output_wrappers(idx).name_start = name_start;
        output_wrappers(idx).name_length = name_length;
        lower_state.output_wrapper_count = idx + 1;
        1
    )
);

emit_inline_binding_entry := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32
} => (
    idx := lower_state.output_inline_binding_count;
    if idx < 0 || idx >= MAX_OUTPUT_INLINE_BINDINGS then 0 else (
        output_inline_bindings(idx).name_start = name_start;
        output_inline_bindings(idx).name_length = name_length;
        output_inline_bindings(idx).value_tag = value_tag;
        output_inline_bindings(idx).value_i32 = value_i32;
        lower_state.output_inline_binding_count = idx + 1;
        1
    )
);

emit_inline_binding_for_binding := {expr_idx: i32, input_len: i32} => (
    if binding_should_materialize{} == 1 then (
        1
    ) else (
        value_lookup := resolve_scalar_value_expr{expr_idx, input_len};
        value_lookup |> match {
            ScalarValueLookup::InputError => 0,
            ScalarValueLookup::Missing => 1,
            ScalarValueLookup::Value(value) => emit_inline_binding_entry{
                binding_extract_state.name_start,
                binding_extract_state.name_length,
                value.value_tag,
                value.value_i32
            },
            else => 0
        }
    )
);

resolve_output_global_type_tag := {value_tag: i32, value_type_tag: i32} => (
    if value_type_tag == INPUT_VALUE_TYPE_U8 then OUTPUT_GLOBAL_TYPE_U8
    else if value_type_tag == INPUT_VALUE_TYPE_I32 then OUTPUT_GLOBAL_TYPE_I32
    else if value_tag == VALUE_TAG_CHAR then OUTPUT_GLOBAL_TYPE_U8
    else OUTPUT_GLOBAL_TYPE_I32
);

lower_binding_expr := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then LowerBindingResult::InputError
    else if binding_extract_state.export_mask < 0 || binding_extract_state.wrap_mask < 0 || binding_extract_state.target_mask < 0 then LowerBindingResult::InputError
    else if binding_should_materialize{} == 0 then LowerBindingResult::Ok
    else (
        value_lookup := resolve_scalar_value_expr{expr_idx, input_len};
        value_lookup |> match {
            ScalarValueLookup::InputError => LowerBindingResult::InputError,
            ScalarValueLookup::Missing => LowerBindingResult::Unimplemented,
            ScalarValueLookup::Value(value) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                value_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                    else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                    else default_scalar_type_tag(value.value_tag);
                global_type_tag := resolve_output_global_type_tag{value.value_tag, value_type_tag};
                global_index := emit_global_entry{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    global_type_tag,
                    value.value_tag,
                    value.value_i32
                };
                if global_index < 0 then LowerBindingResult::OutputError else (
                    mut emit_ok := 1;
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_JS,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WASM,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WGSL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 0 then LowerBindingResult::OutputError
                    else (
                        wrapper_source_target := resolve_wrapper_source_target{};
                        wrapper_source_target |> match {
                            WrapperSourceTarget::Missing => (
                                LowerBindingResult::Ok
                            ),
                            WrapperSourceTarget::Target(source_target_tag) => (
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_JS,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WASM,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WGSL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                            ),
                            else => LowerBindingResult::OutputError
                        }
                    )
                )
            ),
            else => LowerBindingResult::OutputError
        }
    )
);

finalize_output_payload := {} => (
    if lower_state.output_global_count == 0
        && lower_state.output_export_count == 0
        && lower_state.output_wrapper_count == 0
        && lower_state.output_inline_binding_count == 0
    then (
        lower_state.output_len = 0;
        1
    ) else (
        lower_state.output_len = lower_state.output_global_count
            + lower_state.output_export_count
            + lower_state.output_wrapper_count
            + lower_state.output_inline_binding_count;
        1
    )
);

count_bindings_in_root := (root: i32) => (
    if root < 0 || root >= MAX_NODES then -1 else (
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut idx := 0;
            mut binding_count := 0;
            while idx < list.count && current != -1 do (
                node_idx := list_nodes(current).value;
                if node_idx >= 0 && node_idx < MAX_NODES then (
                    if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                        binding_count = binding_count + 1;
                        {}
                    ) else (
                        {}
                    )
                ) else (
                    {}
                );
                current = list_nodes(current).next;
                idx = idx + 1;
                {}
            );
            binding_count
        ) else (
            if NodeKind::Binding(binding) := nodes(root).kind then 1 else 0
        )
    )
);

parse_body_records := {root: i32, binding_count: i32, input_len: i32} => (
    mut idx := 0;
    mut parsed_bindings := 0;
    mut parsed_annotated := 0;
    mut body_ok := 1;
    mut output_ok := reset_output_slots{};
    mut lowering_unimplemented := 0;
    reset_binding_lookup_state{};

    if root < 0 || root >= MAX_NODES then (
        body_ok = 0;
    ) else if NodeKind::Block(list) := nodes(root).kind then (
        mut current := list.head;
        while idx < list.count && current != -1 && body_ok == 1 do (
            node_idx := list_nodes(current).value;
            if node_idx < 0 || node_idx >= MAX_NODES then (
                body_ok = 0;
            ) else if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                if resolve_binding_pattern{binding.pattern, input_len} == 0 then (
                    parsed_bindings = parsed_bindings + 1;
                    lowering_unimplemented = 1;
                ) else (
                    parsed_bindings = parsed_bindings + 1;
                    if binding_has_any_annotations{} == 1 then (
                        parsed_annotated = parsed_annotated + 1;
                    ) else (
                        {}
                    );

                    if output_ok == 1 && lowering_unimplemented == 0 then (
                        lowering_result := lower_binding_expr{binding.expr, input_len};
                        lowering_code := lowering_result |> match {
                            LowerBindingResult::Ok => 0,
                            LowerBindingResult::Unimplemented => 1,
                            LowerBindingResult::OutputError => 2,
                            LowerBindingResult::InputError => 3,
                            else => 4
                        };
                        if lowering_code == 1 then (
                            lowering_unimplemented = 1;
                        ) else if lowering_code == 2 then (
                            output_ok = 0;
                        ) else if lowering_code == 3 then (
                            body_ok = 0;
                        ) else if lowering_code == 4 then (
                            output_ok = 0;
                        ) else (
                            {}
                        );
                        {}
                    ) else (
                        {}
                    );

                    if output_ok == 1 && emit_inline_binding_for_binding{binding.expr, input_len} == 0 then (
                        output_ok = 0;
                    ) else (
                        {}
                    );

                    if body_ok == 1 && update_known_type_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else if body_ok == 1 && update_known_scalar_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else (
                        {}
                    )
                )
            ) else (
                {}
            );
            current = list_nodes(current).next;
            idx = idx + 1;
            {}
        );
    ) else (
        if NodeKind::Binding(binding) := nodes(root).kind then (
            parsed_bindings = 1;
            if resolve_binding_pattern{binding.pattern, input_len} == 0 then (
                lowering_unimplemented = 1;
            ) else (
                if binding_has_any_annotations{} == 1 then (
                    parsed_annotated = 1;
                ) else (
                    {}
                );

                if output_ok == 1 && lowering_unimplemented == 0 then (
                    lowering_result := lower_binding_expr{binding.expr, input_len};
                    lowering_code := lowering_result |> match {
                        LowerBindingResult::Ok => 0,
                        LowerBindingResult::Unimplemented => 1,
                        LowerBindingResult::OutputError => 2,
                        LowerBindingResult::InputError => 3,
                        else => 4
                    };
                    if lowering_code == 1 then (
                        lowering_unimplemented = 1;
                    ) else if lowering_code == 2 then (
                        output_ok = 0;
                    ) else if lowering_code == 3 then (
                        body_ok = 0;
                    ) else if lowering_code == 4 then (
                        output_ok = 0;
                    ) else (
                        {}
                    );
                    {}
                ) else (
                    {}
                );

                if output_ok == 1 && emit_inline_binding_for_binding{binding.expr, input_len} == 0 then (
                    output_ok = 0;
                ) else (
                    {}
                );

                if body_ok == 1 && update_known_type_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else if body_ok == 1 && update_known_scalar_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else (
                    {}
                )
            )
        ) else (
            parsed_bindings = 0;
        );
        idx = 1;
    );

    lower_state.parse_cursor = idx;
    lower_state.parsed_binding_count = parsed_bindings;
    lower_state.parsed_annotated_binding_count = parsed_annotated;
    lower_state.header_annotated_binding_count = parsed_annotated;
    lower_state.body_ok = body_ok;
    lower_state.lowering_unimplemented = lowering_unimplemented;

    if body_ok == 0 then 0
    else if parsed_bindings != binding_count then 0
    else if output_ok == 0 then 2
    else 1
);

run_lower_context := {root: i32, binding_count: i32, input_len: i32} => (
    lower_state.error_code = lower_error_none{};
    lower_state.last_scope_count = 1;
    lower_state.last_binding_count = binding_count;
    lower_state.last_input_len = input_len;
    lower_state.input_magic_ok = 0;
    lower_state.header_version = 0;
    lower_state.header_scope_count = 0;
    lower_state.header_binding_count = 0;
    lower_state.header_annotated_binding_count = 0;
    lower_state.parsed_binding_count = 0;
    lower_state.parsed_annotated_binding_count = 0;
    lower_state.parse_cursor = 0;
    lower_state.body_ok = 0;
    lower_state.header_ok = 0;
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.output_inline_binding_count = 0;
    lower_state.lowering_unimplemented = 0;

    lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
    lower_state.header_version = intermediate_payload_version{};
    lower_state.header_scope_count = 1;
    lower_state.header_binding_count = binding_count;

    if lower_state.input_magic_ok == 0 then (
        lower_state.error_code = lower_error_input_too_small{};
        lower_status_error{}
    ) else if binding_count < 0 then (
        lower_state.error_code = lower_error_header_count_mismatch{};
        lower_status_error{}
    ) else (
        parse_ok := parse_body_records{root, binding_count, input_len};
        if parse_ok == 0 then (
            if lower_state.body_ok == 0 then (
                lower_state.error_code = lower_error_body_parse_failed{};
            ) else (
                lower_state.error_code = lower_error_body_count_mismatch{};
            );
            lower_status_error{}
        ) else if parse_ok == 2 then (
            lower_state.error_code = lower_error_output_encode_failed{};
            lower_status_error{}
        ) else (
            lower_state.header_ok = 1;
            if lower_state.lowering_unimplemented == 1 then (
                lower_status_unimplemented{}
            ) else (
                finalize_ok := finalize_output_payload{};
                if finalize_ok == 0 then (
                    lower_state.error_code = lower_error_output_encode_failed{};
                    lower_status_error{}
                ) else (
                    lower_status_ok{}
                )
            )
        )
    )
);

(export wasm) lower_context := (root: i32) => (
    input_len := if state.cursor >= 0 && state.cursor <= MAX_INPUT then state.cursor else MAX_INPUT;
    binding_count := count_bindings_in_root(root);
    if binding_count < 0 then (
        lower_state.error_code = lower_error_body_parse_failed{};
        lower_state.last_scope_count = 1;
        lower_state.last_binding_count = 0;
        lower_state.last_input_len = input_len;
        lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
        lower_state.header_version = intermediate_payload_version{};
        lower_state.header_scope_count = 1;
        lower_state.header_binding_count = 0;
        lower_state.header_annotated_binding_count = 0;
        lower_state.parsed_binding_count = 0;
        lower_state.parsed_annotated_binding_count = 0;
        lower_state.parse_cursor = 0;
        lower_state.body_ok = 0;
        lower_state.header_ok = 0;
        lower_state.output_len = 0;
        lower_state.output_global_count = 0;
        lower_state.output_export_count = 0;
        lower_state.output_wrapper_count = 0;
        lower_state.output_inline_binding_count = 0;
        lower_state.lowering_unimplemented = 0;
        lower_status_error{}
    ) else (
        run_lower_context{root, binding_count, input_len}
    )
);

(export wasm) get_lower_error_code := {} => (
    lower_state.error_code
);

(export wasm) get_lower_last_scope_count := {} => (
    lower_state.last_scope_count
);

(export wasm) get_lower_last_binding_count := {} => (
    lower_state.last_binding_count
);

(export wasm) get_lower_last_input_len := {} => (
    lower_state.last_input_len
);

(export wasm) get_lower_input_magic_ok := {} => (
    lower_state.input_magic_ok
);

(export wasm) get_lower_header_version := {} => (
    lower_state.header_version
);

(export wasm) get_lower_header_scope_count := {} => (
    lower_state.header_scope_count
);

(export wasm) get_lower_header_binding_count := {} => (
    lower_state.header_binding_count
);

(export wasm) get_lower_header_annotated_binding_count := {} => (
    lower_state.header_annotated_binding_count
);

(export wasm) get_lower_header_ok := {} => (
    lower_state.header_ok
);

(export wasm) get_lower_parsed_binding_count := {} => (
    lower_state.parsed_binding_count
);

(export wasm) get_lower_parsed_annotated_binding_count := {} => (
    lower_state.parsed_annotated_binding_count
);

(export wasm) get_lower_parse_cursor := {} => (
    lower_state.parse_cursor
);

(export wasm) get_lower_body_ok := {} => (
    lower_state.body_ok
);

(export wasm) get_lower_output_len := {} => (
    lower_state.output_len
);

(export wasm) get_lower_output_global_count := {} => (
    lower_state.output_global_count
);

(export wasm) get_lower_output_export_count := {} => (
    lower_state.output_export_count
);

(export wasm) get_lower_output_wrapper_count := {} => (
    lower_state.output_wrapper_count
);

(export wasm) get_lower_output_inline_binding_count := {} => (
    lower_state.output_inline_binding_count
);

(export wasm) get_lower_lowering_unimplemented := {} => (
    lower_state.lowering_unimplemented
);

(export wasm) get_lower_output_global_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_start
);

(export wasm) get_lower_output_global_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_length
);

(export wasm) get_lower_output_global_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).ty_tag
);

(export wasm) get_lower_output_global_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_tag
);

(export wasm) get_lower_output_global_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_i32
);

(export wasm) get_lower_output_export_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).target_tag
);

(export wasm) get_lower_output_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).export_type
);

(export wasm) get_lower_output_export_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).index
);

(export wasm) get_lower_output_export_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_start
);

(export wasm) get_lower_output_export_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_length
);

(export wasm) get_lower_output_wrapper_source_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).source_target_tag
);

(export wasm) get_lower_output_wrapper_wrap_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).wrap_target_tag
);

(export wasm) get_lower_output_wrapper_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).export_type
);

(export wasm) get_lower_output_wrapper_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).index
);

(export wasm) get_lower_output_wrapper_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_start
);

(export wasm) get_lower_output_wrapper_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_length
);

(export wasm) get_lower_output_inline_binding_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).name_start
);

(export wasm) get_lower_output_inline_binding_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).name_length
);

(export wasm) get_lower_output_inline_binding_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).value_tag
);

(export wasm) get_lower_output_inline_binding_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).value_i32
);

