types := use "types.silk";

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;
MAX_OUTPUT_GLOBALS := 4096;
MAX_OUTPUT_EXPORTS := 12288;
MAX_OUTPUT_WRAPPERS := 12288;

StringRef := types.StringRef;
TargetLiteral := types.TargetLiteral;
BindingAnnotationLiteral := types.BindingAnnotationLiteral;
ExpressionLiteral := types.ExpressionLiteral;
IntrinsicType := types.IntrinsicType;
BindingPattern := types.BindingPattern;
NodeKind := types.NodeKind;
Node := types.Node;
ListNode := types.ListNode;
State := types.State;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

INPUT_VALUE_NUMBER := 0;
INPUT_VALUE_BOOLEAN := 1;
INPUT_VALUE_CHAR := 2;

INPUT_VALUE_TYPE_UNKNOWN := 0;
INPUT_VALUE_TYPE_I32 := 1;
INPUT_VALUE_TYPE_U8 := 2;

TARGET_MASK_JS := types.TARGET_MASK_JS;
TARGET_MASK_WASM := types.TARGET_MASK_WASM;
TARGET_MASK_WGSL := types.TARGET_MASK_WGSL;

VALUE_TAG_UNKNOWN := 0;
VALUE_TAG_NUMBER := 1;
VALUE_TAG_BOOLEAN := 2;
VALUE_TAG_CHAR := 3;

OUTPUT_TARGET_JS := types.TARGET_JS;
OUTPUT_TARGET_WASM := types.TARGET_WASM;
OUTPUT_TARGET_WGSL := types.TARGET_WGSL;

OUTPUT_EXPORT_TYPE_FUNCTION := 0;
OUTPUT_EXPORT_TYPE_GLOBAL := 1;

OUTPUT_GLOBAL_TYPE_I32 := 0;
OUTPUT_GLOBAL_TYPE_U8 := 1;

LowerStatus := enum {
    Ok = {},
    Unimplemented = {},
    Error = {},
};

LowerError := enum {
    None = {},
    InputTooSmall = {},
    BadMagic = {},
    BadVersion = {},
    HeaderCountMismatch = {},
    BodyParseFailed = {},
    BodyCountMismatch = {},
    OutputEncodeFailed = {},
};

LowerBindingResult := enum {
    Ok = {},
    Unimplemented = {},
    OutputError = {},
    InputError = {},
};

WrapperSourceTarget := enum {
    Missing = {},
    Target = i32,
};

OutputGlobalSlot := {
    name_start = i32,
    name_length = i32,
    ty_tag = i32,
    value_tag = i32,
    value_i32 = i32,
};

OutputExportSlot := {
    target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputWrapperSlot := {
    source_target_tag = i32,
    wrap_target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

EMPTY_OUTPUT_GLOBAL_SLOT := {
    name_start = 0,
    name_length = 0,
    ty_tag = 0,
    value_tag = 0,
    value_i32 = 0,
};

EMPTY_OUTPUT_EXPORT_SLOT := {
    target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_WRAPPER_SLOT := {
    source_target_tag = 0,
    wrap_target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

lower_status_ok := {} => (
    0
);

lower_status_unimplemented := {} => (
    1
);

lower_status_error := {} => (
    2
);

lower_error_none := {} => (
    0
);

lower_error_input_too_small := {} => (
    1
);

lower_error_bad_magic := {} => (
    2
);

lower_error_bad_version := {} => (
    3
);

lower_error_header_count_mismatch := {} => (
    4
);

lower_error_body_parse_failed := {} => (
    5
);

lower_error_body_count_mismatch := {} => (
    6
);

lower_error_output_encode_failed := {} => (
    7
);

(export wasm) intermediate_payload_version := {} => (
    6
);

(export wasm) intermediate_output_version := {} => (
    2
);

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

(export wasm) mut output_globals: Box({OutputGlobalSlot; MAX_OUTPUT_GLOBALS}) := {EMPTY_OUTPUT_GLOBAL_SLOT; MAX_OUTPUT_GLOBALS};
(export wasm) mut output_exports: Box({OutputExportSlot; MAX_OUTPUT_EXPORTS}) := {EMPTY_OUTPUT_EXPORT_SLOT; MAX_OUTPUT_EXPORTS};
(export wasm) mut output_wrappers: Box({OutputWrapperSlot; MAX_OUTPUT_WRAPPERS}) := {EMPTY_OUTPUT_WRAPPER_SLOT; MAX_OUTPUT_WRAPPERS};

LowerState := {
    error_code = i32,
    last_scope_count = i32,
    last_binding_count = i32,
    last_input_len = i32,
    input_magic_ok = i32,
    header_version = i32,
    header_scope_count = i32,
    header_binding_count = i32,
    header_annotated_binding_count = i32,
    parsed_binding_count = i32,
    parsed_annotated_binding_count = i32,
    parse_cursor = i32,
    body_ok = i32,
    header_ok = i32,
    output_len = i32,
    output_global_count = i32,
    output_export_count = i32,
    output_wrapper_count = i32,
    lowering_unimplemented = i32,
};

(export wasm) mut lower_state: Box(LowerState) := {
    error_code = 0,
    last_scope_count = 0,
    last_binding_count = 0,
    last_input_len = 0,
    input_magic_ok = 0,
    header_version = 0,
    header_scope_count = 0,
    header_binding_count = 0,
    header_annotated_binding_count = 0,
    parsed_binding_count = 0,
    parsed_annotated_binding_count = 0,
    parse_cursor = 0,
    body_ok = 0,
    header_ok = 0,
    output_len = 0,
    output_global_count = 0,
    output_export_count = 0,
    output_wrapper_count = 0,
    lowering_unimplemented = 0,
};

AnnotationState := {
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
};

BindingExtractState := {
    ok = i32,
    name_start = i32,
    name_length = i32,
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
    value_type_tag = i32,
};

LiteralExtractState := {
    tag = i32,
    payload_i32 = i32,
};

mut annotation_state: Box(AnnotationState) := {
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
};
mut binding_extract_state: Box(BindingExtractState) := {
    ok = 0,
    name_start = 0,
    name_length = 0,
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};
mut literal_extract_state: Box(LiteralExtractState) := {
    tag = -1,
    payload_i32 = 0,
};

(export wasm) intermediate_stage_version := {} => (
    5
);

target_mask_has := {mask: i32, bit: i32} => (
    if bit <= 0 then 0 else (
        q := mask / bit;
        if q - (q / 2) * 2 == 1 then 1 else 0
    )
);

target_mask_or := {left: i32, right: i32} => (
    js := if target_mask_has{left, TARGET_MASK_JS} == 1 || target_mask_has{right, TARGET_MASK_JS} == 1 then TARGET_MASK_JS else 0;
    wasm := if target_mask_has{left, TARGET_MASK_WASM} == 1 || target_mask_has{right, TARGET_MASK_WASM} == 1 then TARGET_MASK_WASM else 0;
    wgsl := if target_mask_has{left, TARGET_MASK_WGSL} == 1 || target_mask_has{right, TARGET_MASK_WGSL} == 1 then TARGET_MASK_WGSL else 0;
    js + wasm + wgsl
);

target_count := (mask: i32) => (
    target_mask_has{mask, TARGET_MASK_JS}
        + target_mask_has{mask, TARGET_MASK_WASM}
        + target_mask_has{mask, TARGET_MASK_WGSL}
);

first_target_tag := (mask: i32) => (
    if target_mask_has{mask, TARGET_MASK_JS} == 1 then OUTPUT_TARGET_JS
    else if target_mask_has{mask, TARGET_MASK_WASM} == 1 then OUTPUT_TARGET_WASM
    else if target_mask_has{mask, TARGET_MASK_WGSL} == 1 then OUTPUT_TARGET_WGSL
    else -1
);

string_ref_matches_2 := {value: StringRef, c0: u8, c1: u8} => (
    if value.start < 0 || value.length != 2 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 then 1 else 0
);

string_ref_matches_4 := {value: StringRef, c0: u8, c1: u8, c2: u8, c3: u8} => (
    if value.start < 0 || value.length != 4 then 0
    else if input(value.start) == c0
        && input(value.start + 1) == c1
        && input(value.start + 2) == c2
        && input(value.start + 3) == c3
    then 1 else 0
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'm' && input(value.start + 1) == 'u' && input(value.start + 2) == 't' then 1 else 0
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 'e'
        && input(value.start + 1) == 'x'
        && input(value.start + 2) == 'p'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 't'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_wrap := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 4 then 0
    else if input(value.start) == 'w'
        && input(value.start + 1) == 'r'
        && input(value.start + 2) == 'a'
        && input(value.start + 3) == 'p'
    then 1 else 0
);

string_ref_is_js := (value: StringRef) => (
    string_ref_matches_2{value, 'j', 's'}
);

string_ref_is_wasm := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'a', 's', 'm'}
);

string_ref_is_wgsl := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'g', 's', 'l'}
);

target_mask_from_target_literal := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TARGET_MASK_JS,
        TargetLiteral::WasmTarget => TARGET_MASK_WASM,
        TargetLiteral::WgslTarget => TARGET_MASK_WGSL,
        else => 0
    }
);

target_mask_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_js(id.name) == 1 then TARGET_MASK_JS
                else if string_ref_is_wasm(id.name) == 1 then TARGET_MASK_WASM
                else if string_ref_is_wgsl(id.name) == 1 then TARGET_MASK_WGSL
                else 0
            ),
            NodeKind::Literal(ExpressionLiteral::Target(target)) => target_mask_from_target_literal(target),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Export(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Target(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Wrap(target) => target_mask_from_target_literal(target),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

reset_annotation_state := {} => (
    annotation_state.is_mut = 0;
    annotation_state.target_mask = 0;
    annotation_state.export_mask = 0;
    annotation_state.wrap_mask = 0;
    1
);

apply_annotation_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_mut(id.name) == 1 then (
                    annotation_state.is_mut = 1;
                    1
                ) else (
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                target_mask := target_mask_from_expr(info.argument);
                if target_mask == 0 then (
                    0
                ) else if NodeKind::Identifier(id) := nodes(info.function).kind then (
                    if string_ref_is_export(id.name) == 1 then (
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, target_mask};
                        1
                    ) else if string_ref_is_target(id.name) == 1 then (
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, target_mask};
                        1
                    ) else if string_ref_is_wrap(id.name) == 1 then (
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, target_mask};
                        1
                    ) else (
                        0
                    )
                ) else (
                    0
                )
            ),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => (
                        annotation_state.is_mut = 1;
                        1
                    ),
                    BindingAnnotationLiteral::Export(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Target(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Wrap(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, ann_mask};
                        1
                    ),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

apply_annotation_list := (head: i32) => (
    mut current := head;
    mut ok := 1;
    while current != -1 && ok == 1 do (
        ann_idx := list_nodes(current).value;
        if apply_annotation_expr(ann_idx) == 1 then (
            current = list_nodes(current).next;
        ) else (
            ok = 0;
            current = -1;
        );
        {}
    );
    ok
);

reset_binding_extract_state := {} => (
    binding_extract_state.ok = 0;
    binding_extract_state.name_start = 0;
    binding_extract_state.name_length = 0;
    binding_extract_state.is_mut = 0;
    binding_extract_state.target_mask = 0;
    binding_extract_state.export_mask = 0;
    binding_extract_state.wrap_mask = 0;
    binding_extract_state.value_type_tag = INPUT_VALUE_TYPE_UNKNOWN;
    1
);

set_binding_name := {start: i32, length: i32} => (
    if start < 0 || length < 0 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        binding_extract_state.ok = 1;
        binding_extract_state.name_start = start;
        binding_extract_state.name_length = length;
        1
    )
);

resolve_binding_name_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => set_binding_name{id.name.start, id.name.length},
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    resolve_binding_name_from_expr(info.left)
                ) else (
                    binding_extract_state.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => resolve_binding_name_from_expr(info.argument),
            else => (
                binding_extract_state.ok = 0;
                0
            )
        }
    )
);

value_type_tag_from_type_expr := (expr_idx: i32) => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN else (
        nodes(expr_idx).kind |> match {
            NodeKind::IntrinsicType(ty) => (
                ty |> match {
                    IntrinsicType::U8 => INPUT_VALUE_TYPE_U8,
                    IntrinsicType::I32 => INPUT_VALUE_TYPE_I32,
                    IntrinsicType::Boolean => INPUT_VALUE_TYPE_I32,
                    else => INPUT_VALUE_TYPE_UNKNOWN
                }
            ),
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

value_type_tag_from_pattern_expr := (expr_idx: i32) => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN else (
        nodes(expr_idx).kind |> match {
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    value_type_tag_from_type_expr(info.right)
                ) else (
                    INPUT_VALUE_TYPE_UNKNOWN
                )
            ),
            NodeKind::FunctionCall(info) => value_type_tag_from_pattern_expr(info.argument),
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

resolve_binding_pattern := (pattern: BindingPattern) => (
    reset_binding_extract_state{};
    pattern |> match {
        BindingPattern::Identifier(info) => (
            set_binding_name{info.name.name.start, info.name.name.length};
            binding_extract_state.ok
        ),
        BindingPattern::TypeHint(info) => (
            if resolve_binding_name_from_expr(info.pattern) == 0 then 0 else (
                binding_extract_state.value_type_tag = value_type_tag_from_type_expr(info.type_expr);
                binding_extract_state.ok
            )
        ),
        BindingPattern::Annotated(info) => (
            if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotation_list(info.annotations) == 0 then (
                0
            ) else if resolve_binding_name_from_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.value_type_tag = value_type_tag_from_pattern_expr(info.pattern);
                binding_extract_state.ok
            )
        ),
        else => (
            binding_extract_state.ok = 0;
            0
        )
    }
);

extract_literal_value := (expr_idx: i32) => (
    literal_extract_state.tag = -1;
    literal_extract_state.payload_i32 = 0;
    if expr_idx == -1 then (
        1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(value) => (
                value |> match {
                    ExpressionLiteral::Number(number) => (
                        literal_extract_state.tag = INPUT_VALUE_NUMBER;
                        literal_extract_state.payload_i32 = number;
                        1
                    ),
                    ExpressionLiteral::Boolean(boolean) => (
                        literal_extract_state.tag = INPUT_VALUE_BOOLEAN;
                        literal_extract_state.payload_i32 = boolean;
                        1
                    ),
                    ExpressionLiteral::Char(ch) => (
                        literal_extract_state.tag = INPUT_VALUE_CHAR;
                        literal_extract_state.payload_i32 = ch;
                        1
                    ),
                    else => 1
                }
            ),
            else => 1
        }
    )
);

binding_has_any_annotations := {} => (
    if binding_extract_state.is_mut != 0
        || binding_extract_state.target_mask != 0
        || binding_extract_state.export_mask != 0
        || binding_extract_state.wrap_mask != 0
    then 1 else 0
);

binding_should_materialize := {} => (
    if binding_extract_state.is_mut != 0 || binding_extract_state.export_mask != 0 then 1 else 0
);

output_value_tag_from_input_tag := (tag: i32) => (
    if tag == INPUT_VALUE_NUMBER then VALUE_TAG_NUMBER
    else if tag == INPUT_VALUE_BOOLEAN then VALUE_TAG_BOOLEAN
    else if tag == INPUT_VALUE_CHAR then VALUE_TAG_CHAR
    else VALUE_TAG_UNKNOWN
);

safe_name_bounds := {start: i32, length: i32, input_len: i32} => (
    if start < 0 || length < 0 || input_len < 0 then 0
    else if start + length > input_len then 0
    else if start + length > MAX_INPUT then 0
    else 1
);

resolve_wrapper_source_target := {} => (
    if target_count(binding_extract_state.wrap_mask) == 0 then WrapperSourceTarget::Missing{} else (
        source_target_tag := first_target_tag(binding_extract_state.export_mask);
        if source_target_tag < 0 then WrapperSourceTarget::Missing{} else WrapperSourceTarget::Target(source_target_tag)
    )
);

reset_output_slots := {} => (
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    1
);

emit_global_entry := {
    name_start: i32,
    name_length: i32,
    ty_tag: i32,
    value_tag: i32,
    value_i32: i32
} => (
    idx := lower_state.output_global_count;
    if idx < 0 || idx >= MAX_OUTPUT_GLOBALS then -1 else (
        output_globals(idx).name_start = name_start;
        output_globals(idx).name_length = name_length;
        output_globals(idx).ty_tag = ty_tag;
        output_globals(idx).value_tag = value_tag;
        output_globals(idx).value_i32 = value_i32;
        lower_state.output_global_count = idx + 1;
        idx
    )
);

emit_export_entry := {
    target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_export_count;
    if idx < 0 || idx >= MAX_OUTPUT_EXPORTS then 0 else (
        output_exports(idx).target_tag = target_tag;
        output_exports(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_exports(idx).index = global_index;
        output_exports(idx).name_start = name_start;
        output_exports(idx).name_length = name_length;
        lower_state.output_export_count = idx + 1;
        1
    )
);

emit_wrapper_entry := {
    source_target_tag: i32,
    wrap_target_tag: i32,
    global_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_wrapper_count;
    if idx < 0 || idx >= MAX_OUTPUT_WRAPPERS then 0 else (
        output_wrappers(idx).source_target_tag = source_target_tag;
        output_wrappers(idx).wrap_target_tag = wrap_target_tag;
        output_wrappers(idx).export_type = OUTPUT_EXPORT_TYPE_GLOBAL;
        output_wrappers(idx).index = global_index;
        output_wrappers(idx).name_start = name_start;
        output_wrappers(idx).name_length = name_length;
        lower_state.output_wrapper_count = idx + 1;
        1
    )
);

resolve_output_global_type_tag := (value_tag: i32) => (
    if binding_extract_state.value_type_tag == INPUT_VALUE_TYPE_U8 then OUTPUT_GLOBAL_TYPE_U8
    else if binding_extract_state.value_type_tag == INPUT_VALUE_TYPE_I32 then OUTPUT_GLOBAL_TYPE_I32
    else if value_tag == VALUE_TAG_CHAR then OUTPUT_GLOBAL_TYPE_U8
    else OUTPUT_GLOBAL_TYPE_I32
);

lower_binding_expr := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then LowerBindingResult::InputError{}
    else if binding_extract_state.export_mask < 0 || binding_extract_state.wrap_mask < 0 || binding_extract_state.target_mask < 0 then LowerBindingResult::InputError{}
    else if binding_should_materialize{} == 0 then LowerBindingResult::Ok{}
    else (
        extract_literal_value(expr_idx);
        value_tag := output_value_tag_from_input_tag(literal_extract_state.tag);
        if value_tag == VALUE_TAG_UNKNOWN then LowerBindingResult::Unimplemented{} else (
            global_type_tag := resolve_output_global_type_tag(value_tag);
            global_index := emit_global_entry{
                binding_extract_state.name_start,
                binding_extract_state.name_length,
                global_type_tag,
                value_tag,
                literal_extract_state.payload_i32
            };
            if global_index < 0 then LowerBindingResult::OutputError{} else (
                mut emit_ok := 1;
                if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                    emit_ok = emit_export_entry{
                        OUTPUT_TARGET_JS,
                        global_index,
                        binding_extract_state.name_start,
                        binding_extract_state.name_length
                    };
                ) else (
                    {}
                );
                if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                    emit_ok = emit_export_entry{
                        OUTPUT_TARGET_WASM,
                        global_index,
                        binding_extract_state.name_start,
                        binding_extract_state.name_length
                    };
                ) else (
                    {}
                );
                if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                    emit_ok = emit_export_entry{
                        OUTPUT_TARGET_WGSL,
                        global_index,
                        binding_extract_state.name_start,
                        binding_extract_state.name_length
                    };
                ) else (
                    {}
                );
                if emit_ok == 0 then LowerBindingResult::OutputError{}
                else (
                    wrapper_source_target := resolve_wrapper_source_target{};
                    wrapper_source_target |> match {
                        WrapperSourceTarget::Missing => (
                            LowerBindingResult::Ok{}
                        ),
                        WrapperSourceTarget::Target(source_target_tag) => (
                            if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                emit_ok = emit_wrapper_entry{
                                    source_target_tag,
                                    OUTPUT_TARGET_JS,
                                    global_index,
                                    binding_extract_state.name_start,
                                    binding_extract_state.name_length
                                };
                            ) else (
                                {}
                            );
                            if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                emit_ok = emit_wrapper_entry{
                                    source_target_tag,
                                    OUTPUT_TARGET_WASM,
                                    global_index,
                                    binding_extract_state.name_start,
                                    binding_extract_state.name_length
                                };
                            ) else (
                                {}
                            );
                            if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                emit_ok = emit_wrapper_entry{
                                    source_target_tag,
                                    OUTPUT_TARGET_WGSL,
                                    global_index,
                                    binding_extract_state.name_start,
                                    binding_extract_state.name_length
                                };
                            ) else (
                                {}
                            );
                            if emit_ok == 1 then LowerBindingResult::Ok{} else LowerBindingResult::OutputError{}
                        ),
                        else => LowerBindingResult::OutputError{}
                    }
                )
            )
        )
    )
);

finalize_output_payload := {} => (
    if lower_state.output_global_count == 0
        && lower_state.output_export_count == 0
        && lower_state.output_wrapper_count == 0
    then (
        lower_state.output_len = 0;
        1
    ) else (
        lower_state.output_len = lower_state.output_global_count
            + lower_state.output_export_count
            + lower_state.output_wrapper_count;
        1
    )
);

count_bindings_in_root := (root: i32) => (
    if root < 0 || root >= MAX_NODES then -1 else (
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut idx := 0;
            mut binding_count := 0;
            while idx < list.count && current != -1 do (
                node_idx := list_nodes(current).value;
                if node_idx >= 0 && node_idx < MAX_NODES then (
                    if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                        binding_count = binding_count + 1;
                        {}
                    ) else (
                        {}
                    )
                ) else (
                    {}
                );
                current = list_nodes(current).next;
                idx = idx + 1;
                {}
            );
            binding_count
        ) else (
            if NodeKind::Binding(binding) := nodes(root).kind then 1 else 0
        )
    )
);

parse_body_records := {root: i32, binding_count: i32, input_len: i32} => (
    mut idx := 0;
    mut parsed_bindings := 0;
    mut parsed_annotated := 0;
    mut body_ok := 1;
    mut output_ok := reset_output_slots{};
    mut lowering_unimplemented := 0;

    if root < 0 || root >= MAX_NODES then (
        body_ok = 0;
    ) else if NodeKind::Block(list) := nodes(root).kind then (
        mut current := list.head;
        while idx < list.count && current != -1 && body_ok == 1 do (
            node_idx := list_nodes(current).value;
            if node_idx < 0 || node_idx >= MAX_NODES then (
                body_ok = 0;
            ) else if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                if resolve_binding_pattern(binding.pattern) == 0 then (
                    body_ok = 0;
                ) else (
                    parsed_bindings = parsed_bindings + 1;
                    if binding_has_any_annotations{} == 1 then (
                        parsed_annotated = parsed_annotated + 1;
                    ) else (
                        {}
                    );

                    if output_ok == 1 && lowering_unimplemented == 0 then (
                        lowering_result := lower_binding_expr{binding.expr, input_len};
                        lowering_result |> match {
                            LowerBindingResult::Ok => (
                                {}
                            ),
                            LowerBindingResult::Unimplemented => (
                                lowering_unimplemented = 1;
                                {}
                            ),
                            LowerBindingResult::OutputError => (
                                output_ok = 0;
                                {}
                            ),
                            LowerBindingResult::InputError => (
                                body_ok = 0;
                                {}
                            ),
                            else => (
                                output_ok = 0;
                                {}
                            )
                        }
                    ) else (
                        {}
                    )
                )
            ) else (
                {}
            );
            current = list_nodes(current).next;
            idx = idx + 1;
            {}
        );
    ) else (
        if NodeKind::Binding(binding) := nodes(root).kind then (
            parsed_bindings = 1;
            if resolve_binding_pattern(binding.pattern) == 0 then (
                body_ok = 0;
            ) else (
                if binding_has_any_annotations{} == 1 then (
                    parsed_annotated = 1;
                ) else (
                    {}
                );

                if output_ok == 1 && lowering_unimplemented == 0 then (
                    lowering_result := lower_binding_expr{binding.expr, input_len};
                    lowering_result |> match {
                        LowerBindingResult::Ok => (
                            {}
                        ),
                        LowerBindingResult::Unimplemented => (
                            lowering_unimplemented = 1;
                            {}
                        ),
                        LowerBindingResult::OutputError => (
                            output_ok = 0;
                            {}
                        ),
                        LowerBindingResult::InputError => (
                            body_ok = 0;
                            {}
                        ),
                        else => (
                            output_ok = 0;
                            {}
                        )
                    }
                ) else (
                    {}
                )
            )
        ) else (
            parsed_bindings = 0;
        );
        idx = 1;
    );

    lower_state.parse_cursor = idx;
    lower_state.parsed_binding_count = parsed_bindings;
    lower_state.parsed_annotated_binding_count = parsed_annotated;
    lower_state.header_annotated_binding_count = parsed_annotated;
    lower_state.body_ok = body_ok;
    lower_state.lowering_unimplemented = lowering_unimplemented;

    if body_ok == 0 then 0
    else if parsed_bindings != binding_count then 0
    else if output_ok == 0 then 2
    else 1
);

run_lower_context := {root: i32, binding_count: i32, input_len: i32} => (
    lower_state.error_code = lower_error_none{};
    lower_state.last_scope_count = 1;
    lower_state.last_binding_count = binding_count;
    lower_state.last_input_len = input_len;
    lower_state.input_magic_ok = 0;
    lower_state.header_version = 0;
    lower_state.header_scope_count = 0;
    lower_state.header_binding_count = 0;
    lower_state.header_annotated_binding_count = 0;
    lower_state.parsed_binding_count = 0;
    lower_state.parsed_annotated_binding_count = 0;
    lower_state.parse_cursor = 0;
    lower_state.body_ok = 0;
    lower_state.header_ok = 0;
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.lowering_unimplemented = 0;

    lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
    lower_state.header_version = intermediate_payload_version{};
    lower_state.header_scope_count = 1;
    lower_state.header_binding_count = binding_count;

    if lower_state.input_magic_ok == 0 then (
        lower_state.error_code = lower_error_input_too_small{};
        lower_status_error{}
    ) else if binding_count < 0 then (
        lower_state.error_code = lower_error_header_count_mismatch{};
        lower_status_error{}
    ) else (
        parse_ok := parse_body_records{root, binding_count, input_len};
        if parse_ok == 0 then (
            if lower_state.body_ok == 0 then (
                lower_state.error_code = lower_error_body_parse_failed{};
            ) else (
                lower_state.error_code = lower_error_body_count_mismatch{};
            );
            lower_status_error{}
        ) else if parse_ok == 2 then (
            lower_state.error_code = lower_error_output_encode_failed{};
            lower_status_error{}
        ) else (
            lower_state.header_ok = 1;
            if lower_state.lowering_unimplemented == 1 then (
                lower_status_unimplemented{}
            ) else (
                finalize_ok := finalize_output_payload{};
                if finalize_ok == 0 then (
                    lower_state.error_code = lower_error_output_encode_failed{};
                    lower_status_error{}
                ) else (
                    lower_status_ok{}
                )
            )
        )
    )
);

(export wasm) lower_context := (root: i32) => (
    input_len := if state.cursor >= 0 && state.cursor <= MAX_INPUT then state.cursor else MAX_INPUT;
    binding_count := count_bindings_in_root(root);
    if binding_count < 0 then (
        lower_state.error_code = lower_error_body_parse_failed{};
        lower_state.last_scope_count = 1;
        lower_state.last_binding_count = 0;
        lower_state.last_input_len = input_len;
        lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
        lower_state.header_version = intermediate_payload_version{};
        lower_state.header_scope_count = 1;
        lower_state.header_binding_count = 0;
        lower_state.header_annotated_binding_count = 0;
        lower_state.parsed_binding_count = 0;
        lower_state.parsed_annotated_binding_count = 0;
        lower_state.parse_cursor = 0;
        lower_state.body_ok = 0;
        lower_state.header_ok = 0;
        lower_state.output_len = 0;
        lower_state.output_global_count = 0;
        lower_state.output_export_count = 0;
        lower_state.output_wrapper_count = 0;
        lower_state.lowering_unimplemented = 0;
        lower_status_error{}
    ) else (
        run_lower_context{root, binding_count, input_len}
    )
);

(export wasm) get_lower_error_code := {} => (
    lower_state.error_code
);

(export wasm) get_lower_last_scope_count := {} => (
    lower_state.last_scope_count
);

(export wasm) get_lower_last_binding_count := {} => (
    lower_state.last_binding_count
);

(export wasm) get_lower_last_input_len := {} => (
    lower_state.last_input_len
);

(export wasm) get_lower_input_magic_ok := {} => (
    lower_state.input_magic_ok
);

(export wasm) get_lower_header_version := {} => (
    lower_state.header_version
);

(export wasm) get_lower_header_scope_count := {} => (
    lower_state.header_scope_count
);

(export wasm) get_lower_header_binding_count := {} => (
    lower_state.header_binding_count
);

(export wasm) get_lower_header_annotated_binding_count := {} => (
    lower_state.header_annotated_binding_count
);

(export wasm) get_lower_header_ok := {} => (
    lower_state.header_ok
);

(export wasm) get_lower_parsed_binding_count := {} => (
    lower_state.parsed_binding_count
);

(export wasm) get_lower_parsed_annotated_binding_count := {} => (
    lower_state.parsed_annotated_binding_count
);

(export wasm) get_lower_parse_cursor := {} => (
    lower_state.parse_cursor
);

(export wasm) get_lower_body_ok := {} => (
    lower_state.body_ok
);

(export wasm) get_lower_output_len := {} => (
    lower_state.output_len
);

(export wasm) get_lower_output_global_count := {} => (
    lower_state.output_global_count
);

(export wasm) get_lower_output_export_count := {} => (
    lower_state.output_export_count
);

(export wasm) get_lower_output_wrapper_count := {} => (
    lower_state.output_wrapper_count
);

(export wasm) get_lower_lowering_unimplemented := {} => (
    lower_state.lowering_unimplemented
);

(export wasm) get_lower_output_global_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_start
);

(export wasm) get_lower_output_global_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_length
);

(export wasm) get_lower_output_global_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).ty_tag
);

(export wasm) get_lower_output_global_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_tag
);

(export wasm) get_lower_output_global_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_i32
);

(export wasm) get_lower_output_export_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).target_tag
);

(export wasm) get_lower_output_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).export_type
);

(export wasm) get_lower_output_export_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).index
);

(export wasm) get_lower_output_export_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_start
);

(export wasm) get_lower_output_export_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_length
);

(export wasm) get_lower_output_wrapper_source_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).source_target_tag
);

(export wasm) get_lower_output_wrapper_wrap_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).wrap_target_tag
);

(export wasm) get_lower_output_wrapper_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).export_type
);

(export wasm) get_lower_output_wrapper_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).index
);

(export wasm) get_lower_output_wrapper_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_start
);

(export wasm) get_lower_output_wrapper_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_length
);
