types := use "types.silk";

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;
MAX_OUTPUT_FUNCTIONS := 4096;
MAX_OUTPUT_GLOBALS := 4096;
MAX_OUTPUT_EXPORTS := 12288;
MAX_OUTPUT_WRAPPERS := 12288;
MAX_OUTPUT_INLINE_BINDINGS := 8192;
MAX_OUTPUT_VALUES := 65536;
MAX_OUTPUT_VALUE_FIELDS := 131072;
MAX_KNOWN_TYPE_ALIASES := 2048;
MAX_KNOWN_SCALAR_ALIASES := 2048;
MAX_KNOWN_VALUE_ALIASES := 8192;
MAX_KNOWN_FUNCTION_ALIASES := 2048;

StringRef := types.StringRef;
TargetLiteral := types.TargetLiteral;
BindingAnnotationLiteral := types.BindingAnnotationLiteral;
ExpressionLiteral := types.ExpressionLiteral;
IntrinsicType := types.IntrinsicType;
UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;
BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;
IntrinsicOperation := types.IntrinsicOperation;
DivergeExpressionType := types.DivergeExpressionType;
BindingPattern := types.BindingPattern;
LValue := types.LValue;
Binding := types.Binding;
NodeKind := types.NodeKind;
Node := types.Node;
ListNode := types.ListNode;
ExpressionList := types.ExpressionList;
State := types.State;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

INPUT_VALUE_TYPE_UNKNOWN := 0;
INPUT_VALUE_TYPE_I32 := 1;
INPUT_VALUE_TYPE_U8 := 2;

TARGET_MASK_JS := types.TARGET_MASK_JS;
TARGET_MASK_WASM := types.TARGET_MASK_WASM;
TARGET_MASK_WGSL := types.TARGET_MASK_WGSL;

VALUE_TAG_UNKNOWN := 0;
VALUE_TAG_NUMBER := 1;
VALUE_TAG_BOOLEAN := 2;
VALUE_TAG_CHAR := 3;

OUTPUT_TARGET_JS := types.TARGET_JS;
OUTPUT_TARGET_WASM := types.TARGET_WASM;
OUTPUT_TARGET_WGSL := types.TARGET_WGSL;

OUTPUT_EXPORT_TYPE_FUNCTION := 0;
OUTPUT_EXPORT_TYPE_GLOBAL := 1;

OUTPUT_GLOBAL_TYPE_INFER := -1;
OUTPUT_GLOBAL_TYPE_I32 := 0;
OUTPUT_GLOBAL_TYPE_U8 := 1;

OUTPUT_VALUE_KIND_UNKNOWN := 0;
OUTPUT_VALUE_KIND_NUMBER := 1;
OUTPUT_VALUE_KIND_BOOLEAN := 2;
OUTPUT_VALUE_KIND_CHAR := 3;
OUTPUT_VALUE_KIND_STRUCT := 4;
OUTPUT_VALUE_KIND_ARRAY := 5;
OUTPUT_VALUE_KIND_INTRINSIC_BINARY := 6;
OUTPUT_VALUE_KIND_INTRINSIC_UNARY := 7;
OUTPUT_VALUE_KIND_IF := 8;
OUTPUT_VALUE_KIND_IDENTIFIER := 9;
OUTPUT_VALUE_KIND_TYPE_PROPERTY_ACCESS := 10;
OUTPUT_VALUE_KIND_ARRAY_INDEX := 11;
OUTPUT_VALUE_KIND_BLOCK := 12;
OUTPUT_VALUE_KIND_DIVERGE := 13;
OUTPUT_VALUE_KIND_LOOP := 14;
OUTPUT_VALUE_KIND_FUNCTION_CALL := 15;
OUTPUT_VALUE_KIND_INLINE_ASSEMBLY := 16;
OUTPUT_VALUE_KIND_ASSIGNMENT := 17;
OUTPUT_VALUE_KIND_BINDING := 18;

VALUE_REF_LOOKUP_MISSING := -1;
VALUE_REF_LOOKUP_INPUT_ERROR := -2;
VALUE_REF_LOOKUP_OUTPUT_ERROR := -3;

LowerStatus := enum {
    Ok = {},
    Unimplemented = {},
    Error = {},
};

LowerError := enum {
    None = {},
    InputTooSmall = {},
    BadMagic = {},
    BadVersion = {},
    HeaderCountMismatch = {},
    BodyParseFailed = {},
    BodyCountMismatch = {},
    OutputEncodeFailed = {},
};

LowerBindingResult := enum {
    Ok = {},
    Unimplemented = {},
    OutputError = {},
    InputError = {},
};

WrapperSourceTarget := enum {
    Missing = {},
    Target = i32,
};

OutputGlobalSlot := {
    name_start = i32,
    name_length = i32,
    ty_tag = i32,
    value_tag = i32,
    value_i32 = i32,
    value_ref = i32,
};

OutputFunctionSlot := {
    name_start = i32,
    name_length = i32,
};

OutputExportSlot := {
    target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputWrapperSlot := {
    source_target_tag = i32,
    wrap_target_tag = i32,
    export_type = i32,
    index = i32,
    name_start = i32,
    name_length = i32,
};

OutputInlineBindingSlot := {
    name_start = i32,
    name_length = i32,
    value_tag = i32,
    value_i32 = i32,
    value_ref = i32,
};

OutputValueSlot := {
    kind_tag = i32,
    value_i32 = i32,
    name_start = i32,
    name_length = i32,
    item_start = i32,
    item_count = i32,
};

OutputValueFieldSlot := {
    name_start = i32,
    name_length = i32,
    value_ref = i32,
};

EMPTY_OUTPUT_GLOBAL_SLOT := {
    name_start = 0,
    name_length = 0,
    ty_tag = 0,
    value_tag = 0,
    value_i32 = 0,
    value_ref = -1,
};

EMPTY_OUTPUT_FUNCTION_SLOT := {
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_EXPORT_SLOT := {
    target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_WRAPPER_SLOT := {
    source_target_tag = 0,
    wrap_target_tag = 0,
    export_type = 0,
    index = 0,
    name_start = 0,
    name_length = 0,
};

EMPTY_OUTPUT_INLINE_BINDING_SLOT := {
    name_start = 0,
    name_length = 0,
    value_tag = VALUE_TAG_UNKNOWN,
    value_i32 = 0,
    value_ref = -1,
};

EMPTY_OUTPUT_VALUE_SLOT := {
    kind_tag = OUTPUT_VALUE_KIND_UNKNOWN,
    value_i32 = 0,
    name_start = 0,
    name_length = 0,
    item_start = 0,
    item_count = 0,
};

EMPTY_OUTPUT_VALUE_FIELD_SLOT := {
    name_start = 0,
    name_length = 0,
    value_ref = -1,
};

lower_status_ok := {} => (
    0
);

lower_status_unimplemented := {} => (
    1
);

lower_status_error := {} => (
    2
);

lower_error_none := {} => (
    0
);

lower_error_input_too_small := {} => (
    1
);

lower_error_bad_magic := {} => (
    2
);

lower_error_bad_version := {} => (
    3
);

lower_error_header_count_mismatch := {} => (
    4
);

lower_error_body_parse_failed := {} => (
    5
);

lower_error_body_count_mismatch := {} => (
    6
);

lower_error_output_encode_failed := {} => (
    7
);

(export wasm) intermediate_payload_version := {} => (
    6
);

(export wasm) intermediate_output_version := {} => (
    9
);

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };

(export wasm) mut output_globals: Box({OutputGlobalSlot; MAX_OUTPUT_GLOBALS}) := {EMPTY_OUTPUT_GLOBAL_SLOT; MAX_OUTPUT_GLOBALS};
(export wasm) mut output_functions: Box({OutputFunctionSlot; MAX_OUTPUT_FUNCTIONS}) := {EMPTY_OUTPUT_FUNCTION_SLOT; MAX_OUTPUT_FUNCTIONS};
(export wasm) mut output_exports: Box({OutputExportSlot; MAX_OUTPUT_EXPORTS}) := {EMPTY_OUTPUT_EXPORT_SLOT; MAX_OUTPUT_EXPORTS};
(export wasm) mut output_wrappers: Box({OutputWrapperSlot; MAX_OUTPUT_WRAPPERS}) := {EMPTY_OUTPUT_WRAPPER_SLOT; MAX_OUTPUT_WRAPPERS};
(export wasm) mut output_inline_bindings: Box({OutputInlineBindingSlot; MAX_OUTPUT_INLINE_BINDINGS}) := {EMPTY_OUTPUT_INLINE_BINDING_SLOT; MAX_OUTPUT_INLINE_BINDINGS};
(export wasm) mut output_values: Box({OutputValueSlot; MAX_OUTPUT_VALUES}) := {EMPTY_OUTPUT_VALUE_SLOT; MAX_OUTPUT_VALUES};
(export wasm) mut output_value_fields: Box({OutputValueFieldSlot; MAX_OUTPUT_VALUE_FIELDS}) := {EMPTY_OUTPUT_VALUE_FIELD_SLOT; MAX_OUTPUT_VALUE_FIELDS};

LowerState := {
    error_code = i32,
    last_scope_count = i32,
    last_binding_count = i32,
    last_input_len = i32,
    input_magic_ok = i32,
    header_version = i32,
    header_scope_count = i32,
    header_binding_count = i32,
    header_annotated_binding_count = i32,
    parsed_binding_count = i32,
    parsed_annotated_binding_count = i32,
    parse_cursor = i32,
    body_ok = i32,
    header_ok = i32,
    output_len = i32,
    output_global_count = i32,
    output_function_count = i32,
    output_export_count = i32,
    output_wrapper_count = i32,
    output_inline_binding_count = i32,
    output_value_count = i32,
    output_value_field_count = i32,
    lowering_unimplemented = i32,
};

(export wasm) mut lower_state: Box(LowerState) := {
    error_code = 0,
    last_scope_count = 0,
    last_binding_count = 0,
    last_input_len = 0,
    input_magic_ok = 0,
    header_version = 0,
    header_scope_count = 0,
    header_binding_count = 0,
    header_annotated_binding_count = 0,
    parsed_binding_count = 0,
    parsed_annotated_binding_count = 0,
    parse_cursor = 0,
    body_ok = 0,
    header_ok = 0,
    output_len = 0,
    output_global_count = 0,
    output_function_count = 0,
    output_export_count = 0,
    output_wrapper_count = 0,
    output_inline_binding_count = 0,
    output_value_count = 0,
    output_value_field_count = 0,
    lowering_unimplemented = 0,
};

AnnotationState := {
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
    first_export_target_tag = i32,
};

BindingExtractState := {
    ok = i32,
    name_start = i32,
    name_length = i32,
    is_mut = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32,
    first_export_target_tag = i32,
    value_type_tag = i32,
};

KnownTypeAliasSlot := {
    name_start = i32,
    name_length = i32,
    value_type_tag = i32,
};

BindingLookupState := {
    type_alias_count = i32,
    scalar_alias_count = i32,
    value_alias_count = i32,
    function_alias_count = i32,
};

ScalarValue := {
    value_tag = i32,
    value_i32 = i32,
    value_type_tag = i32,
};

ScalarValueLookup := enum {
    Missing = {},
    Value = ScalarValue,
    InputError = {},
};

LoweredValueLookup := enum {
    Missing = {},
    Scalar = ScalarValue,
    ValueRef = i32,
    InputError = {},
    OutputError = {},
};

FunctionAliasLookup := enum {
    Missing = {},
    Present = {},
    InputError = {},
};

EMPTY_KNOWN_TYPE_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};

KnownScalarAliasSlot := {
    name_start = i32,
    name_length = i32,
    value_tag = i32,
    value_i32 = i32,
    value_type_tag = i32,
};

EMPTY_KNOWN_SCALAR_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
    value_tag = VALUE_TAG_UNKNOWN,
    value_i32 = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};

KnownValueAliasSlot := {
    name_start = i32,
    name_length = i32,
    value_tag = i32,
    value_i32 = i32,
    value_type_tag = i32,
    value_ref = i32,
};

EMPTY_KNOWN_VALUE_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
    value_tag = VALUE_TAG_UNKNOWN,
    value_i32 = 0,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
    value_ref = -1,
};

KnownFunctionAliasSlot := {
    name_start = i32,
    name_length = i32,
};

EMPTY_KNOWN_FUNCTION_ALIAS_SLOT := {
    name_start = 0,
    name_length = 0,
};

(export wasm) mut annotation_state: Box(AnnotationState) := {
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
    first_export_target_tag = -1,
};
(export wasm) mut binding_extract_state: Box(BindingExtractState) := {
    ok = 0,
    name_start = 0,
    name_length = 0,
    is_mut = 0,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0,
    first_export_target_tag = -1,
    value_type_tag = INPUT_VALUE_TYPE_UNKNOWN,
};
(export wasm) mut binding_lookup_state: Box(BindingLookupState) := {
    type_alias_count = 0,
    scalar_alias_count = 0,
    value_alias_count = 0,
    function_alias_count = 0,
};
(export wasm) mut known_type_aliases: Box({KnownTypeAliasSlot; MAX_KNOWN_TYPE_ALIASES}) := {EMPTY_KNOWN_TYPE_ALIAS_SLOT; MAX_KNOWN_TYPE_ALIASES};
(export wasm) mut known_scalar_aliases: Box({KnownScalarAliasSlot; MAX_KNOWN_SCALAR_ALIASES}) := {EMPTY_KNOWN_SCALAR_ALIAS_SLOT; MAX_KNOWN_SCALAR_ALIASES};
(export wasm) mut known_value_aliases: Box({KnownValueAliasSlot; MAX_KNOWN_VALUE_ALIASES}) := {EMPTY_KNOWN_VALUE_ALIAS_SLOT; MAX_KNOWN_VALUE_ALIASES};
(export wasm) mut known_function_aliases: Box({KnownFunctionAliasSlot; MAX_KNOWN_FUNCTION_ALIASES}) := {EMPTY_KNOWN_FUNCTION_ALIAS_SLOT; MAX_KNOWN_FUNCTION_ALIASES};

(export wasm) intermediate_stage_version := {} => (
    15
);

target_mask_has := {mask: i32, bit: i32} => (
    if bit <= 0 then 0 else (
        q := mask / bit;
        if q - (q / 2) * 2 == 1 then 1 else 0
    )
);

target_mask_or := {left: i32, right: i32} => (
    js := if target_mask_has{left, TARGET_MASK_JS} == 1 || target_mask_has{right, TARGET_MASK_JS} == 1 then TARGET_MASK_JS else 0;
    wasm := if target_mask_has{left, TARGET_MASK_WASM} == 1 || target_mask_has{right, TARGET_MASK_WASM} == 1 then TARGET_MASK_WASM else 0;
    wgsl := if target_mask_has{left, TARGET_MASK_WGSL} == 1 || target_mask_has{right, TARGET_MASK_WGSL} == 1 then TARGET_MASK_WGSL else 0;
    js + wasm + wgsl
);

target_count := (mask: i32) => (
    target_mask_has{mask, TARGET_MASK_JS}
        + target_mask_has{mask, TARGET_MASK_WASM}
        + target_mask_has{mask, TARGET_MASK_WGSL}
);

first_target_tag := (mask: i32) => (
    if target_mask_has{mask, TARGET_MASK_JS} == 1 then OUTPUT_TARGET_JS
    else if target_mask_has{mask, TARGET_MASK_WASM} == 1 then OUTPUT_TARGET_WASM
    else if target_mask_has{mask, TARGET_MASK_WGSL} == 1 then OUTPUT_TARGET_WGSL
    else -1
);

target_mask_from_output_target_tag := (target_tag: i32) => (
    if target_tag == OUTPUT_TARGET_JS then TARGET_MASK_JS
    else if target_tag == OUTPUT_TARGET_WASM then TARGET_MASK_WASM
    else if target_tag == OUTPUT_TARGET_WGSL then TARGET_MASK_WGSL
    else 0
);

string_ref_matches_2 := {value: StringRef, c0: u8, c1: u8} => (
    if value.start < 0 || value.length != 2 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 then 1 else 0
);

string_ref_matches_4 := {value: StringRef, c0: u8, c1: u8, c2: u8, c3: u8} => (
    if value.start < 0 || value.length != 4 then 0
    else if input(value.start) == c0
        && input(value.start + 1) == c1
        && input(value.start + 2) == c2
        && input(value.start + 3) == c3
    then 1 else 0
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'm' && input(value.start + 1) == 'u' && input(value.start + 2) == 't' then 1 else 0
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 'e'
        && input(value.start + 1) == 'x'
        && input(value.start + 2) == 'p'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 6 then 0
    else if input(value.start) == 't'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_wrap := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 4 then 0
    else if input(value.start) == 'w'
        && input(value.start + 1) == 'r'
        && input(value.start + 2) == 'a'
        && input(value.start + 3) == 'p'
    then 1 else 0
);

string_ref_is_asm := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'a' && input(value.start + 1) == 's' && input(value.start + 2) == 'm' then 1 else 0
);

string_ref_is_js := (value: StringRef) => (
    string_ref_matches_2{value, 'j', 's'}
);

string_ref_is_wasm := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'a', 's', 'm'}
);

string_ref_is_wgsl := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'g', 's', 'l'}
);

string_ref_is_u8 := (value: StringRef) => (
    string_ref_matches_2{value, 'u', '8'}
);

string_ref_is_i32 := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 3 then 0
    else if input(value.start) == 'i' && input(value.start + 1) == '3' && input(value.start + 2) == '2' then 1 else 0
);

string_ref_is_boolean_type := (value: StringRef) => (
    if value.start < 0 then 0
    else if value.length != 7 then 0
    else if input(value.start) == 'b'
        && input(value.start + 1) == 'o'
        && input(value.start + 2) == 'o'
        && input(value.start + 3) == 'l'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 'a'
        && input(value.start + 6) == 'n'
    then 1 else 0
);

target_mask_from_target_literal := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TARGET_MASK_JS,
        TargetLiteral::WasmTarget => TARGET_MASK_WASM,
        TargetLiteral::WgslTarget => TARGET_MASK_WGSL,
        else => 0
    }
);

output_target_tag_from_target_literal := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => OUTPUT_TARGET_JS,
        TargetLiteral::WasmTarget => OUTPUT_TARGET_WASM,
        TargetLiteral::WgslTarget => OUTPUT_TARGET_WGSL,
        else => -1
    }
);

target_mask_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_js(id.name) == 1 then TARGET_MASK_JS
                else if string_ref_is_wasm(id.name) == 1 then TARGET_MASK_WASM
                else if string_ref_is_wgsl(id.name) == 1 then TARGET_MASK_WGSL
                else 0
            ),
            NodeKind::Literal(ExpressionLiteral::Target(target)) => target_mask_from_target_literal(target),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Export(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Target(target) => target_mask_from_target_literal(target),
                    BindingAnnotationLiteral::Wrap(target) => target_mask_from_target_literal(target),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

reset_annotation_state := {} => (
    annotation_state.is_mut = 0;
    annotation_state.target_mask = 0;
    annotation_state.export_mask = 0;
    annotation_state.wrap_mask = 0;
    annotation_state.first_export_target_tag = -1;
    1
);

apply_annotation_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if string_ref_is_mut(id.name) == 1 then (
                    annotation_state.is_mut = 1;
                    1
                ) else (
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                target_mask := target_mask_from_expr(info.argument);
                if target_mask == 0 then (
                    0
                ) else if NodeKind::Identifier(id) := nodes(info.function).kind then (
                    if string_ref_is_export(id.name) == 1 then (
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, target_mask};
                        if annotation_state.first_export_target_tag < 0 then (
                            annotation_state.first_export_target_tag = first_target_tag(target_mask);
                        ) else (
                            {}
                        );
                        1
                    ) else if string_ref_is_target(id.name) == 1 then (
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, target_mask};
                        1
                    ) else if string_ref_is_wrap(id.name) == 1 then (
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, target_mask};
                        1
                    ) else (
                        0
                    )
                ) else (
                    0
                )
            ),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => (
                        annotation_state.is_mut = 1;
                        1
                    ),
                    BindingAnnotationLiteral::Export(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.export_mask = target_mask_or{annotation_state.export_mask, ann_mask};
                        if annotation_state.first_export_target_tag < 0 then (
                            annotation_state.first_export_target_tag = first_target_tag(ann_mask);
                        ) else (
                            {}
                        );
                        1
                    ),
                    BindingAnnotationLiteral::Target(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.target_mask = target_mask_or{annotation_state.target_mask, ann_mask};
                        1
                    ),
                    BindingAnnotationLiteral::Wrap(target) => (
                        ann_mask := target_mask_from_target_literal(target);
                        annotation_state.wrap_mask = target_mask_or{annotation_state.wrap_mask, ann_mask};
                        1
                    ),
                    else => 0
                }
            ),
            else => 0
        }
    )
);

apply_annotation_list := (head: i32) => (
    mut current := head;
    mut ok := 1;
    while current != -1 && ok == 1 do (
        ann_idx := list_nodes(current).value;
        if apply_annotation_expr(ann_idx) == 1 then (
            current = list_nodes(current).next;
        ) else (
            ok = 0;
            current = -1;
        );
        {}
    );
    ok
);

reset_binding_extract_state := {} => (
    binding_extract_state.ok = 0;
    binding_extract_state.name_start = 0;
    binding_extract_state.name_length = 0;
    binding_extract_state.is_mut = 0;
    binding_extract_state.target_mask = 0;
    binding_extract_state.export_mask = 0;
    binding_extract_state.wrap_mask = 0;
    binding_extract_state.first_export_target_tag = -1;
    binding_extract_state.value_type_tag = INPUT_VALUE_TYPE_UNKNOWN;
    1
);

set_binding_name := {start: i32, length: i32} => (
    if start < 0 || length < 0 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        binding_extract_state.ok = 1;
        binding_extract_state.name_start = start;
        binding_extract_state.name_length = length;
        1
    )
);

resolve_binding_name_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_extract_state.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => set_binding_name{id.name.start, id.name.length},
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    resolve_binding_name_from_expr(info.left)
                ) else (
                    binding_extract_state.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => resolve_binding_name_from_expr(info.argument),
            else => (
                binding_extract_state.ok = 0;
                0
            )
        }
    )
);

value_type_tag_from_type_expr := {expr_idx: i32, input_len: i32} => (
    resolve_scalar_type_expr{expr_idx, input_len}
);

value_type_tag_from_pattern_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN else (
        nodes(expr_idx).kind |> match {
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == ':' then (
                    value_type_tag_from_type_expr{info.right, input_len}
                ) else (
                    INPUT_VALUE_TYPE_UNKNOWN
                )
            ),
            NodeKind::FunctionCall(info) => value_type_tag_from_pattern_expr{info.argument, input_len},
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

apply_annotation_chain_expr := (node_idx: i32) => (
    if node_idx == -1 then 0
    else if node_idx < 0 || node_idx >= MAX_NODES then 0
    else if NodeKind::FunctionCall(info) := nodes(node_idx).kind then (
        if NodeKind::FunctionCall(_) := nodes(info.function).kind then (
            if apply_annotation_chain_expr(info.function) == 0 then 0 else apply_annotation_expr(info.argument)
        ) else (
            apply_annotation_expr(node_idx)
        )
    ) else 0
);

apply_annotations_from_pattern_expr := (expr_idx: i32) => (
    if expr_idx == -1 then 1
    else if expr_idx < 0 || expr_idx >= MAX_NODES then 0
    else if NodeKind::FunctionCall(info) := nodes(expr_idx).kind then (
        if NodeKind::TypePropertyAccess(_) := nodes(info.function).kind then 1 else apply_annotation_chain_expr(info.function)
    ) else 1
);

resolve_binding_pattern := {pattern: BindingPattern, input_len: i32} => (
    reset_binding_extract_state{};
    pattern |> match {
        BindingPattern::Identifier(info) => (
            set_binding_name{info.name.name.start, info.name.name.length};
            binding_extract_state.ok
        ),
        BindingPattern::TypeHint(info) => (
            if resolve_binding_name_from_expr(info.pattern) == 0 then 0 else if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotations_from_pattern_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.first_export_target_tag =
                    annotation_state.first_export_target_tag;
                binding_extract_state.value_type_tag = value_type_tag_from_type_expr{info.type_expr, input_len};
                binding_extract_state.ok
            )
        ),
        BindingPattern::Annotated(info) => (
            if reset_annotation_state{} == 0 then (
                0
            ) else if apply_annotation_list(info.annotations) == 0 then (
                0
            ) else if resolve_binding_name_from_expr(info.pattern) == 0 then (
                0
            ) else (
                binding_extract_state.is_mut = annotation_state.is_mut;
                binding_extract_state.target_mask = annotation_state.target_mask;
                binding_extract_state.export_mask = annotation_state.export_mask;
                binding_extract_state.wrap_mask = annotation_state.wrap_mask;
                binding_extract_state.first_export_target_tag =
                    annotation_state.first_export_target_tag;
                binding_extract_state.value_type_tag = value_type_tag_from_pattern_expr{info.pattern, input_len};
                binding_extract_state.ok
            )
        ),
        else => (
            binding_extract_state.ok = 0;
            0
        )
    }
);

binding_has_any_annotations := {} => (
    if binding_extract_state.is_mut != 0
        || binding_extract_state.target_mask != 0
        || binding_extract_state.export_mask != 0
        || binding_extract_state.wrap_mask != 0
    then 1 else 0
);

binding_should_materialize := {} => (
    if binding_extract_state.is_mut != 0 || binding_extract_state.export_mask != 0 then 1 else 0
);

safe_name_bounds := {start: i32, length: i32, input_len: i32} => (
    if start < 0 || length < 0 || input_len < 0 then 0
    else if start + length > input_len then 0
    else if start + length > MAX_INPUT then 0
    else 1
);

reset_binding_lookup_state := {} => (
    binding_lookup_state.type_alias_count = 0;
    binding_lookup_state.scalar_alias_count = 0;
    binding_lookup_state.value_alias_count = 0;
    binding_lookup_state.function_alias_count = 0;
    1
);

input_spans_equal := {
    left_start: i32,
    left_length: i32,
    right_start: i32,
    right_length: i32,
    input_len: i32
} => (
    if safe_name_bounds{left_start, left_length, input_len} == 0 then 0
    else if safe_name_bounds{right_start, right_length, input_len} == 0 then 0
    else if left_length != right_length then 0
    else (
        mut idx := 0;
        mut same := 1;
        while idx < left_length && same == 1 do (
            if input(left_start + idx) != input(right_start + idx) then (
                same = 0;
            ) else (
                {}
            );
            idx = idx + 1;
            {}
        );
        same
    )
);

find_known_type_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.type_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_type_aliases(idx).name_start,
            known_type_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_type_alias := {
    name_start: i32,
    name_length: i32,
    value_type_tag: i32,
    input_len: i32
} => (
    existing := find_known_type_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_type_aliases(existing).name_start = name_start;
        known_type_aliases(existing).name_length = name_length;
        known_type_aliases(existing).value_type_tag = value_type_tag;
        1
    ) else (
        idx := binding_lookup_state.type_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_TYPE_ALIASES then 0 else (
            known_type_aliases(idx).name_start = name_start;
            known_type_aliases(idx).name_length = name_length;
            known_type_aliases(idx).value_type_tag = value_type_tag;
            binding_lookup_state.type_alias_count = idx + 1;
            1
        )
    )
);

clear_known_type_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_type_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.type_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.type_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_type_aliases(idx).name_start = known_type_aliases(last).name_start;
                known_type_aliases(idx).name_length = known_type_aliases(last).name_length;
                known_type_aliases(idx).value_type_tag = known_type_aliases(last).value_type_tag;
            ) else (
                {}
            );
            binding_lookup_state.type_alias_count = last;
            1
        )
    )
);

lookup_known_type_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then INPUT_VALUE_TYPE_UNKNOWN
    else (
        idx := find_known_type_alias_index{name_start, name_length, input_len};
        if idx < 0 then INPUT_VALUE_TYPE_UNKNOWN else known_type_aliases(idx).value_type_tag
    )
);

find_known_scalar_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.scalar_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_scalar_aliases(idx).name_start,
            known_scalar_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_scalar_alias := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32,
    value_type_tag: i32,
    input_len: i32
} => (
    existing := find_known_scalar_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_scalar_aliases(existing).name_start = name_start;
        known_scalar_aliases(existing).name_length = name_length;
        known_scalar_aliases(existing).value_tag = value_tag;
        known_scalar_aliases(existing).value_i32 = value_i32;
        known_scalar_aliases(existing).value_type_tag = value_type_tag;
        1
    ) else (
        idx := binding_lookup_state.scalar_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_SCALAR_ALIASES then 0 else (
            known_scalar_aliases(idx).name_start = name_start;
            known_scalar_aliases(idx).name_length = name_length;
            known_scalar_aliases(idx).value_tag = value_tag;
            known_scalar_aliases(idx).value_i32 = value_i32;
            known_scalar_aliases(idx).value_type_tag = value_type_tag;
            binding_lookup_state.scalar_alias_count = idx + 1;
            1
        )
    )
);

clear_known_scalar_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_scalar_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.scalar_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.scalar_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_scalar_aliases(idx).name_start = known_scalar_aliases(last).name_start;
                known_scalar_aliases(idx).name_length = known_scalar_aliases(last).name_length;
                known_scalar_aliases(idx).value_tag = known_scalar_aliases(last).value_tag;
                known_scalar_aliases(idx).value_i32 = known_scalar_aliases(last).value_i32;
                known_scalar_aliases(idx).value_type_tag = known_scalar_aliases(last).value_type_tag;
            ) else (
                {}
            );
            binding_lookup_state.scalar_alias_count = last;
            1
        )
    )
);

lookup_known_scalar_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then ScalarValueLookup::InputError
    else (
        idx := find_known_scalar_alias_index{name_start, name_length, input_len};
        if idx < 0 then (
            ScalarValueLookup::Missing
        ) else (
            ScalarValueLookup::Value({
                value_tag = known_scalar_aliases(idx).value_tag,
                value_i32 = known_scalar_aliases(idx).value_i32,
                value_type_tag = known_scalar_aliases(idx).value_type_tag
            })
        )
    )
);

find_known_value_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.value_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_value_aliases(idx).name_start,
            known_value_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_value_alias := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32,
    value_type_tag: i32,
    value_ref: i32,
    input_len: i32
} => (
    existing := find_known_value_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_value_aliases(existing).name_start = name_start;
        known_value_aliases(existing).name_length = name_length;
        known_value_aliases(existing).value_tag = value_tag;
        known_value_aliases(existing).value_i32 = value_i32;
        known_value_aliases(existing).value_type_tag = value_type_tag;
        known_value_aliases(existing).value_ref = value_ref;
        1
    ) else (
        idx := binding_lookup_state.value_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_VALUE_ALIASES then 0 else (
            known_value_aliases(idx).name_start = name_start;
            known_value_aliases(idx).name_length = name_length;
            known_value_aliases(idx).value_tag = value_tag;
            known_value_aliases(idx).value_i32 = value_i32;
            known_value_aliases(idx).value_type_tag = value_type_tag;
            known_value_aliases(idx).value_ref = value_ref;
            binding_lookup_state.value_alias_count = idx + 1;
            1
        )
    )
);

clear_known_value_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_value_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.value_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.value_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_value_aliases(idx).name_start = known_value_aliases(last).name_start;
                known_value_aliases(idx).name_length = known_value_aliases(last).name_length;
                known_value_aliases(idx).value_tag = known_value_aliases(last).value_tag;
                known_value_aliases(idx).value_i32 = known_value_aliases(last).value_i32;
                known_value_aliases(idx).value_type_tag = known_value_aliases(last).value_type_tag;
                known_value_aliases(idx).value_ref = known_value_aliases(last).value_ref;
            ) else (
                {}
            );
            binding_lookup_state.value_alias_count = last;
            1
        )
    )
);

lookup_known_value_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then LoweredValueLookup::InputError
    else (
        idx := find_known_value_alias_index{name_start, name_length, input_len};
        if idx < 0 then (
            LoweredValueLookup::Missing
        ) else if known_value_aliases(idx).value_ref >= 0 then (
            LoweredValueLookup::ValueRef(known_value_aliases(idx).value_ref)
        ) else if known_value_aliases(idx).value_tag != VALUE_TAG_UNKNOWN then (
            LoweredValueLookup::Scalar({
                value_tag = known_value_aliases(idx).value_tag,
                value_i32 = known_value_aliases(idx).value_i32,
                value_type_tag = known_value_aliases(idx).value_type_tag
            })
        ) else (
            LoweredValueLookup::Missing
        )
    )
);

find_known_function_alias_index := {name_start: i32, name_length: i32, input_len: i32} => (
    mut idx := 0;
    mut found := -1;
    while idx < binding_lookup_state.function_alias_count && found == -1 do (
        if input_spans_equal{
            name_start,
            name_length,
            known_function_aliases(idx).name_start,
            known_function_aliases(idx).name_length,
            input_len
        } == 1 then (
            found = idx;
        ) else (
            {}
        );
        idx = idx + 1;
        {}
    );
    found
);

set_known_function_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    existing := find_known_function_alias_index{name_start, name_length, input_len};
    if existing >= 0 then (
        known_function_aliases(existing).name_start = name_start;
        known_function_aliases(existing).name_length = name_length;
        1
    ) else (
        idx := binding_lookup_state.function_alias_count;
        if idx < 0 || idx >= MAX_KNOWN_FUNCTION_ALIASES then 0 else (
            known_function_aliases(idx).name_start = name_start;
            known_function_aliases(idx).name_length = name_length;
            binding_lookup_state.function_alias_count = idx + 1;
            1
        )
    )
);

clear_known_function_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    idx := find_known_function_alias_index{name_start, name_length, input_len};
    if idx < 0 then (
        1
    ) else (
        last := binding_lookup_state.function_alias_count - 1;
        if last < 0 then (
            binding_lookup_state.function_alias_count = 0;
            1
        ) else (
            if idx != last then (
                known_function_aliases(idx).name_start = known_function_aliases(last).name_start;
                known_function_aliases(idx).name_length = known_function_aliases(last).name_length;
            ) else (
                {}
            );
            binding_lookup_state.function_alias_count = last;
            1
        )
    )
);

lookup_known_function_alias := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then FunctionAliasLookup::InputError
    else (
        idx := find_known_function_alias_index{name_start, name_length, input_len};
        if idx < 0 then FunctionAliasLookup::Missing else FunctionAliasLookup::Present
    )
);

resolve_function_alias_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then FunctionAliasLookup::Missing
    else if expr_idx < 0 || expr_idx >= MAX_NODES then FunctionAliasLookup::InputError
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Function(_) => FunctionAliasLookup::Present,
            NodeKind::Identifier(id) => lookup_known_function_alias{id.name.start, id.name.length, input_len},
            else => FunctionAliasLookup::Missing
        }
    )
);

resolve_scalar_type_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then INPUT_VALUE_TYPE_UNKNOWN
    else if expr_idx < 0 || expr_idx >= MAX_NODES then INPUT_VALUE_TYPE_UNKNOWN
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::IntrinsicType(ty) => (
                ty |> match {
                    IntrinsicType::U8 => INPUT_VALUE_TYPE_U8,
                    IntrinsicType::I32 => INPUT_VALUE_TYPE_I32,
                    IntrinsicType::Boolean => INPUT_VALUE_TYPE_I32,
                    else => INPUT_VALUE_TYPE_UNKNOWN
                }
            ),
            NodeKind::Identifier(id) => (
                if string_ref_is_u8(id.name) == 1 then INPUT_VALUE_TYPE_U8
                else if string_ref_is_i32(id.name) == 1 then INPUT_VALUE_TYPE_I32
                else if string_ref_is_boolean_type(id.name) == 1 then INPUT_VALUE_TYPE_I32
                else lookup_known_type_alias{id.name.start, id.name.length, input_len}
            ),
            NodeKind::AttachImplementation(info) => resolve_scalar_type_expr{info.type_expr, input_len},
            else => INPUT_VALUE_TYPE_UNKNOWN
        }
    )
);

default_scalar_type_tag := (value_tag: i32) => (
    if value_tag == VALUE_TAG_CHAR then INPUT_VALUE_TYPE_U8
    else INPUT_VALUE_TYPE_I32
);

resolve_scalar_value_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then ScalarValueLookup::Missing
    else if expr_idx < 0 || expr_idx >= MAX_NODES then ScalarValueLookup::InputError
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(value) => (
                value |> match {
                    ExpressionLiteral::Number(number) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_NUMBER,
                            value_i32 = number,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Boolean(boolean) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_BOOLEAN,
                            value_i32 = boolean,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Char(ch) => (
                        ScalarValueLookup::Value({
                            value_tag = VALUE_TAG_CHAR,
                            value_i32 = ch,
                            value_type_tag = INPUT_VALUE_TYPE_U8
                        })
                    ),
                    else => ScalarValueLookup::Missing
                }
            ),
            NodeKind::Identifier(id) => lookup_known_scalar_alias{id.name.start, id.name.length, input_len},
            else => ScalarValueLookup::Missing
        }
    )
);

output_value_kind_from_scalar_tag := (value_tag: i32) => (
    if value_tag == VALUE_TAG_NUMBER then OUTPUT_VALUE_KIND_NUMBER
    else if value_tag == VALUE_TAG_BOOLEAN then OUTPUT_VALUE_KIND_BOOLEAN
    else if value_tag == VALUE_TAG_CHAR then OUTPUT_VALUE_KIND_CHAR
    else OUTPUT_VALUE_KIND_UNKNOWN
);

parse_non_negative_i32_span := {start: i32, length: i32, input_len: i32} => (
    if safe_name_bounds{start, length, input_len} == 0 then -1
    else if length <= 0 then -1
    else (
        mut idx := 0;
        mut value := 0;
        mut ok := 1;
        while idx < length && ok == 1 do (
            ch := input(start + idx);
            if ch < 48 || ch > 57 then (
                ok = 0;
            ) else (
                digit := ch - 48;
                value = value * 10 + digit;
            );
            idx = idx + 1;
            {}
        );
        if ok == 1 then value else -1
    )
);

output_target_tag_from_expr := (expr_idx: i32) => (
    mask := target_mask_from_expr(expr_idx);
    if target_count(mask) == 1 then first_target_tag(mask) else -1
);

binary_intrinsic_operator_tag := (operator: BinaryIntrinsicOperator) => (
    operator |> match {
        BinaryIntrinsicOperator::I32Add => 0,
        BinaryIntrinsicOperator::I32Subtract => 1,
        BinaryIntrinsicOperator::I32Multiply => 2,
        BinaryIntrinsicOperator::I32Divide => 3,
        BinaryIntrinsicOperator::I32Equal => 4,
        BinaryIntrinsicOperator::I32NotEqual => 5,
        BinaryIntrinsicOperator::I32LessThan => 6,
        BinaryIntrinsicOperator::I32GreaterThan => 7,
        BinaryIntrinsicOperator::I32LessThanOrEqual => 8,
        BinaryIntrinsicOperator::I32GreaterThanOrEqual => 9,
        BinaryIntrinsicOperator::BooleanAnd => 10,
        BinaryIntrinsicOperator::BooleanOr => 11,
        BinaryIntrinsicOperator::BooleanXor => 12,
        else => -1
    }
);

unary_intrinsic_operator_tag := (operator: UnaryIntrinsicOperator) => (
    operator |> match {
        UnaryIntrinsicOperator::BooleanNot => 0,
        UnaryIntrinsicOperator::EnumFromStruct => 1,
        UnaryIntrinsicOperator::MatchFromStruct => 2,
        UnaryIntrinsicOperator::UseFromString => 3,
        UnaryIntrinsicOperator::BoxFromType => 4,
        UnaryIntrinsicOperator::BindingAnnotationExportFromTarget => 5,
        UnaryIntrinsicOperator::BindingAnnotationTargetFromTarget => 6,
        UnaryIntrinsicOperator::BindingAnnotationWrapFromTarget => 7,
        UnaryIntrinsicOperator::AssemblyFromTarget => 8,
        else => -1
    }
);

binary_intrinsic_operator_tag_from_span := {start: i32, length: i32, input_len: i32} => (
    if safe_name_bounds{start, length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
    else if length == 1 then (
        op := input(start);
        if op == '+' then 0
        else if op == '-' then 1
        else if op == '*' then 2
        else if op == '/' then 3
        else if op == '<' then 6
        else if op == '>' then 7
        else if op == '^' then 12
        else VALUE_REF_LOOKUP_MISSING
    ) else if length == 2 then (
        op0 := input(start);
        op1 := input(start + 1);
        if op0 == '=' && op1 == '=' then 4
        else if op0 == '!' && op1 == '=' then 5
        else if op0 == '<' && op1 == '=' then 8
        else if op0 == '>' && op1 == '=' then 9
        else if op0 == '&' && op1 == '&' then 10
        else if op0 == '|' && op1 == '|' then 11
        else VALUE_REF_LOOKUP_MISSING
    ) else (
        VALUE_REF_LOOKUP_MISSING
    )
);

value_ref_lookup_to_lowered_value := (value_ref_lookup: i32) => (
    if value_ref_lookup == VALUE_REF_LOOKUP_INPUT_ERROR then LoweredValueLookup::InputError
    else if value_ref_lookup == VALUE_REF_LOOKUP_OUTPUT_ERROR then LoweredValueLookup::OutputError
    else if value_ref_lookup == VALUE_REF_LOOKUP_MISSING then LoweredValueLookup::Missing
    else LoweredValueLookup::ValueRef(value_ref_lookup)
);

value_ref_element_type_tag := (value_ref: i32) => (
    if value_ref < 0 || value_ref >= lower_state.output_value_count then INPUT_VALUE_TYPE_UNKNOWN
    else (
        kind_tag := output_values(value_ref).kind_tag;
        if kind_tag == OUTPUT_VALUE_KIND_NUMBER || kind_tag == OUTPUT_VALUE_KIND_BOOLEAN then INPUT_VALUE_TYPE_I32
        else if kind_tag == OUTPUT_VALUE_KIND_CHAR then INPUT_VALUE_TYPE_U8
        else INPUT_VALUE_TYPE_UNKNOWN
    )
);

lookup_value_ref_by_property := {object_ref: i32, property_start: i32, property_length: i32, input_len: i32} => (
    if safe_name_bounds{property_start, property_length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
    else if object_ref < 0 || object_ref >= lower_state.output_value_count then VALUE_REF_LOOKUP_INPUT_ERROR
    else (
        kind_tag := output_values(object_ref).kind_tag;
        if kind_tag != OUTPUT_VALUE_KIND_STRUCT && kind_tag != OUTPUT_VALUE_KIND_ARRAY then VALUE_REF_LOOKUP_MISSING
        else (
            item_start := output_values(object_ref).item_start;
            item_count := output_values(object_ref).item_count;
            if item_start < 0 || item_count < 0 || item_start + item_count > lower_state.output_value_field_count then VALUE_REF_LOOKUP_INPUT_ERROR
            else (
                target_index := parse_non_negative_i32_span{property_start, property_length, input_len};
                mut cursor := item_start;
                mut found_ref := VALUE_REF_LOOKUP_MISSING;
                while cursor < item_start + item_count && found_ref == VALUE_REF_LOOKUP_MISSING do (
                    field_name_start := output_value_fields(cursor).name_start;
                    field_name_length := output_value_fields(cursor).name_length;
                    if field_name_start >= 0 && input_spans_equal{
                        field_name_start,
                        field_name_length,
                        property_start,
                        property_length,
                        input_len
                    } == 1 then (
                        found_ref = output_value_fields(cursor).value_ref;
                    ) else if field_name_start == -1 && target_index >= 0 && field_name_length == target_index then (
                        found_ref = output_value_fields(cursor).value_ref;
                    ) else (
                        {}
                    );
                    cursor = cursor + 1;
                    {}
                );
                if found_ref == VALUE_REF_LOOKUP_MISSING then VALUE_REF_LOOKUP_MISSING
                else if found_ref < 0 || found_ref >= lower_state.output_value_count then VALUE_REF_LOOKUP_INPUT_ERROR
                else found_ref
            )
        )
    )
);

lookup_value_ref_by_index := {array_ref: i32, index: i32, input_len: i32} => (
    if index < 0 then VALUE_REF_LOOKUP_MISSING
    else if array_ref < 0 || array_ref >= lower_state.output_value_count then VALUE_REF_LOOKUP_INPUT_ERROR
    else (
        kind_tag := output_values(array_ref).kind_tag;
        if kind_tag != OUTPUT_VALUE_KIND_STRUCT && kind_tag != OUTPUT_VALUE_KIND_ARRAY then VALUE_REF_LOOKUP_MISSING
        else (
            item_start := output_values(array_ref).item_start;
            item_count := output_values(array_ref).item_count;
            if item_start < 0 || item_count < 0 || item_start + item_count > lower_state.output_value_field_count then VALUE_REF_LOOKUP_INPUT_ERROR
            else if index >= item_count then VALUE_REF_LOOKUP_MISSING
            else (
                field_idx := item_start + index;
                if field_idx < item_start || field_idx >= item_start + item_count then VALUE_REF_LOOKUP_INPUT_ERROR
                else (
                    field_name_start := output_value_fields(field_idx).name_start;
                    field_name_length := output_value_fields(field_idx).name_length;
                    mut name_match := 0;
                    if field_name_start == -1 && field_name_length == index then (
                        name_match = 1;
                    ) else if field_name_start >= 0 then (
                        parsed_idx := parse_non_negative_i32_span{
                            field_name_start,
                            field_name_length,
                            input_len
                        };
                        if parsed_idx == index then (
                            name_match = 1;
                        ) else (
                            {}
                        );
                    ) else (
                        {}
                    );
                    if name_match == 0 then VALUE_REF_LOOKUP_MISSING
                    else (
                        child_ref := output_value_fields(field_idx).value_ref;
                        if child_ref < 0 || child_ref >= lower_state.output_value_count then VALUE_REF_LOOKUP_INPUT_ERROR
                        else child_ref
                    )
                )
            )
        )
    )
);

resolve_lowered_value_index_access := {array_expr_idx: i32, index_expr_idx: i32, input_len: i32} => (
    index_lookup := resolve_scalar_value_expr{index_expr_idx, input_len};
    index_lookup |> match {
        ScalarValueLookup::InputError => LoweredValueLookup::InputError,
        ScalarValueLookup::Missing => LoweredValueLookup::Missing,
        ScalarValueLookup::Value(index_value) => (
            if index_value.value_tag != VALUE_TAG_NUMBER || index_value.value_i32 < 0 then (
                LoweredValueLookup::Missing
            ) else (
                resolve_lowered_value_expr{array_expr_idx, input_len} |> match {
                    LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                    LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                    LoweredValueLookup::Missing => LoweredValueLookup::Missing,
                    LoweredValueLookup::Scalar(value) => LoweredValueLookup::Missing,
                    LoweredValueLookup::ValueRef(array_ref) => (
                        value_ref_lookup_to_lowered_value(
                            lookup_value_ref_by_index{
                                array_ref,
                                index_value.value_i32,
                                input_len
                            }
                        )
                    ),
                    else => LoweredValueLookup::InputError
                }
            )
        ),
        else => LoweredValueLookup::InputError
    }
);

emit_output_value_entry := {
    kind_tag: i32,
    value_i32: i32,
    name_start: i32,
    name_length: i32,
    item_start: i32,
    item_count: i32
} => (
    idx := lower_state.output_value_count;
    if idx < 0 || idx >= MAX_OUTPUT_VALUES then -1 else (
        output_values(idx).kind_tag = kind_tag;
        output_values(idx).value_i32 = value_i32;
        output_values(idx).name_start = name_start;
        output_values(idx).name_length = name_length;
        output_values(idx).item_start = item_start;
        output_values(idx).item_count = item_count;
        lower_state.output_value_count = idx + 1;
        idx
    )
);

emit_output_value_for_scalar := {value_tag: i32, value_i32: i32} => (
    kind_tag := output_value_kind_from_scalar_tag(value_tag);
    if kind_tag == OUTPUT_VALUE_KIND_UNKNOWN then -1 else (
        emit_output_value_entry{
            kind_tag,
            value_i32,
            0,
            0,
            0,
            0
        }
    )
);

resolve_lowered_value_expr_as_ref := {expr_idx: i32, input_len: i32} => (
    resolve_lowered_value_expr{expr_idx, input_len} |> match {
        LoweredValueLookup::Missing => VALUE_REF_LOOKUP_MISSING,
        LoweredValueLookup::InputError => VALUE_REF_LOOKUP_INPUT_ERROR,
        LoweredValueLookup::OutputError => VALUE_REF_LOOKUP_OUTPUT_ERROR,
        LoweredValueLookup::Scalar(value) => (
            value_ref := emit_output_value_for_scalar{value.value_tag, value.value_i32};
            if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
        ),
        LoweredValueLookup::ValueRef(value_ref) => value_ref,
        else => VALUE_REF_LOOKUP_INPUT_ERROR
    }
);

emit_output_value_child_field := {index: i32, value_ref: i32} => (
    field_slot_idx := lower_state.output_value_field_count;
    if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then 0
    else if value_ref < 0 || value_ref >= lower_state.output_value_count then 0
    else (
        output_value_fields(field_slot_idx).name_start = -1;
        output_value_fields(field_slot_idx).name_length = index;
        output_value_fields(field_slot_idx).value_ref = value_ref;
        lower_state.output_value_field_count = field_slot_idx + 1;
        1
    )
);

emit_binary_intrinsic_value := {operator_tag: i32, left_expr_idx: i32, right_expr_idx: i32, input_len: i32} => (
    if operator_tag < 0 then LoweredValueLookup::Missing
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        left_ref := resolve_lowered_value_expr_as_ref{left_expr_idx, input_len};
        if left_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(left_ref)
        ) else (
            right_ref := resolve_lowered_value_expr_as_ref{right_expr_idx, input_len};
            if right_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                value_ref_lookup_to_lowered_value(right_ref)
            ) else if emit_output_value_child_field{0, left_ref} == 0 || emit_output_value_child_field{1, right_ref} == 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                value_ref := emit_output_value_entry{
                    OUTPUT_VALUE_KIND_INTRINSIC_BINARY,
                    operator_tag,
                    0,
                    0,
                    item_start,
                    2
                };
                if value_ref < 0 then (
                    lower_state.output_value_count = checkpoint_value_count;
                    lower_state.output_value_field_count = checkpoint_field_count;
                    LoweredValueLookup::OutputError
                ) else (
                    LoweredValueLookup::ValueRef(value_ref)
                )
            )
        )
    )
);

emit_unary_intrinsic_value := {operator_tag: i32, operand_expr_idx: i32, input_len: i32} => (
    if operator_tag < 0 then LoweredValueLookup::Missing
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        operand_ref := resolve_lowered_value_expr_as_ref{operand_expr_idx, input_len};
        if operand_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(operand_ref)
        ) else if emit_output_value_child_field{0, operand_ref} == 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            value_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_INTRINSIC_UNARY,
                operator_tag,
                0,
                0,
                item_start,
                1
            };
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(value_ref)
            )
        )
    )
);

emit_if_value := {condition_expr_idx: i32, then_expr_idx: i32, else_expr_idx: i32, input_len: i32} => (
    checkpoint_value_count := lower_state.output_value_count;
    checkpoint_field_count := lower_state.output_value_field_count;
    item_start := checkpoint_field_count;
    condition_ref := resolve_lowered_value_expr_as_ref{condition_expr_idx, input_len};
    if condition_ref < 0 then (
        lower_state.output_value_count = checkpoint_value_count;
        lower_state.output_value_field_count = checkpoint_field_count;
        value_ref_lookup_to_lowered_value(condition_ref)
    ) else (
        then_ref := resolve_lowered_value_expr_as_ref{then_expr_idx, input_len};
        if then_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(then_ref)
        ) else (
            else_ref := resolve_lowered_value_expr_as_ref{else_expr_idx, input_len};
            if else_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                value_ref_lookup_to_lowered_value(else_ref)
            ) else if emit_output_value_child_field{0, condition_ref} == 0
                || emit_output_value_child_field{1, then_ref} == 0
                || emit_output_value_child_field{2, else_ref} == 0
            then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                value_ref := emit_output_value_entry{
                    OUTPUT_VALUE_KIND_IF,
                    0,
                    0,
                    0,
                    item_start,
                    3
                };
                if value_ref < 0 then (
                    lower_state.output_value_count = checkpoint_value_count;
                    lower_state.output_value_field_count = checkpoint_field_count;
                    LoweredValueLookup::OutputError
                ) else (
                    LoweredValueLookup::ValueRef(value_ref)
                )
            )
        )
    )
);

emit_identifier_value := {name_start: i32, name_length: i32, input_len: i32} => (
    if name_start < 0 then LoweredValueLookup::Missing
    else if safe_name_bounds{name_start, name_length, input_len} == 0 then LoweredValueLookup::InputError
    else (
        value_ref := emit_output_value_entry{
            OUTPUT_VALUE_KIND_IDENTIFIER,
            0,
            name_start,
            name_length,
            0,
            0
        };
        if value_ref < 0 then LoweredValueLookup::OutputError
        else LoweredValueLookup::ValueRef(value_ref)
    )
);

emit_type_property_access_value := {object_expr_idx: i32, property_start: i32, property_length: i32, input_len: i32} => (
    if property_start < 0 then LoweredValueLookup::Missing
    else if safe_name_bounds{property_start, property_length, input_len} == 0 then LoweredValueLookup::InputError
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        object_ref := resolve_lowered_value_expr_as_ref{object_expr_idx, input_len};
        if object_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(object_ref)
        ) else if emit_output_value_child_field{0, object_ref} == 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            value_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_TYPE_PROPERTY_ACCESS,
                0,
                property_start,
                property_length,
                item_start,
                1
            };
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(value_ref)
            )
        )
    )
);

emit_array_index_value := {array_expr_idx: i32, index_expr_idx: i32, input_len: i32} => (
    checkpoint_value_count := lower_state.output_value_count;
    checkpoint_field_count := lower_state.output_value_field_count;
    item_start := checkpoint_field_count;
    array_ref := resolve_lowered_value_expr_as_ref{array_expr_idx, input_len};
    if array_ref < 0 then (
        lower_state.output_value_count = checkpoint_value_count;
        lower_state.output_value_field_count = checkpoint_field_count;
        value_ref_lookup_to_lowered_value(array_ref)
    ) else (
        index_ref := resolve_lowered_value_expr_as_ref{index_expr_idx, input_len};
        if index_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(index_ref)
        ) else if emit_output_value_child_field{0, array_ref} == 0
            || emit_output_value_child_field{1, index_ref} == 0
        then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            value_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_ARRAY_INDEX,
                0,
                0,
                0,
                item_start,
                2
            };
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(value_ref)
            )
        )
    )
);

emit_block_value := {list_head: i32, list_count: i32, input_len: i32} => (
    if list_count < 0 then LoweredValueLookup::InputError
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        mut idx := 0;
        mut current := list_head;
        mut ok := 1;
        mut result_code := 0;

        while idx < list_count && ok == 1 do (
            if current < 0 || current >= MAX_LIST_NODES then (
                ok = 0;
                result_code = 1;
            ) else (
                node_idx := list_nodes(current).value;
                if node_idx < 0 || node_idx >= MAX_NODES then (
                    ok = 0;
                    result_code = 1;
                ) else (
                    mut child_ref := -1;
                    resolve_lowered_value_expr{node_idx, input_len} |> match {
                        LoweredValueLookup::Missing => (
                            ok = 0;
                            result_code = 0;
                            0
                        ),
                        LoweredValueLookup::Scalar(value) => (
                            child_ref = emit_output_value_for_scalar{
                                value.value_tag,
                                value.value_i32
                            };
                            if child_ref < 0 then (
                                ok = 0;
                                result_code = 2;
                            ) else (
                                {}
                            );
                            0
                        ),
                        LoweredValueLookup::ValueRef(value_ref) => (
                            child_ref = value_ref;
                            0
                        ),
                        LoweredValueLookup::InputError => (
                            ok = 0;
                            result_code = 1;
                            0
                        ),
                        LoweredValueLookup::OutputError => (
                            ok = 0;
                            result_code = 2;
                            0
                        ),
                        else => (
                            ok = 0;
                            result_code = 1;
                            0
                        )
                    };

                    if ok == 1 then (
                        field_slot_idx := lower_state.output_value_field_count;
                        if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then (
                            ok = 0;
                            result_code = 2;
                        ) else (
                            output_value_fields(field_slot_idx).name_start = -1;
                            output_value_fields(field_slot_idx).name_length = idx;
                            output_value_fields(field_slot_idx).value_ref = child_ref;
                            lower_state.output_value_field_count = field_slot_idx + 1;
                            current = list_nodes(current).next;
                            idx = idx + 1;
                        );
                        {}
                    ) else (
                        {}
                    )
                )
            );
            {}
        );

        if ok == 1 && idx != list_count then (
            ok = 0;
            result_code = 1;
        ) else (
            {}
        );

        if ok == 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            if result_code == 1 then LoweredValueLookup::InputError
            else if result_code == 2 then LoweredValueLookup::OutputError
            else LoweredValueLookup::Missing
        ) else (
            value_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_BLOCK,
                0,
                0,
                0,
                item_start,
                list_count
            };
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(value_ref)
            )
        )
    )
);

emit_diverge_value := {value_expr_idx: i32, divergence_tag: i32, input_len: i32} => (
    if divergence_tag < 0 then LoweredValueLookup::Missing
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        value_ref := resolve_lowered_value_expr_as_ref{value_expr_idx, input_len};
        if value_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(value_ref)
        ) else if emit_output_value_child_field{0, value_ref} == 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            result_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_DIVERGE,
                divergence_tag,
                0,
                0,
                item_start,
                1
            };
            if result_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(result_ref)
            )
        )
    )
);

emit_loop_value := {body_expr_idx: i32, input_len: i32} => (
    checkpoint_value_count := lower_state.output_value_count;
    checkpoint_field_count := lower_state.output_value_field_count;
    item_start := checkpoint_field_count;
    body_ref := resolve_lowered_value_expr_as_ref{body_expr_idx, input_len};
    if body_ref < 0 then (
        lower_state.output_value_count = checkpoint_value_count;
        lower_state.output_value_field_count = checkpoint_field_count;
        value_ref_lookup_to_lowered_value(body_ref)
    ) else if emit_output_value_child_field{0, body_ref} == 0 then (
        lower_state.output_value_count = checkpoint_value_count;
        lower_state.output_value_field_count = checkpoint_field_count;
        LoweredValueLookup::OutputError
    ) else (
        value_ref := emit_output_value_entry{
            OUTPUT_VALUE_KIND_LOOP,
            0,
            0,
            0,
            item_start,
            1
        };
        if value_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            LoweredValueLookup::ValueRef(value_ref)
        )
    )
);

emit_inline_assembly_value := {
    target_tag: i32,
    code_start: i32,
    code_length: i32,
    input_len: i32
} => (
    if target_tag < 0 then LoweredValueLookup::Missing
    else if safe_name_bounds{code_start, code_length, input_len} == 0 then LoweredValueLookup::InputError
    else (
        value_ref := emit_output_value_entry{
            OUTPUT_VALUE_KIND_INLINE_ASSEMBLY,
            target_tag,
            code_start,
            code_length,
            0,
            0
        };
        if value_ref < 0 then LoweredValueLookup::OutputError
        else LoweredValueLookup::ValueRef(value_ref)
    )
);

resolve_inline_assembly_call := {
    function_expr_idx: i32,
    code_expr_idx: i32,
    input_len: i32
} => (
    if function_expr_idx < 0 || function_expr_idx >= MAX_NODES then LoweredValueLookup::InputError
    else if NodeKind::FunctionCall(inner) := nodes(function_expr_idx).kind then (
        if inner.function < 0 || inner.function >= MAX_NODES then LoweredValueLookup::InputError
        else if NodeKind::Identifier(id) := nodes(inner.function).kind then (
            if string_ref_is_asm(id.name) == 0 then LoweredValueLookup::Missing
            else (
                target_tag := output_target_tag_from_expr(inner.argument);
                if target_tag < 0 then LoweredValueLookup::Missing
                else if code_expr_idx < 0 || code_expr_idx >= MAX_NODES then LoweredValueLookup::InputError
                else (
                    nodes(code_expr_idx).kind |> match {
                        NodeKind::Literal(ExpressionLiteral::String(code_ref)) => (
                            emit_inline_assembly_value{
                                target_tag,
                                code_ref.start,
                                code_ref.length,
                                input_len
                            }
                        ),
                        else => LoweredValueLookup::Missing
                    }
                )
            )
        ) else (
            LoweredValueLookup::Missing
        )
    ) else (
        LoweredValueLookup::Missing
    )
);

emit_lvalue_target_object_expr_ref := {expr_idx: i32, input_len: i32} => (
    if expr_idx < 0 || expr_idx >= MAX_NODES then VALUE_REF_LOOKUP_INPUT_ERROR
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                if safe_name_bounds{id.name.start, id.name.length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
                else (
                    value_ref := emit_output_value_entry{
                        OUTPUT_VALUE_KIND_IDENTIFIER,
                        0,
                        id.name.start,
                        id.name.length,
                        0,
                        0
                    };
                    if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                )
            ),
            NodeKind::TypePropertyAccess(info) => (
                if safe_name_bounds{info.property.start, info.property.length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
                else (
                    item_start := lower_state.output_value_field_count;
                    object_ref := emit_lvalue_target_object_expr_ref{info.object, input_len};
                    if object_ref < 0 then (
                        object_ref
                    ) else if emit_output_value_child_field{0, object_ref} == 0 then (
                        VALUE_REF_LOOKUP_OUTPUT_ERROR
                    ) else (
                        value_ref := emit_output_value_entry{
                            OUTPUT_VALUE_KIND_TYPE_PROPERTY_ACCESS,
                            0,
                            info.property.start,
                            info.property.length,
                            item_start,
                            1
                        };
                        if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                    )
                )
            ),
            NodeKind::ArrayIndex(info) => (
                item_start := lower_state.output_value_field_count;
                array_ref := emit_lvalue_target_object_expr_ref{info.array, input_len};
                if array_ref < 0 then (
                    array_ref
                ) else (
                    index_ref := resolve_lowered_value_expr_as_ref{info.index, input_len};
                    if index_ref < 0 then (
                        index_ref
                    ) else if emit_output_value_child_field{0, array_ref} == 0
                        || emit_output_value_child_field{1, index_ref} == 0
                    then (
                        VALUE_REF_LOOKUP_OUTPUT_ERROR
                    ) else (
                        value_ref := emit_output_value_entry{
                            OUTPUT_VALUE_KIND_ARRAY_INDEX,
                            0,
                            0,
                            0,
                            item_start,
                            2
                        };
                        if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                    )
                )
            ),
            else => VALUE_REF_LOOKUP_MISSING
        }
    )
);

emit_assignment_value := {assignment_expr_idx: i32, input_len: i32} => (
    if assignment_expr_idx < 0 || assignment_expr_idx >= MAX_NODES then LoweredValueLookup::InputError
    else if NodeKind::Assignment(info) := nodes(assignment_expr_idx).kind then (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        target_ref := info.target |> match {
            LValue::Identifier(target_info) => (
                if safe_name_bounds{target_info.name.name.start, target_info.name.name.length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
                else (
                    value_ref := emit_output_value_entry{
                        OUTPUT_VALUE_KIND_IDENTIFIER,
                        0,
                        target_info.name.name.start,
                        target_info.name.name.length,
                        0,
                        0
                    };
                    if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                )
            ),
            LValue::TypePropertyAccess(target_info) => (
                if safe_name_bounds{target_info.property.start, target_info.property.length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
                else (
                    target_item_start := lower_state.output_value_field_count;
                    object_ref := emit_lvalue_target_object_expr_ref{target_info.object, input_len};
                    if object_ref < 0 then (
                        object_ref
                    ) else if emit_output_value_child_field{0, object_ref} == 0 then (
                        VALUE_REF_LOOKUP_OUTPUT_ERROR
                    ) else (
                        value_ref := emit_output_value_entry{
                            OUTPUT_VALUE_KIND_TYPE_PROPERTY_ACCESS,
                            0,
                            target_info.property.start,
                            target_info.property.length,
                            target_item_start,
                            1
                        };
                        if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                    )
                )
            ),
            LValue::ArrayIndex(target_info) => (
                target_item_start := lower_state.output_value_field_count;
                array_ref := emit_lvalue_target_object_expr_ref{target_info.array, input_len};
                if array_ref < 0 then (
                    array_ref
                ) else (
                    index_ref := resolve_lowered_value_expr_as_ref{target_info.index, input_len};
                    if index_ref < 0 then (
                        index_ref
                    ) else if emit_output_value_child_field{0, array_ref} == 0
                        || emit_output_value_child_field{1, index_ref} == 0
                    then (
                        VALUE_REF_LOOKUP_OUTPUT_ERROR
                    ) else (
                        value_ref := emit_output_value_entry{
                            OUTPUT_VALUE_KIND_ARRAY_INDEX,
                            0,
                            0,
                            0,
                            target_item_start,
                            2
                        };
                        if value_ref < 0 then VALUE_REF_LOOKUP_OUTPUT_ERROR else value_ref
                    )
                )
            ),
            else => VALUE_REF_LOOKUP_MISSING
        };
        if target_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(target_ref)
        ) else (
            value_ref := resolve_lowered_value_expr_as_ref{info.expr, input_len};
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                value_ref_lookup_to_lowered_value(value_ref)
            ) else if emit_output_value_child_field{0, target_ref} == 0
                || emit_output_value_child_field{1, value_ref} == 0
            then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                assignment_ref := emit_output_value_entry{
                    OUTPUT_VALUE_KIND_ASSIGNMENT,
                    0,
                    0,
                    0,
                    item_start,
                    2
                };
                if assignment_ref < 0 then (
                    lower_state.output_value_count = checkpoint_value_count;
                    lower_state.output_value_field_count = checkpoint_field_count;
                    LoweredValueLookup::OutputError
                ) else (
                    LoweredValueLookup::ValueRef(assignment_ref)
                )
            )
        )
    ) else (
        LoweredValueLookup::InputError
    )
);

emit_binding_value := {binding_expr_idx: i32, input_len: i32} => (
    if binding_expr_idx < 0 || binding_expr_idx >= MAX_NODES then LoweredValueLookup::InputError
    else if NodeKind::Binding(binding) := nodes(binding_expr_idx).kind then (
        if resolve_binding_pattern{binding.pattern, input_len} == 0 then (
            LoweredValueLookup::Missing
        ) else if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then (
            LoweredValueLookup::InputError
        ) else (
            checkpoint_value_count := lower_state.output_value_count;
            checkpoint_field_count := lower_state.output_value_field_count;
            item_start := checkpoint_field_count;
            value_ref := resolve_lowered_value_expr_as_ref{binding.expr, input_len};
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                value_ref_lookup_to_lowered_value(value_ref)
            ) else if emit_output_value_child_field{0, value_ref} == 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                mut binding_type_tag := if binding_extract_state.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then binding_extract_state.value_type_tag
                    else value_ref_element_type_tag(value_ref);
                if binding_type_tag != INPUT_VALUE_TYPE_I32 && binding_type_tag != INPUT_VALUE_TYPE_U8 then (
                    binding_type_tag = INPUT_VALUE_TYPE_UNKNOWN;
                ) else (
                    {}
                );
                binding_ref := emit_output_value_entry{
                    OUTPUT_VALUE_KIND_BINDING,
                    binding_type_tag,
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    item_start,
                    1
                };
                if binding_ref < 0 then (
                    lower_state.output_value_count = checkpoint_value_count;
                    lower_state.output_value_field_count = checkpoint_field_count;
                    LoweredValueLookup::OutputError
                ) else (
                    LoweredValueLookup::ValueRef(binding_ref)
                )
            )
        )
    ) else (
        LoweredValueLookup::InputError
    )
);

find_output_function_index_by_name := {name_start: i32, name_length: i32, input_len: i32} => (
    if safe_name_bounds{name_start, name_length, input_len} == 0 then VALUE_REF_LOOKUP_INPUT_ERROR
    else (
        mut idx := 0;
        mut found := -1;
        while idx < lower_state.output_function_count && found == -1 do (
            if input_spans_equal{
                name_start,
                name_length,
                output_functions(idx).name_start,
                output_functions(idx).name_length,
                input_len
            } == 1 then (
                found = idx;
            ) else (
                {}
            );
            idx = idx + 1;
            {}
        );
        found
    )
);

resolve_output_function_index_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx < 0 || expr_idx >= MAX_NODES then VALUE_REF_LOOKUP_INPUT_ERROR
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => find_output_function_index_by_name{
                id.name.start,
                id.name.length,
                input_len
            },
            else => VALUE_REF_LOOKUP_MISSING
        }
    )
);

emit_function_call_value := {function_index: i32, argument_expr_idx: i32, input_len: i32} => (
    if function_index < 0 then LoweredValueLookup::Missing
    else (
        checkpoint_value_count := lower_state.output_value_count;
        checkpoint_field_count := lower_state.output_value_field_count;
        item_start := checkpoint_field_count;
        argument_ref := resolve_lowered_value_expr_as_ref{argument_expr_idx, input_len};
        if argument_ref < 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            value_ref_lookup_to_lowered_value(argument_ref)
        ) else if emit_output_value_child_field{0, argument_ref} == 0 then (
            lower_state.output_value_count = checkpoint_value_count;
            lower_state.output_value_field_count = checkpoint_field_count;
            LoweredValueLookup::OutputError
        ) else (
            value_ref := emit_output_value_entry{
                OUTPUT_VALUE_KIND_FUNCTION_CALL,
                function_index,
                0,
                0,
                item_start,
                1
            };
            if value_ref < 0 then (
                lower_state.output_value_count = checkpoint_value_count;
                lower_state.output_value_field_count = checkpoint_field_count;
                LoweredValueLookup::OutputError
            ) else (
                LoweredValueLookup::ValueRef(value_ref)
            )
        )
    )
);

resolve_lowered_value_expr := {expr_idx: i32, input_len: i32} => (
    if expr_idx == -1 then LoweredValueLookup::Missing
    else if expr_idx < 0 || expr_idx >= MAX_NODES then LoweredValueLookup::InputError
    else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(value) => (
                value |> match {
                    ExpressionLiteral::Number(number) => (
                        LoweredValueLookup::Scalar({
                            value_tag = VALUE_TAG_NUMBER,
                            value_i32 = number,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Boolean(boolean) => (
                        LoweredValueLookup::Scalar({
                            value_tag = VALUE_TAG_BOOLEAN,
                            value_i32 = boolean,
                            value_type_tag = INPUT_VALUE_TYPE_I32
                        })
                    ),
                    ExpressionLiteral::Char(ch) => (
                        LoweredValueLookup::Scalar({
                            value_tag = VALUE_TAG_CHAR,
                            value_i32 = ch,
                            value_type_tag = INPUT_VALUE_TYPE_U8
                        })
                    ),
                    ExpressionLiteral::String(value) => (
                        if safe_name_bounds{value.start, value.length, input_len} == 0 then (
                            LoweredValueLookup::InputError
                        ) else (
                            checkpoint_value_count := lower_state.output_value_count;
                            checkpoint_field_count := lower_state.output_value_field_count;
                            item_start := checkpoint_field_count;
                            mut idx := 0;
                            mut ok := 1;

                            while idx < value.length && ok == 1 do (
                                byte_value := input(value.start + idx) - 0;
                                child_ref := emit_output_value_entry{
                                    OUTPUT_VALUE_KIND_CHAR,
                                    byte_value,
                                    0,
                                    0,
                                    0,
                                    0
                                };
                                if child_ref < 0 then (
                                    ok = 0;
                                ) else (
                                    field_slot_idx := lower_state.output_value_field_count;
                                    if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then (
                                        ok = 0;
                                    ) else (
                                        output_value_fields(field_slot_idx).name_start = -1;
                                        output_value_fields(field_slot_idx).name_length = idx;
                                        output_value_fields(field_slot_idx).value_ref = child_ref;
                                        lower_state.output_value_field_count = field_slot_idx + 1;
                                    )
                                );
                                idx = idx + 1;
                                {}
                            );

                            if ok == 0 then (
                                lower_state.output_value_count = checkpoint_value_count;
                                lower_state.output_value_field_count = checkpoint_field_count;
                                LoweredValueLookup::OutputError
                            ) else (
                                value_ref := emit_output_value_entry{
                                    OUTPUT_VALUE_KIND_ARRAY,
                                    INPUT_VALUE_TYPE_U8,
                                    0,
                                    0,
                                    item_start,
                                    value.length
                                };
                                if value_ref < 0 then (
                                    lower_state.output_value_count = checkpoint_value_count;
                                    lower_state.output_value_field_count = checkpoint_field_count;
                                    LoweredValueLookup::OutputError
                                ) else (
                                    LoweredValueLookup::ValueRef(value_ref)
                                )
                            )
                        )
                    ),
                    else => LoweredValueLookup::Missing
                }
            ),
            NodeKind::Identifier(id) => (
                value_lookup := lookup_known_value_alias{id.name.start, id.name.length, input_len};
                value_lookup |> match {
                    LoweredValueLookup::Missing => (
                        scalar_lookup := lookup_known_scalar_alias{id.name.start, id.name.length, input_len};
                        scalar_lookup |> match {
                            ScalarValueLookup::Missing => emit_identifier_value{
                                id.name.start,
                                id.name.length,
                                input_len
                            },
                            ScalarValueLookup::Value(value) => LoweredValueLookup::Scalar(value),
                            ScalarValueLookup::InputError => LoweredValueLookup::InputError,
                            else => LoweredValueLookup::InputError
                        }
                    ),
                    LoweredValueLookup::Scalar(value) => LoweredValueLookup::Scalar(value),
                    LoweredValueLookup::ValueRef(value_ref) => LoweredValueLookup::ValueRef(value_ref),
                    LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                    LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                    else => LoweredValueLookup::InputError
                }
            ),
            NodeKind::IntrinsicOperation(intrinsic) => (
                intrinsic |> match {
                    IntrinsicOperation::Binary(info) => (
                        operator_tag := binary_intrinsic_operator_tag(info.operator);
                        emit_binary_intrinsic_value{
                            operator_tag,
                            info.left,
                            info.right,
                            input_len
                        }
                    ),
                    IntrinsicOperation::Unary(info) => (
                        operator_tag := unary_intrinsic_operator_tag(info.operator);
                        emit_unary_intrinsic_value{
                            operator_tag,
                            info.operand,
                            input_len
                        }
                    ),
                    IntrinsicOperation::InlineAssembly(info) => (
                        if info.code < 0 || info.code >= MAX_NODES then (
                            LoweredValueLookup::InputError
                        ) else (
                            nodes(info.code).kind |> match {
                                NodeKind::Literal(ExpressionLiteral::String(code_ref)) => (
                                    target_tag := output_target_tag_from_target_literal(info.target);
                                    emit_inline_assembly_value{
                                        target_tag,
                                        code_ref.start,
                                        code_ref.length,
                                        input_len
                                    }
                                ),
                                else => LoweredValueLookup::Missing
                            }
                        )
                    ),
                    else => LoweredValueLookup::Missing
                }
            ),
            NodeKind::If(info) => (
                emit_if_value{
                    info.condition,
                    info.then_branch,
                    info.else_branch,
                    input_len
                }
            ),
            NodeKind::Operation(info) => (
                if info.operator.length == 1 && info.operator.start >= 0 && input(info.operator.start) == '.' then (
                    if info.left < 0 || info.left >= MAX_NODES || info.right < 0 || info.right >= MAX_NODES then (
                        LoweredValueLookup::InputError
                    ) else if NodeKind::Identifier(property_id) := nodes(info.right).kind then (
                        resolve_lowered_value_expr{info.left, input_len} |> match {
                            LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                            LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                            LoweredValueLookup::Missing => LoweredValueLookup::Missing,
                            LoweredValueLookup::Scalar(value) => LoweredValueLookup::Missing,
                            LoweredValueLookup::ValueRef(object_ref) => (
                                property_lookup := lookup_value_ref_by_property{
                                    object_ref,
                                    property_id.name.start,
                                    property_id.name.length,
                                    input_len
                                };
                                if property_lookup == VALUE_REF_LOOKUP_MISSING then (
                                    emit_type_property_access_value{
                                        info.left,
                                        property_id.name.start,
                                        property_id.name.length,
                                        input_len
                                    }
                                ) else (
                                    value_ref_lookup_to_lowered_value(property_lookup)
                                )
                            ),
                            else => LoweredValueLookup::InputError
                        }
                    ) else (
                        LoweredValueLookup::Missing
                    )
                ) else (
                    operator_tag_lookup := binary_intrinsic_operator_tag_from_span{
                        info.operator.start,
                        info.operator.length,
                        input_len
                    };
                    if operator_tag_lookup == VALUE_REF_LOOKUP_INPUT_ERROR then LoweredValueLookup::InputError
                    else if operator_tag_lookup < 0 then LoweredValueLookup::Missing
                    else (
                        emit_binary_intrinsic_value{
                            operator_tag_lookup,
                            info.left,
                            info.right,
                            input_len
                        }
                    )
                )
            ),
            NodeKind::FunctionCall(info) => (
                if info.function < 0 || info.function >= MAX_NODES then (
                    LoweredValueLookup::InputError
                ) else (
                    inline_asm_lookup := resolve_inline_assembly_call{
                        info.function,
                        info.argument,
                        input_len
                    };
                    inline_asm_lookup |> match {
                        LoweredValueLookup::Missing => (
                            function_index := resolve_output_function_index_expr{info.function, input_len};
                            if function_index == VALUE_REF_LOOKUP_INPUT_ERROR then (
                                LoweredValueLookup::InputError
                            ) else if function_index >= 0 then (
                                emit_function_call_value{function_index, info.argument, input_len}
                            ) else if NodeKind::TypePropertyAccess(access_info) := nodes(info.function).kind then (
                                if info.argument != access_info.object then (
                                    index_lookup := resolve_lowered_value_index_access{
                                        info.function,
                                        info.argument,
                                        input_len
                                    };
                                    index_lookup |> match {
                                        LoweredValueLookup::Missing => emit_array_index_value{
                                            info.function,
                                            info.argument,
                                            input_len
                                        },
                                        else => index_lookup
                                    }
                                ) else if safe_name_bounds{access_info.property.start, access_info.property.length, input_len} == 0 then (
                                    LoweredValueLookup::InputError
                                ) else (
                                    resolve_lowered_value_expr{access_info.object, input_len} |> match {
                                        LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                                        LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                                        LoweredValueLookup::Missing => LoweredValueLookup::Missing,
                                        LoweredValueLookup::Scalar(value) => LoweredValueLookup::Missing,
                                        LoweredValueLookup::ValueRef(object_ref) => (
                                            property_lookup := lookup_value_ref_by_property{
                                                object_ref,
                                                access_info.property.start,
                                                access_info.property.length,
                                                input_len
                                            };
                                            if property_lookup == VALUE_REF_LOOKUP_MISSING then (
                                                emit_type_property_access_value{
                                                    access_info.object,
                                                    access_info.property.start,
                                                    access_info.property.length,
                                                    input_len
                                                }
                                            ) else (
                                                value_ref_lookup_to_lowered_value(property_lookup)
                                            )
                                        ),
                                        else => LoweredValueLookup::InputError
                                    }
                                )
                            ) else (
                                index_lookup := resolve_lowered_value_index_access{
                                    info.function,
                                    info.argument,
                                    input_len
                                };
                                index_lookup |> match {
                                    LoweredValueLookup::Missing => emit_array_index_value{
                                        info.function,
                                        info.argument,
                                        input_len
                                    },
                                    else => index_lookup
                                }
                            )
                        ),
                        else => inline_asm_lookup
                    }
                )
            ),
            NodeKind::Struct(info) => (
                checkpoint_value_count := lower_state.output_value_count;
                checkpoint_field_count := lower_state.output_value_field_count;
                item_start := checkpoint_field_count;
                mut item_count := 0;
                mut current := info.fields;
                mut ok := 1;
                mut result_code := 0;

                while current != -1 && ok == 1 do (
                    if current < 0 || current >= MAX_LIST_NODES then (
                        ok = 0;
                        result_code = 1;
                    ) else (
                        field_node := list_nodes(current).value;
                        if field_node < 0 || field_node >= MAX_NODES then (
                            ok = 0;
                            result_code = 1;
                        ) else if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                            mut child_ref := -1;
                            resolve_lowered_value_expr{field_binding.expr, input_len} |> match {
                                LoweredValueLookup::Missing => (
                                    ok = 0;
                                    result_code = 0;
                                    0
                                ),
                                LoweredValueLookup::Scalar(value) => (
                                    child_ref = emit_output_value_for_scalar{
                                        value.value_tag,
                                        value.value_i32
                                    };
                                    if child_ref < 0 then (
                                        ok = 0;
                                        result_code = 2;
                                    ) else (
                                        {}
                                    );
                                    0
                                ),
                                LoweredValueLookup::ValueRef(value_ref) => (
                                    child_ref = value_ref;
                                    0
                                ),
                                LoweredValueLookup::InputError => (
                                    ok = 0;
                                    result_code = 1;
                                    0
                                ),
                                LoweredValueLookup::OutputError => (
                                    ok = 0;
                                    result_code = 2;
                                    0
                                ),
                                else => (
                                    ok = 0;
                                    result_code = 1;
                                    0
                                )
                            };

                            mut field_name_start := -1;
                            mut field_name_length := item_count;
                            if ok == 1 then (
                                if BindingPattern::Identifier(field_pattern_info) := field_binding.pattern then (
                                    if field_pattern_info.name.name.start >= 0 && field_pattern_info.name.name.length > 0 then (
                                        field_name_start = field_pattern_info.name.name.start;
                                        field_name_length = field_pattern_info.name.name.length;
                                    ) else (
                                        {}
                                    );
                                ) else (
                                    ok = 0;
                                    result_code = 0;
                                );
                                {}
                            ) else (
                                {}
                            );

                            if ok == 1 then (
                                field_slot_idx := lower_state.output_value_field_count;
                                if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then (
                                    ok = 0;
                                    result_code = 2;
                                ) else (
                                    output_value_fields(field_slot_idx).name_start = field_name_start;
                                    output_value_fields(field_slot_idx).name_length = field_name_length;
                                    output_value_fields(field_slot_idx).value_ref = child_ref;
                                    lower_state.output_value_field_count = field_slot_idx + 1;
                                    item_count = item_count + 1;
                                    current = list_nodes(current).next;
                                );
                                {}
                            ) else (
                                {}
                            )
                        ) else (
                            ok = 0;
                            result_code = 0;
                        )
                    );
                    {}
                );

                if ok == 0 then (
                    lower_state.output_value_count = checkpoint_value_count;
                    lower_state.output_value_field_count = checkpoint_field_count;
                    if result_code == 1 then LoweredValueLookup::InputError
                    else if result_code == 2 then LoweredValueLookup::OutputError
                    else LoweredValueLookup::Missing
                ) else (
                    value_ref := emit_output_value_entry{
                        OUTPUT_VALUE_KIND_STRUCT,
                        0,
                        0,
                        0,
                        item_start,
                        item_count
                    };
                    if value_ref < 0 then (
                        lower_state.output_value_count = checkpoint_value_count;
                        lower_state.output_value_field_count = checkpoint_field_count;
                        LoweredValueLookup::OutputError
                    ) else (
                        LoweredValueLookup::ValueRef(value_ref)
                    )
                )
            ),
            NodeKind::ArrayRepeat(info) => (
                count_lookup := resolve_scalar_value_expr{info.count, input_len};
                count_lookup |> match {
                    ScalarValueLookup::InputError => LoweredValueLookup::InputError,
                    ScalarValueLookup::Missing => LoweredValueLookup::Missing,
                    ScalarValueLookup::Value(count_value) => (
                        if count_value.value_tag != VALUE_TAG_NUMBER || count_value.value_i32 < 0 then (
                            LoweredValueLookup::Missing
                        ) else (
                            repeat_count := count_value.value_i32;
                            resolve_lowered_value_expr{info.value, input_len} |> match {
                                LoweredValueLookup::Missing => LoweredValueLookup::Missing,
                                LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                                LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                                LoweredValueLookup::Scalar(value) => (
                                    element_type_tag := if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                                        else default_scalar_type_tag(value.value_tag);
                                    checkpoint_value_count := lower_state.output_value_count;
                                    checkpoint_field_count := lower_state.output_value_field_count;
                                    item_start := checkpoint_field_count;
                                    mut idx := 0;
                                    mut ok := 1;
                                    mut child_ref := -1;

                                    if repeat_count > 0 then (
                                        child_ref = emit_output_value_for_scalar{
                                            value.value_tag,
                                            value.value_i32
                                        };
                                        if child_ref < 0 then (
                                            ok = 0;
                                        ) else (
                                            {}
                                        );
                                    ) else (
                                        {}
                                    );

                                    while idx < repeat_count && ok == 1 do (
                                        field_slot_idx := lower_state.output_value_field_count;
                                        if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then (
                                            ok = 0;
                                        ) else (
                                            output_value_fields(field_slot_idx).name_start = -1;
                                            output_value_fields(field_slot_idx).name_length = idx;
                                            output_value_fields(field_slot_idx).value_ref = child_ref;
                                            lower_state.output_value_field_count = field_slot_idx + 1;
                                        );
                                        idx = idx + 1;
                                        {}
                                    );

                                    if ok == 0 then (
                                        lower_state.output_value_count = checkpoint_value_count;
                                        lower_state.output_value_field_count = checkpoint_field_count;
                                        LoweredValueLookup::OutputError
                                    ) else (
                                        value_ref := emit_output_value_entry{
                                            OUTPUT_VALUE_KIND_ARRAY,
                                            element_type_tag,
                                            0,
                                            0,
                                            item_start,
                                            repeat_count
                                        };
                                        if value_ref < 0 then (
                                            lower_state.output_value_count = checkpoint_value_count;
                                            lower_state.output_value_field_count = checkpoint_field_count;
                                            LoweredValueLookup::OutputError
                                        ) else (
                                            LoweredValueLookup::ValueRef(value_ref)
                                        )
                                    )
                                ),
                                LoweredValueLookup::ValueRef(item_value_ref) => (
                                    element_type_tag := value_ref_element_type_tag(item_value_ref);
                                    if repeat_count == 0 && element_type_tag == INPUT_VALUE_TYPE_UNKNOWN then (
                                        LoweredValueLookup::Missing
                                    ) else (
                                        checkpoint_value_count := lower_state.output_value_count;
                                        checkpoint_field_count := lower_state.output_value_field_count;
                                        item_start := checkpoint_field_count;
                                        mut idx := 0;
                                        mut ok := 1;

                                        while idx < repeat_count && ok == 1 do (
                                            field_slot_idx := lower_state.output_value_field_count;
                                            if field_slot_idx < 0 || field_slot_idx >= MAX_OUTPUT_VALUE_FIELDS then (
                                                ok = 0;
                                            ) else (
                                                output_value_fields(field_slot_idx).name_start = -1;
                                                output_value_fields(field_slot_idx).name_length = idx;
                                                output_value_fields(field_slot_idx).value_ref = item_value_ref;
                                                lower_state.output_value_field_count = field_slot_idx + 1;
                                            );
                                            idx = idx + 1;
                                            {}
                                        );

                                        if ok == 0 then (
                                            lower_state.output_value_count = checkpoint_value_count;
                                            lower_state.output_value_field_count = checkpoint_field_count;
                                            LoweredValueLookup::OutputError
                                        ) else (
                                            value_ref := emit_output_value_entry{
                                                OUTPUT_VALUE_KIND_ARRAY,
                                                element_type_tag,
                                                0,
                                                0,
                                                item_start,
                                                repeat_count
                                            };
                                            if value_ref < 0 then (
                                                lower_state.output_value_count = checkpoint_value_count;
                                                lower_state.output_value_field_count = checkpoint_field_count;
                                                LoweredValueLookup::OutputError
                                            ) else (
                                                LoweredValueLookup::ValueRef(value_ref)
                                            )
                                        )
                                    )
                                ),
                                else => LoweredValueLookup::InputError
                            }
                        )
                    ),
                    else => LoweredValueLookup::InputError
                }
            ),
            NodeKind::TypePropertyAccess(info) => (
                if safe_name_bounds{info.property.start, info.property.length, input_len} == 0 then LoweredValueLookup::InputError
                else (
                    resolve_lowered_value_expr{info.object, input_len} |> match {
                        LoweredValueLookup::InputError => LoweredValueLookup::InputError,
                        LoweredValueLookup::OutputError => LoweredValueLookup::OutputError,
                        LoweredValueLookup::Missing => LoweredValueLookup::Missing,
                        LoweredValueLookup::Scalar(value) => LoweredValueLookup::Missing,
                        LoweredValueLookup::ValueRef(object_ref) => (
                            property_lookup := lookup_value_ref_by_property{
                                object_ref,
                                info.property.start,
                                info.property.length,
                                input_len
                            };
                            if property_lookup == VALUE_REF_LOOKUP_MISSING then (
                                emit_type_property_access_value{
                                    info.object,
                                    info.property.start,
                                    info.property.length,
                                    input_len
                                }
                            ) else (
                                value_ref_lookup_to_lowered_value(property_lookup)
                            )
                        ),
                        else => LoweredValueLookup::InputError
                    }
                )
            ),
            NodeKind::ArrayIndex(info) => (
                index_lookup := resolve_lowered_value_index_access{
                    info.array,
                    info.index,
                    input_len
                };
                index_lookup |> match {
                    LoweredValueLookup::Missing => emit_array_index_value{
                        info.array,
                        info.index,
                        input_len
                    },
                    else => index_lookup
                }
            ),
            NodeKind::Assignment(info) => (
                emit_assignment_value{expr_idx, input_len}
            ),
            NodeKind::Binding(binding) => (
                emit_binding_value{expr_idx, input_len}
            ),
            NodeKind::Block(list) => (
                emit_block_value{list.head, list.count, input_len}
            ),
            NodeKind::Diverge(info) => (
                divergence_tag := info.divergance_type |> match {
                    DivergeExpressionType::Return => 0,
                    DivergeExpressionType::Break => 1,
                    else => -1
                };
                emit_diverge_value{info.value, divergence_tag, input_len}
            ),
            NodeKind::Loop(info) => (
                emit_loop_value{info.body, input_len}
            ),
            else => LoweredValueLookup::Missing
        }
    )
);

update_known_type_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        value_type_tag := resolve_scalar_type_expr{expr_idx, input_len};
        if value_type_tag == INPUT_VALUE_TYPE_UNKNOWN then (
            clear_known_type_alias{binding_extract_state.name_start, binding_extract_state.name_length, input_len}
        ) else (
            set_known_type_alias{
                binding_extract_state.name_start,
                binding_extract_state.name_length,
                value_type_tag,
                input_len
            }
        )
    )
);

update_known_scalar_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        value_lookup := resolve_scalar_value_expr{expr_idx, input_len};
        value_lookup |> match {
            ScalarValueLookup::InputError => 0,
            ScalarValueLookup::Missing => (
                clear_known_scalar_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    input_len
                }
            ),
            ScalarValueLookup::Value(value) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                resolved_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                    else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                    else default_scalar_type_tag(value.value_tag);
                set_known_scalar_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    value.value_tag,
                    value.value_i32,
                    resolved_type_tag,
                    input_len
                }
            ),
            else => 0
        }
    )
);

update_known_value_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        value_lookup := resolve_lowered_value_expr{expr_idx, input_len};
        value_lookup |> match {
            LoweredValueLookup::InputError => 0,
            LoweredValueLookup::OutputError => 0,
            LoweredValueLookup::Missing => (
                clear_known_value_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    input_len
                }
            ),
            LoweredValueLookup::Scalar(value) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                resolved_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                    else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                    else default_scalar_type_tag(value.value_tag);
                set_known_value_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    value.value_tag,
                    value.value_i32,
                    resolved_type_tag,
                    -1,
                    input_len
                }
            ),
            LoweredValueLookup::ValueRef(value_ref) => (
                set_known_value_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    VALUE_TAG_UNKNOWN,
                    0,
                    INPUT_VALUE_TYPE_UNKNOWN,
                    value_ref,
                    input_len
                }
            ),
            else => 0
        }
    )
);

update_known_function_alias_for_binding := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then 0
    else (
        function_lookup := resolve_function_alias_expr{expr_idx, input_len};
        function_lookup |> match {
            FunctionAliasLookup::InputError => 0,
            FunctionAliasLookup::Missing => (
                clear_known_function_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    input_len
                }
            ),
            FunctionAliasLookup::Present => (
                set_known_function_alias{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    input_len
                }
            ),
            else => 0
        }
    )
);

resolve_wrapper_source_target := {} => (
    if target_count(binding_extract_state.wrap_mask) == 0 then WrapperSourceTarget::Missing else (
        mut source_target_tag := binding_extract_state.first_export_target_tag;
        source_target_mask := target_mask_from_output_target_tag(source_target_tag);
        if source_target_mask == 0 || target_mask_has{binding_extract_state.export_mask, source_target_mask} == 0 then (
            source_target_tag = first_target_tag(binding_extract_state.export_mask);
        ) else (
            {}
        );
        if source_target_tag < 0 then WrapperSourceTarget::Missing else WrapperSourceTarget::Target(source_target_tag)
    )
);

reset_output_slots := {} => (
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_function_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.output_inline_binding_count = 0;
    lower_state.output_value_count = 0;
    lower_state.output_value_field_count = 0;
    1
);

emit_global_entry := {
    name_start: i32,
    name_length: i32,
    ty_tag: i32,
    value_tag: i32,
    value_i32: i32,
    value_ref: i32
} => (
    idx := lower_state.output_global_count;
    if idx < 0 || idx >= MAX_OUTPUT_GLOBALS then -1 else (
        output_globals(idx).name_start = name_start;
        output_globals(idx).name_length = name_length;
        output_globals(idx).ty_tag = ty_tag;
        output_globals(idx).value_tag = value_tag;
        output_globals(idx).value_i32 = value_i32;
        output_globals(idx).value_ref = value_ref;
        lower_state.output_global_count = idx + 1;
        idx
    )
);

emit_function_entry := {
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_function_count;
    if idx < 0 || idx >= MAX_OUTPUT_FUNCTIONS then -1 else (
        output_functions(idx).name_start = name_start;
        output_functions(idx).name_length = name_length;
        lower_state.output_function_count = idx + 1;
        idx
    )
);

emit_export_entry := {
    target_tag: i32,
    export_type: i32,
    item_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_export_count;
    if idx < 0 || idx >= MAX_OUTPUT_EXPORTS then 0 else (
        output_exports(idx).target_tag = target_tag;
        output_exports(idx).export_type = export_type;
        output_exports(idx).index = item_index;
        output_exports(idx).name_start = name_start;
        output_exports(idx).name_length = name_length;
        lower_state.output_export_count = idx + 1;
        1
    )
);

emit_wrapper_entry := {
    source_target_tag: i32,
    wrap_target_tag: i32,
    export_type: i32,
    item_index: i32,
    name_start: i32,
    name_length: i32
} => (
    idx := lower_state.output_wrapper_count;
    if idx < 0 || idx >= MAX_OUTPUT_WRAPPERS then 0 else (
        output_wrappers(idx).source_target_tag = source_target_tag;
        output_wrappers(idx).wrap_target_tag = wrap_target_tag;
        output_wrappers(idx).export_type = export_type;
        output_wrappers(idx).index = item_index;
        output_wrappers(idx).name_start = name_start;
        output_wrappers(idx).name_length = name_length;
        lower_state.output_wrapper_count = idx + 1;
        1
    )
);

emit_inline_binding_entry := {
    name_start: i32,
    name_length: i32,
    value_tag: i32,
    value_i32: i32,
    value_ref: i32
} => (
    idx := lower_state.output_inline_binding_count;
    if idx < 0 || idx >= MAX_OUTPUT_INLINE_BINDINGS then 0 else (
        output_inline_bindings(idx).name_start = name_start;
        output_inline_bindings(idx).name_length = name_length;
        output_inline_bindings(idx).value_tag = value_tag;
        output_inline_bindings(idx).value_i32 = value_i32;
        output_inline_bindings(idx).value_ref = value_ref;
        lower_state.output_inline_binding_count = idx + 1;
        1
    )
);

emit_inline_binding_for_binding := {expr_idx: i32, input_len: i32} => (
    if binding_should_materialize{} == 1 then (
        1
    ) else (
        if resolve_scalar_type_expr{expr_idx, input_len} != INPUT_VALUE_TYPE_UNKNOWN then (
            1
        ) else (
            resolve_function_alias_expr{expr_idx, input_len} |> match {
                FunctionAliasLookup::InputError => 0,
                FunctionAliasLookup::Present => 1,
                FunctionAliasLookup::Missing => (
                    value_lookup := resolve_lowered_value_expr{expr_idx, input_len};
                    value_lookup |> match {
                        LoweredValueLookup::InputError => 0,
                        LoweredValueLookup::OutputError => 0,
                        LoweredValueLookup::Missing => 1,
                        LoweredValueLookup::Scalar(value) => emit_inline_binding_entry{
                            binding_extract_state.name_start,
                            binding_extract_state.name_length,
                            value.value_tag,
                            value.value_i32,
                            -1
                        },
                        LoweredValueLookup::ValueRef(value_ref) => emit_inline_binding_entry{
                            binding_extract_state.name_start,
                            binding_extract_state.name_length,
                            VALUE_TAG_UNKNOWN,
                            0,
                            value_ref
                        },
                        else => 0
                    }
                ),
                else => 0
            }
        )
    )
);

resolve_output_global_type_tag := {value_tag: i32, value_type_tag: i32} => (
    if value_type_tag == INPUT_VALUE_TYPE_U8 then OUTPUT_GLOBAL_TYPE_U8
    else if value_type_tag == INPUT_VALUE_TYPE_I32 then OUTPUT_GLOBAL_TYPE_I32
    else if value_tag == VALUE_TAG_CHAR then OUTPUT_GLOBAL_TYPE_U8
    else OUTPUT_GLOBAL_TYPE_I32
);

value_ref_requires_explicit_global_type := (value_ref: i32) => (
    if value_ref < 0 || value_ref >= lower_state.output_value_count then 1
    else (
        kind_tag := output_values(value_ref).kind_tag;
        if kind_tag == OUTPUT_VALUE_KIND_IDENTIFIER
            || kind_tag == OUTPUT_VALUE_KIND_TYPE_PROPERTY_ACCESS
            || kind_tag == OUTPUT_VALUE_KIND_ARRAY_INDEX
            || kind_tag == OUTPUT_VALUE_KIND_FUNCTION_CALL
        then 1 else 0
    )
);

emit_function_binding_outputs := {} => (
    if binding_extract_state.export_mask == 0 then LowerBindingResult::Ok else (
        function_index := emit_function_entry{
            binding_extract_state.name_start,
            binding_extract_state.name_length
        };
        if function_index < 0 then LowerBindingResult::OutputError else (
            mut emit_ok := 1;
            if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                emit_ok = emit_export_entry{
                    OUTPUT_TARGET_JS,
                    OUTPUT_EXPORT_TYPE_FUNCTION,
                    function_index,
                    binding_extract_state.name_start,
                    binding_extract_state.name_length
                };
            ) else (
                {}
            );
            if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                emit_ok = emit_export_entry{
                    OUTPUT_TARGET_WASM,
                    OUTPUT_EXPORT_TYPE_FUNCTION,
                    function_index,
                    binding_extract_state.name_start,
                    binding_extract_state.name_length
                };
            ) else (
                {}
            );
            if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                emit_ok = emit_export_entry{
                    OUTPUT_TARGET_WGSL,
                    OUTPUT_EXPORT_TYPE_FUNCTION,
                    function_index,
                    binding_extract_state.name_start,
                    binding_extract_state.name_length
                };
            ) else (
                {}
            );
            if emit_ok == 0 then LowerBindingResult::OutputError
            else (
                wrapper_source_target := resolve_wrapper_source_target{};
                wrapper_source_target |> match {
                    WrapperSourceTarget::Missing => (
                        LowerBindingResult::Ok
                    ),
                    WrapperSourceTarget::Target(source_target_tag) => (
                        if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_JS,
                                OUTPUT_EXPORT_TYPE_FUNCTION,
                                function_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_WASM,
                                OUTPUT_EXPORT_TYPE_FUNCTION,
                                function_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                            emit_ok = emit_wrapper_entry{
                                source_target_tag,
                                OUTPUT_TARGET_WGSL,
                                OUTPUT_EXPORT_TYPE_FUNCTION,
                                function_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                    ),
                    else => LowerBindingResult::OutputError
                }
            )
        )
    )
);

lower_binding_expr := {expr_idx: i32, input_len: i32} => (
    if safe_name_bounds{binding_extract_state.name_start, binding_extract_state.name_length, input_len} == 0 then LowerBindingResult::InputError
    else if binding_extract_state.export_mask < 0 || binding_extract_state.wrap_mask < 0 || binding_extract_state.target_mask < 0 then LowerBindingResult::InputError
    else if binding_should_materialize{} == 0 then LowerBindingResult::Ok
    else (
        if expr_idx >= 0 && expr_idx < MAX_NODES then (
            if NodeKind::Function(_) := nodes(expr_idx).kind then (
                emit_function_binding_outputs{}
            ) else (
                function_lookup := resolve_function_alias_expr{expr_idx, input_len};
                function_lookup |> match {
                FunctionAliasLookup::Present => emit_function_binding_outputs{},
                FunctionAliasLookup::InputError => LowerBindingResult::InputError,
                FunctionAliasLookup::Missing => (
                value_lookup := resolve_lowered_value_expr{expr_idx, input_len};
                value_lookup |> match {
                LoweredValueLookup::InputError => LowerBindingResult::InputError,
                LoweredValueLookup::OutputError => LowerBindingResult::OutputError,
                LoweredValueLookup::Missing => LowerBindingResult::Unimplemented,
                LoweredValueLookup::Scalar(value) => (
                    explicit_type_tag := binding_extract_state.value_type_tag;
                    value_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                        else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                        else default_scalar_type_tag(value.value_tag);
                    global_type_tag := resolve_output_global_type_tag{value.value_tag, value_type_tag};
                    global_index := emit_global_entry{
                        binding_extract_state.name_start,
                        binding_extract_state.name_length,
                        global_type_tag,
                        value.value_tag,
                        value.value_i32,
                        -1
                    };
                    if global_index < 0 then LowerBindingResult::OutputError else (
                        mut emit_ok := 1;
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_JS,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_WASM,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_WGSL,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 0 then LowerBindingResult::OutputError
                        else (
                            wrapper_source_target := resolve_wrapper_source_target{};
                            wrapper_source_target |> match {
                                WrapperSourceTarget::Missing => (
                                    LowerBindingResult::Ok
                                ),
                                WrapperSourceTarget::Target(source_target_tag) => (
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_JS,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_WASM,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_WGSL,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                                ),
                                else => LowerBindingResult::OutputError
                            }
                        )
                    )
                ),
                LoweredValueLookup::ValueRef(value_ref) => (
                    explicit_type_tag := binding_extract_state.value_type_tag;
                    if explicit_type_tag == INPUT_VALUE_TYPE_UNKNOWN
                        && value_ref_requires_explicit_global_type(value_ref) == 1
                    then (
                        LowerBindingResult::Unimplemented
                    ) else (
                    global_type_tag := if explicit_type_tag == INPUT_VALUE_TYPE_UNKNOWN then OUTPUT_GLOBAL_TYPE_INFER
                        else resolve_output_global_type_tag{VALUE_TAG_UNKNOWN, explicit_type_tag};
                    global_index := emit_global_entry{
                        binding_extract_state.name_start,
                        binding_extract_state.name_length,
                        global_type_tag,
                        VALUE_TAG_UNKNOWN,
                        0,
                        value_ref
                    };
                    if global_index < 0 then LowerBindingResult::OutputError else (
                        mut emit_ok := 1;
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_JS,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_WASM,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                            emit_ok = emit_export_entry{
                                OUTPUT_TARGET_WGSL,
                                OUTPUT_EXPORT_TYPE_GLOBAL,
                                global_index,
                                binding_extract_state.name_start,
                                binding_extract_state.name_length
                            };
                        ) else (
                            {}
                        );
                        if emit_ok == 0 then LowerBindingResult::OutputError
                        else (
                            wrapper_source_target := resolve_wrapper_source_target{};
                            wrapper_source_target |> match {
                                WrapperSourceTarget::Missing => (
                                    LowerBindingResult::Ok
                                ),
                                WrapperSourceTarget::Target(source_target_tag) => (
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_JS,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_WASM,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                        emit_ok = emit_wrapper_entry{
                                            source_target_tag,
                                            OUTPUT_TARGET_WGSL,
                                            OUTPUT_EXPORT_TYPE_GLOBAL,
                                            global_index,
                                            binding_extract_state.name_start,
                                            binding_extract_state.name_length
                                        };
                                    ) else (
                                        {}
                                    );
                                    if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                                ),
                                else => LowerBindingResult::OutputError
                            }
                        )
                    )
                    )
                ),
                else => LowerBindingResult::OutputError
            }
            ),
                else => LowerBindingResult::InputError
            }
            )
        ) else (
            value_lookup := resolve_lowered_value_expr{expr_idx, input_len};
            value_lookup |> match {
            LoweredValueLookup::InputError => LowerBindingResult::InputError,
            LoweredValueLookup::OutputError => LowerBindingResult::OutputError,
            LoweredValueLookup::Missing => LowerBindingResult::Unimplemented,
            LoweredValueLookup::Scalar(value) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                value_type_tag := if explicit_type_tag != INPUT_VALUE_TYPE_UNKNOWN then explicit_type_tag
                    else if value.value_type_tag != INPUT_VALUE_TYPE_UNKNOWN then value.value_type_tag
                    else default_scalar_type_tag(value.value_tag);
                global_type_tag := resolve_output_global_type_tag{value.value_tag, value_type_tag};
                global_index := emit_global_entry{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    global_type_tag,
                    value.value_tag,
                    value.value_i32,
                    -1
                };
                if global_index < 0 then LowerBindingResult::OutputError else (
                    mut emit_ok := 1;
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_JS,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WASM,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WGSL,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 0 then LowerBindingResult::OutputError
                    else (
                        wrapper_source_target := resolve_wrapper_source_target{};
                        wrapper_source_target |> match {
                            WrapperSourceTarget::Missing => (
                                LowerBindingResult::Ok
                            ),
                            WrapperSourceTarget::Target(source_target_tag) => (
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_JS,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WASM,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WGSL,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                            ),
                            else => LowerBindingResult::OutputError
                        }
                    )
                )
            ),
            LoweredValueLookup::ValueRef(value_ref) => (
                explicit_type_tag := binding_extract_state.value_type_tag;
                if explicit_type_tag == INPUT_VALUE_TYPE_UNKNOWN
                    && value_ref_requires_explicit_global_type(value_ref) == 1
                then (
                    LowerBindingResult::Unimplemented
                ) else (
                global_type_tag := if explicit_type_tag == INPUT_VALUE_TYPE_UNKNOWN then OUTPUT_GLOBAL_TYPE_INFER
                    else resolve_output_global_type_tag{VALUE_TAG_UNKNOWN, explicit_type_tag};
                global_index := emit_global_entry{
                    binding_extract_state.name_start,
                    binding_extract_state.name_length,
                    global_type_tag,
                    VALUE_TAG_UNKNOWN,
                    0,
                    value_ref
                };
                if global_index < 0 then LowerBindingResult::OutputError else (
                    mut emit_ok := 1;
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_JS} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_JS,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WASM} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WASM,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 1 && target_mask_has{binding_extract_state.export_mask, TARGET_MASK_WGSL} == 1 then (
                        emit_ok = emit_export_entry{
                            OUTPUT_TARGET_WGSL,
                            OUTPUT_EXPORT_TYPE_GLOBAL,
                            global_index,
                            binding_extract_state.name_start,
                            binding_extract_state.name_length
                        };
                    ) else (
                        {}
                    );
                    if emit_ok == 0 then LowerBindingResult::OutputError
                    else (
                        wrapper_source_target := resolve_wrapper_source_target{};
                        wrapper_source_target |> match {
                            WrapperSourceTarget::Missing => (
                                LowerBindingResult::Ok
                            ),
                            WrapperSourceTarget::Target(source_target_tag) => (
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_JS} == 1 && source_target_tag != OUTPUT_TARGET_JS then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_JS,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WASM} == 1 && source_target_tag != OUTPUT_TARGET_WASM then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WASM,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 && target_mask_has{binding_extract_state.wrap_mask, TARGET_MASK_WGSL} == 1 && source_target_tag != OUTPUT_TARGET_WGSL then (
                                    emit_ok = emit_wrapper_entry{
                                        source_target_tag,
                                        OUTPUT_TARGET_WGSL,
                                        OUTPUT_EXPORT_TYPE_GLOBAL,
                                        global_index,
                                        binding_extract_state.name_start,
                                        binding_extract_state.name_length
                                    };
                                ) else (
                                    {}
                                );
                                if emit_ok == 1 then LowerBindingResult::Ok else LowerBindingResult::OutputError
                            ),
                            else => LowerBindingResult::OutputError
                        }
                    )
                )
                )
            ),
            else => LowerBindingResult::OutputError
        }
        )
    )
);

finalize_output_payload := {} => (
    if lower_state.output_global_count == 0
        && lower_state.output_function_count == 0
        && lower_state.output_export_count == 0
        && lower_state.output_wrapper_count == 0
        && lower_state.output_inline_binding_count == 0
        && lower_state.output_value_count == 0
        && lower_state.output_value_field_count == 0
    then (
        lower_state.output_len = 0;
        1
    ) else (
        lower_state.output_len = lower_state.output_global_count
            + lower_state.output_function_count
            + lower_state.output_export_count
            + lower_state.output_wrapper_count
            + lower_state.output_inline_binding_count
            + lower_state.output_value_count
            + lower_state.output_value_field_count;
        1
    )
);

count_bindings_in_root := (root: i32) => (
    if root < 0 || root >= MAX_NODES then -1 else (
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut idx := 0;
            mut binding_count := 0;
            while idx < list.count && current != -1 do (
                node_idx := list_nodes(current).value;
                if node_idx >= 0 && node_idx < MAX_NODES then (
                    if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                        binding_count = binding_count + 1;
                        {}
                    ) else (
                        {}
                    )
                ) else (
                    {}
                );
                current = list_nodes(current).next;
                idx = idx + 1;
                {}
            );
            binding_count
        ) else (
            if NodeKind::Binding(binding) := nodes(root).kind then 1 else 0
        )
    )
);

parse_body_records := {root: i32, binding_count: i32, input_len: i32} => (
    mut idx := 0;
    mut parsed_bindings := 0;
    mut parsed_annotated := 0;
    mut body_ok := 1;
    mut output_ok := reset_output_slots{};
    mut lowering_unimplemented := 0;
    reset_binding_lookup_state{};

    if root < 0 || root >= MAX_NODES then (
        body_ok = 0;
    ) else if NodeKind::Block(list) := nodes(root).kind then (
        mut current := list.head;
        while idx < list.count && current != -1 && body_ok == 1 do (
            node_idx := list_nodes(current).value;
            if node_idx < 0 || node_idx >= MAX_NODES then (
                body_ok = 0;
            ) else if NodeKind::Binding(binding) := nodes(node_idx).kind then (
                if resolve_binding_pattern{binding.pattern, input_len} == 0 then (
                    parsed_bindings = parsed_bindings + 1;
                    lowering_unimplemented = 1;
                ) else (
                    parsed_bindings = parsed_bindings + 1;
                    if binding_has_any_annotations{} == 1 then (
                        parsed_annotated = parsed_annotated + 1;
                    ) else (
                        {}
                    );

                    if output_ok == 1 && lowering_unimplemented == 0 then (
                        lowering_result := lower_binding_expr{binding.expr, input_len};
                        lowering_code := lowering_result |> match {
                            LowerBindingResult::Ok => 0,
                            LowerBindingResult::Unimplemented => 1,
                            LowerBindingResult::OutputError => 2,
                            LowerBindingResult::InputError => 3,
                            else => 4
                        };
                        if lowering_code == 1 then (
                            lowering_unimplemented = 1;
                        ) else if lowering_code == 2 then (
                            output_ok = 0;
                        ) else if lowering_code == 3 then (
                            body_ok = 0;
                        ) else if lowering_code == 4 then (
                            output_ok = 0;
                        ) else (
                            {}
                        );
                        {}
                    ) else (
                        {}
                    );

                    if output_ok == 1 && emit_inline_binding_for_binding{binding.expr, input_len} == 0 then (
                        output_ok = 0;
                    ) else (
                        {}
                    );

                    if body_ok == 1 && update_known_type_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else if body_ok == 1 && update_known_scalar_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else if body_ok == 1 && update_known_value_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else if body_ok == 1 && update_known_function_alias_for_binding{binding.expr, input_len} == 0 then (
                        body_ok = 0;
                    ) else (
                        {}
                    )
                )
            ) else (
                {}
            );
            current = list_nodes(current).next;
            idx = idx + 1;
            {}
        );
    ) else (
        if NodeKind::Binding(binding) := nodes(root).kind then (
            parsed_bindings = 1;
            if resolve_binding_pattern{binding.pattern, input_len} == 0 then (
                lowering_unimplemented = 1;
            ) else (
                if binding_has_any_annotations{} == 1 then (
                    parsed_annotated = 1;
                ) else (
                    {}
                );

                if output_ok == 1 && lowering_unimplemented == 0 then (
                    lowering_result := lower_binding_expr{binding.expr, input_len};
                    lowering_code := lowering_result |> match {
                        LowerBindingResult::Ok => 0,
                        LowerBindingResult::Unimplemented => 1,
                        LowerBindingResult::OutputError => 2,
                        LowerBindingResult::InputError => 3,
                        else => 4
                    };
                    if lowering_code == 1 then (
                        lowering_unimplemented = 1;
                    ) else if lowering_code == 2 then (
                        output_ok = 0;
                    ) else if lowering_code == 3 then (
                        body_ok = 0;
                    ) else if lowering_code == 4 then (
                        output_ok = 0;
                    ) else (
                        {}
                    );
                    {}
                ) else (
                    {}
                );

                if output_ok == 1 && emit_inline_binding_for_binding{binding.expr, input_len} == 0 then (
                    output_ok = 0;
                ) else (
                    {}
                );

                if body_ok == 1 && update_known_type_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else if body_ok == 1 && update_known_scalar_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else if body_ok == 1 && update_known_value_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else if body_ok == 1 && update_known_function_alias_for_binding{binding.expr, input_len} == 0 then (
                    body_ok = 0;
                ) else (
                    {}
                )
            )
        ) else (
            parsed_bindings = 0;
        );
        idx = 1;
    );

    lower_state.parse_cursor = idx;
    lower_state.parsed_binding_count = parsed_bindings;
    lower_state.parsed_annotated_binding_count = parsed_annotated;
    lower_state.header_annotated_binding_count = parsed_annotated;
    lower_state.body_ok = body_ok;
    lower_state.lowering_unimplemented = lowering_unimplemented;

    if body_ok == 0 then 0
    else if parsed_bindings != binding_count then 0
    else if output_ok == 0 then 2
    else 1
);

run_lower_context := {root: i32, binding_count: i32, input_len: i32} => (
    lower_state.error_code = lower_error_none{};
    lower_state.last_scope_count = 1;
    lower_state.last_binding_count = binding_count;
    lower_state.last_input_len = input_len;
    lower_state.input_magic_ok = 0;
    lower_state.header_version = 0;
    lower_state.header_scope_count = 0;
    lower_state.header_binding_count = 0;
    lower_state.header_annotated_binding_count = 0;
    lower_state.parsed_binding_count = 0;
    lower_state.parsed_annotated_binding_count = 0;
    lower_state.parse_cursor = 0;
    lower_state.body_ok = 0;
    lower_state.header_ok = 0;
    lower_state.output_len = 0;
    lower_state.output_global_count = 0;
    lower_state.output_function_count = 0;
    lower_state.output_export_count = 0;
    lower_state.output_wrapper_count = 0;
    lower_state.output_inline_binding_count = 0;
    lower_state.output_value_count = 0;
    lower_state.output_value_field_count = 0;
    lower_state.lowering_unimplemented = 0;

    lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
    lower_state.header_version = intermediate_payload_version{};
    lower_state.header_scope_count = 1;
    lower_state.header_binding_count = binding_count;

    if lower_state.input_magic_ok == 0 then (
        lower_state.error_code = lower_error_input_too_small{};
        lower_status_error{}
    ) else if binding_count < 0 then (
        lower_state.error_code = lower_error_header_count_mismatch{};
        lower_status_error{}
    ) else (
        parse_ok := parse_body_records{root, binding_count, input_len};
        if parse_ok == 0 then (
            if lower_state.body_ok == 0 then (
                lower_state.error_code = lower_error_body_parse_failed{};
            ) else (
                lower_state.error_code = lower_error_body_count_mismatch{};
            );
            lower_status_error{}
        ) else if parse_ok == 2 then (
            lower_state.error_code = lower_error_output_encode_failed{};
            lower_status_error{}
        ) else (
            lower_state.header_ok = 1;
            if lower_state.lowering_unimplemented == 1 then (
                lower_status_unimplemented{}
            ) else (
                finalize_ok := finalize_output_payload{};
                if finalize_ok == 0 then (
                    lower_state.error_code = lower_error_output_encode_failed{};
                    lower_status_error{}
                ) else (
                    lower_status_ok{}
                )
            )
        )
    )
);

(export wasm) lower_context := (root: i32) => (
    input_len := if state.cursor >= 0 && state.cursor <= MAX_INPUT then state.cursor else MAX_INPUT;
    binding_count := count_bindings_in_root(root);
    if binding_count < 0 then (
        lower_state.error_code = lower_error_body_parse_failed{};
        lower_state.last_scope_count = 1;
        lower_state.last_binding_count = 0;
        lower_state.last_input_len = input_len;
        lower_state.input_magic_ok = if input_len >= 0 && input_len <= MAX_INPUT then 1 else 0;
        lower_state.header_version = intermediate_payload_version{};
        lower_state.header_scope_count = 1;
        lower_state.header_binding_count = 0;
        lower_state.header_annotated_binding_count = 0;
        lower_state.parsed_binding_count = 0;
        lower_state.parsed_annotated_binding_count = 0;
        lower_state.parse_cursor = 0;
        lower_state.body_ok = 0;
        lower_state.header_ok = 0;
        lower_state.output_len = 0;
        lower_state.output_global_count = 0;
        lower_state.output_function_count = 0;
        lower_state.output_export_count = 0;
        lower_state.output_wrapper_count = 0;
        lower_state.output_inline_binding_count = 0;
        lower_state.output_value_count = 0;
        lower_state.output_value_field_count = 0;
        lower_state.lowering_unimplemented = 0;
        lower_status_error{}
    ) else (
        run_lower_context{root, binding_count, input_len}
    )
);

(export wasm) get_lower_error_code := {} => (
    lower_state.error_code
);

(export wasm) get_lower_last_scope_count := {} => (
    lower_state.last_scope_count
);

(export wasm) get_lower_last_binding_count := {} => (
    lower_state.last_binding_count
);

(export wasm) get_lower_last_input_len := {} => (
    lower_state.last_input_len
);

(export wasm) get_lower_input_magic_ok := {} => (
    lower_state.input_magic_ok
);

(export wasm) get_lower_header_version := {} => (
    lower_state.header_version
);

(export wasm) get_lower_header_scope_count := {} => (
    lower_state.header_scope_count
);

(export wasm) get_lower_header_binding_count := {} => (
    lower_state.header_binding_count
);

(export wasm) get_lower_header_annotated_binding_count := {} => (
    lower_state.header_annotated_binding_count
);

(export wasm) get_lower_header_ok := {} => (
    lower_state.header_ok
);

(export wasm) get_lower_parsed_binding_count := {} => (
    lower_state.parsed_binding_count
);

(export wasm) get_lower_parsed_annotated_binding_count := {} => (
    lower_state.parsed_annotated_binding_count
);

(export wasm) get_lower_parse_cursor := {} => (
    lower_state.parse_cursor
);

(export wasm) get_lower_body_ok := {} => (
    lower_state.body_ok
);

(export wasm) get_lower_output_len := {} => (
    lower_state.output_len
);

(export wasm) get_lower_output_global_count := {} => (
    lower_state.output_global_count
);

(export wasm) get_lower_output_function_count := {} => (
    lower_state.output_function_count
);

(export wasm) get_lower_output_export_count := {} => (
    lower_state.output_export_count
);

(export wasm) get_lower_output_wrapper_count := {} => (
    lower_state.output_wrapper_count
);

(export wasm) get_lower_output_inline_binding_count := {} => (
    lower_state.output_inline_binding_count
);

(export wasm) get_lower_output_value_count := {} => (
    lower_state.output_value_count
);

(export wasm) get_lower_output_value_field_count := {} => (
    lower_state.output_value_field_count
);

(export wasm) get_lower_lowering_unimplemented := {} => (
    lower_state.lowering_unimplemented
);

(export wasm) get_lower_output_global_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_start
);

(export wasm) get_lower_output_global_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).name_length
);

(export wasm) get_lower_output_global_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).ty_tag
);

(export wasm) get_lower_output_global_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_tag
);

(export wasm) get_lower_output_global_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_i32
);

(export wasm) get_lower_output_global_value_ref := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_global_count then -1 else output_globals(idx).value_ref
);

(export wasm) get_lower_output_function_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_function_count then -1 else output_functions(idx).name_start
);

(export wasm) get_lower_output_function_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_function_count then -1 else output_functions(idx).name_length
);

(export wasm) get_lower_output_export_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).target_tag
);

(export wasm) get_lower_output_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).export_type
);

(export wasm) get_lower_output_export_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).index
);

(export wasm) get_lower_output_export_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_start
);

(export wasm) get_lower_output_export_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_export_count then -1 else output_exports(idx).name_length
);

(export wasm) get_lower_output_wrapper_source_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).source_target_tag
);

(export wasm) get_lower_output_wrapper_wrap_target_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).wrap_target_tag
);

(export wasm) get_lower_output_wrapper_export_type_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).export_type
);

(export wasm) get_lower_output_wrapper_index := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).index
);

(export wasm) get_lower_output_wrapper_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_start
);

(export wasm) get_lower_output_wrapper_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_wrapper_count then -1 else output_wrappers(idx).name_length
);

(export wasm) get_lower_output_inline_binding_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).name_start
);

(export wasm) get_lower_output_inline_binding_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).name_length
);

(export wasm) get_lower_output_inline_binding_value_tag := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).value_tag
);

(export wasm) get_lower_output_inline_binding_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).value_i32
);

(export wasm) get_lower_output_inline_binding_value_ref := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_inline_binding_count then -1 else output_inline_bindings(idx).value_ref
);

(export wasm) get_lower_output_value_kind := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).kind_tag
);

(export wasm) get_lower_output_value_i32 := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).value_i32
);

(export wasm) get_lower_output_value_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).name_start
);

(export wasm) get_lower_output_value_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).name_length
);

(export wasm) get_lower_output_value_item_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).item_start
);

(export wasm) get_lower_output_value_item_count := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_count then -1 else output_values(idx).item_count
);

(export wasm) get_lower_output_value_field_name_start := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_field_count then -1 else output_value_fields(idx).name_start
);

(export wasm) get_lower_output_value_field_name_length := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_field_count then -1 else output_value_fields(idx).name_length
);

(export wasm) get_lower_output_value_field_value_ref := (idx: i32) => (
    if idx < 0 || idx >= lower_state.output_value_field_count then -1 else output_value_fields(idx).value_ref
);

