types := use "types.silk";

StringRef := types.StringRef;
SourceSpan := types.SourceSpan;

Identifier := types.Identifier;

TargetLiteral := types.TargetLiteral;

BindingAnnotationLiteral := types.BindingAnnotationLiteral;

ExpressionLiteral := types.ExpressionLiteral;

IntrinsicType := types.IntrinsicType;

UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;

BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;

IntrinsicOperation := types.IntrinsicOperation;

DivergeExpressionType := types.DivergeExpressionType;

BindingPattern := types.BindingPattern;

LValue := types.LValue;

Binding := types.Binding;

ExpressionList := types.ExpressionList;

FunctionTypeInfo := types.FunctionTypeInfo;
FunctionInfo := types.FunctionInfo;
EnumValueInfo := types.EnumValueInfo;
EnumConstructorInfo := types.EnumConstructorInfo;
IfInfo := types.IfInfo;
AttachImplementationInfo := types.AttachImplementationInfo;
ArrayRepeatInfo := types.ArrayRepeatInfo;
OperationInfo := types.OperationInfo;
AssignmentInfo := types.AssignmentInfo;
FunctionCallInfo := types.FunctionCallInfo;
ArrayIndexInfo := types.ArrayIndexInfo;
TypePropertyAccessInfo := types.TypePropertyAccessInfo;
DivergeInfo := types.DivergeInfo;
LoopInfo := types.LoopInfo;
MatchInfo := types.MatchInfo;
StructInfo := types.StructInfo;
EnumTypeInfo := types.EnumTypeInfo;

NodeKind := types.NodeKind;

TypeCache := types.TypeCache;
Node := types.Node;

ListNode := types.ListNode;

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;

EMPTY_STRING := types.EMPTY_STRING;
SYNTHETIC_MUT_STRING := types.SYNTHETIC_MUT_STRING;
SYNTHETIC_OPTION_STRING := types.SYNTHETIC_OPTION_STRING;
SYNTHETIC_SOME_STRING := types.SYNTHETIC_SOME_STRING;
SYNTHETIC_ITER_TY_STRING := types.SYNTHETIC_ITER_TY_STRING;
SYNTHETIC_NEXT_STRING := types.SYNTHETIC_NEXT_STRING;
SYNTHETIC_FOR_ITER_STRING := types.SYNTHETIC_FOR_ITER_STRING;
EMPTY_IDENTIFIER := types.EMPTY_IDENTIFIER;
EMPTY_SPAN := types.EMPTY_SPAN;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

State := types.State;

Value := enum {
    Number = i32,
    Boolean = i32,
    Char = i32,
    String = StringRef,
    Unit = {},
};

ValueState := { count = i32, error = i32 };

MAX_VALUES := 16384;

EMPTY_VALUE := Value::Unit;

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };
(export wasm) mut values: Box({Value; MAX_VALUES}) := {EMPTY_VALUE; MAX_VALUES};
(export wasm) mut value_state: Box(ValueState) := { count = 0, error = -1 };

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

set_error: (i32 -> i32) := (pos: i32) => (
    if value_state.error == -1 then (
        value_state.error = pos;
        0
    ) else (
        0
    );
    0
);

reset_interpreter := {} => (
    value_state.count = 0;
    value_state.error = -1;
    0
);

enter_scope := {} => (
    0
);

exit_scope := {} => (
    0
);

string_ref_equals := {left: StringRef, right: StringRef} => (
    if left.start < 0 || right.start < 0 then (
        if left.start == right.start && left.length == right.length then 1 else 0
    ) else if left.length != right.length then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left.length do (
            if input(left.start + idx) != input(right.start + idx) then (
                ok = 0;
                idx = left.length;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

op_is1 := {op_start: i32, op_len: i32, ch: u8} => (
    if op_len == 1 then (
        if input(op_start) == ch then 1 else 0
    ) else 0
);

op_is2 := {op_start: i32, op_len: i32, ch1: u8, ch2: u8} => (
    if op_len == 2 then (
        if input(op_start) == ch1 then (
            if input(op_start + 1) == ch2 then 1 else 0
        ) else 0
    ) else 0
);

store_value := (value: Value) => (
    if value_state.count >= MAX_VALUES then (
        set_error(0);
        -1
    ) else (
        idx := value_state.count;
        values(idx) = value;
        value_state.count = value_state.count + 1;
        idx
    )
);

is_empty_struct := (fields: i32) => (
    if fields == -1 then 1 else 0
);

eval_literal := (lit: ExpressionLiteral) => (
    lit |> match {
        ExpressionLiteral::Number(value) => Value::Number(value),
        ExpressionLiteral::Boolean(value) => Value::Boolean(value),
        ExpressionLiteral::Char(value) => Value::Char(value),
        ExpressionLiteral::String(value) => Value::String(value),
        else => Value::Unit
    }
);

eval_expression: (i32 -> i32) := (idx: i32) => (
    if value_state.error != -1 then (
        -1
    ) else (
        span_start := nodes(idx).span.start;
        nodes(idx).kind |> match {
            NodeKind::Literal(lit) => store_value(eval_literal(lit)),
            NodeKind::Identifier(_) => (
                set_error(span_start);
                -1
            ),
            NodeKind::Binding(binding) => (
                eval_expression(binding.expr)
            ),
            NodeKind::Assignment(_) => (
                set_error(span_start);
                -1
            ),
            NodeKind::Operation(info) => (
                left_idx := eval_expression(info.left);
                right_idx := eval_expression(info.right);
                if left_idx == -1 || right_idx == -1 then (
                    -1
                ) else (
                    op_start := info.operator.start;
                    op_len := info.operator.length;
                    left := values(left_idx);
                    right := values(right_idx);
                    if Value::Number(lv) := left then (
                        if Value::Number(rv) := right then (
                            if op_is1{op_start, op_len, '+'} == 1 then (
                                store_value(Value::Number(lv + rv))
                            ) else if op_is1{op_start, op_len, '-'} == 1 then (
                                store_value(Value::Number(lv - rv))
                            ) else if op_is1{op_start, op_len, '*'} == 1 then (
                                store_value(Value::Number(lv * rv))
                            ) else if op_is1{op_start, op_len, '/'} == 1 then (
                                if rv == 0 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    store_value(Value::Number(lv / rv))
                                )
                            ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                            ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                store_value(Value::Boolean(if lv < rv then 1 else 0))
                            ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                store_value(Value::Boolean(if lv > rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                store_value(Value::Boolean(if lv <= rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                store_value(Value::Boolean(if lv >= rv then 1 else 0))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    ) else if Value::Boolean(lv) := left then (
                        if Value::Boolean(rv) := right then (
                            if op_is2{op_start, op_len, '&', '&'} == 1 then (
                                store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                            ) else if op_is2{op_start, op_len, '|', '|'} == 1 then (
                                store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                            ) else if op_is1{op_start, op_len, '^'} == 1 then (
                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    ) else if Value::Char(lv) := left then (
                        if Value::Char(rv) := right then (
                            if op_is2{op_start, op_len, '=', '='} == 1 then (
                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                            ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                store_value(Value::Boolean(if lv < rv then 1 else 0))
                            ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                store_value(Value::Boolean(if lv > rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                store_value(Value::Boolean(if lv <= rv then 1 else 0))
                            ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                store_value(Value::Boolean(if lv >= rv then 1 else 0))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    ) else if Value::String(lv) := left then (
                        if Value::String(rv) := right then (
                            if op_is2{op_start, op_len, '=', '='} == 1 then (
                                store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 1 else 0))
                            ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 0 else 1))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::If(info) => (
                cond_idx := eval_expression(info.condition);
                if cond_idx == -1 then (
                    -1
                ) else (
                    cond_value := values(cond_idx);
                    if Value::Boolean(flag) := cond_value then (
                        if flag == 1 then (
                            eval_expression(info.then_branch)
                        ) else (
                            eval_expression(info.else_branch)
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::Block(list) => (
                enter_scope{};
                mut current := list.head;
                mut count := 0;
                mut last_idx: i32 := store_value(Value::Unit);
                while count < list.count && current != -1 do (
                    last_idx = eval_expression(list_nodes(current).value);
                    current = list_nodes(current).next;
                    count = count + 1;
                    {}
                );
                exit_scope{};
                last_idx
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then (
                    store_value(Value::Unit)
                ) else (
                    set_error(span_start);
                    -1
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

value_tag := (value: Value) => (
    value |> match {
        Value::Number(_) => 0,
        Value::Boolean(_) => 1,
        Value::Char(_) => 2,
        Value::String(_) => 3,
        Value::Unit => 4,
        else => -1
    }
);

(export wasm) interpret := (root: i32) => (
    reset_interpreter{};
    enter_scope{};
    result_idx := eval_expression(root);
    exit_scope{};
    if value_state.error != -1 then (
        -1
    ) else (
        result_idx
    )
);

(export wasm) get_interp_error := {} => (
    value_state.error
);

(export wasm) get_value_tag := (idx: i32) => (
    value_tag(values(idx))
);

(export wasm) get_value_number := (idx: i32) => (
    if Value::Number(value) := values(idx) then value else 0
);

(export wasm) get_value_boolean := (idx: i32) => (
    if Value::Boolean(value) := values(idx) then value else 0
);

(export wasm) get_value_char := (idx: i32) => (
    if Value::Char(value) := values(idx) then value else 0
);

(export wasm) get_value_string_start := (idx: i32) => (
    if Value::String(value) := values(idx) then value.start else -1
);

(export wasm) get_value_string_length := (idx: i32) => (
    if Value::String(value) := values(idx) then value.length else 0
);

