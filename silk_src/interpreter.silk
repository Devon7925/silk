types := use "types.silk";

StringRef := types.StringRef;
SourceSpan := types.SourceSpan;

Identifier := types.Identifier;

TargetLiteral := types.TargetLiteral;

BindingAnnotationLiteral := types.BindingAnnotationLiteral;

ExpressionLiteral := types.ExpressionLiteral;

IntrinsicType := types.IntrinsicType;

UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;

BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;

IntrinsicOperation := types.IntrinsicOperation;

DivergeExpressionType := types.DivergeExpressionType;

BindingPattern := types.BindingPattern;

LValue := types.LValue;

Binding := types.Binding;

ExpressionList := types.ExpressionList;

FunctionTypeInfo := types.FunctionTypeInfo;
FunctionInfo := types.FunctionInfo;
EnumValueInfo := types.EnumValueInfo;
EnumConstructorInfo := types.EnumConstructorInfo;
IfInfo := types.IfInfo;
AttachImplementationInfo := types.AttachImplementationInfo;
ArrayRepeatInfo := types.ArrayRepeatInfo;
OperationInfo := types.OperationInfo;
AssignmentInfo := types.AssignmentInfo;
FunctionCallInfo := types.FunctionCallInfo;
ArrayIndexInfo := types.ArrayIndexInfo;
TypePropertyAccessInfo := types.TypePropertyAccessInfo;
DivergeInfo := types.DivergeInfo;
LoopInfo := types.LoopInfo;
MatchInfo := types.MatchInfo;
StructInfo := types.StructInfo;
EnumTypeInfo := types.EnumTypeInfo;

NodeKind := types.NodeKind;

TypeCache := types.TypeCache;
Node := types.Node;

ListNode := types.ListNode;

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;

EMPTY_STRING := types.EMPTY_STRING;
SYNTHETIC_MUT_STRING := types.SYNTHETIC_MUT_STRING;
SYNTHETIC_OPTION_STRING := types.SYNTHETIC_OPTION_STRING;
SYNTHETIC_SOME_STRING := types.SYNTHETIC_SOME_STRING;
SYNTHETIC_ITER_TY_STRING := types.SYNTHETIC_ITER_TY_STRING;
SYNTHETIC_NEXT_STRING := types.SYNTHETIC_NEXT_STRING;
SYNTHETIC_FOR_ITER_STRING := types.SYNTHETIC_FOR_ITER_STRING;
EMPTY_IDENTIFIER := types.EMPTY_IDENTIFIER;
EMPTY_SPAN := types.EMPTY_SPAN;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

State := types.State;

Value := enum {
    Number = i32,
    Boolean = i32,
    Char = i32,
    String = StringRef,
    Unit = {},
    Function = i32,
    Record = { head = i32, count = i32, has_named = i32 },
};

ValueState := { count = i32, error = i32 };

BindingState := { count = i32, scope_count = i32 };
BindingTemp := { start = i32, length = i32, is_mut = i32, ok = i32 };

FlowState := { kind = i32, value = i32 };
RuntimeState := { loop_depth = i32, function_depth = i32 };

MAX_VALUES := 16384;
MAX_BINDINGS := 4096;
MAX_SCOPES := 256;

FLOW_NONE := -1;
FLOW_RETURN := 0;
FLOW_BREAK := 1;

EMPTY_VALUE := Value::Unit;

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };
(export wasm) mut values: Box({Value; MAX_VALUES}) := {EMPTY_VALUE; MAX_VALUES};
(export wasm) mut value_state: Box(ValueState) := { count = 0, error = -1 };
(export wasm) mut binding_name_start: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_name_length: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_values: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_is_mut: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_state: Box(BindingState) := { count = 0, scope_count = 0 };
(export wasm) mut binding_temp: Box(BindingTemp) := { start = 0, length = 0, is_mut = 0, ok = 0 };
(export wasm) mut scope_stack: Box({i32; MAX_SCOPES}) := {0; MAX_SCOPES};
(export wasm) mut flow_state: Box(FlowState) := { kind = FLOW_NONE, value = -1 };
(export wasm) mut runtime_state: Box(RuntimeState) := { loop_depth = 0, function_depth = 0 };

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

set_error: (i32 -> i32) := (pos: i32) => (
    if value_state.error == -1 then (
        value_state.error = pos;
        0
    ) else (
        0
    );
    0
);

reset_interpreter := {} => (
    value_state.count = 0;
    value_state.error = -1;
    binding_state.count = 0;
    binding_state.scope_count = 0;
    binding_temp.start = 0;
    binding_temp.length = 0;
    binding_temp.is_mut = 0;
    binding_temp.ok = 0;
    flow_state.kind = FLOW_NONE;
    flow_state.value = -1;
    runtime_state.loop_depth = 0;
    runtime_state.function_depth = 0;
    0
);

enter_scope := {} => (
    if binding_state.scope_count >= MAX_SCOPES then (
        set_error(0);
        0
    ) else (
        scope_stack(binding_state.scope_count) = binding_state.count;
        binding_state.scope_count = binding_state.scope_count + 1;
        0
    )
);

exit_scope := {} => (
    if binding_state.scope_count <= 0 then (
        set_error(0);
        0
    ) else (
        binding_state.scope_count = binding_state.scope_count - 1;
        binding_state.count = scope_stack(binding_state.scope_count);
        0
    )
);

string_ref_equals := {left: StringRef, right: StringRef} => (
    if left.start < 0 || right.start < 0 then (
        if left.start == right.start && left.length == right.length then 1 else 0
    ) else if left.length != right.length then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left.length do (
            if input(left.start + idx) != input(right.start + idx) then (
                ok = 0;
                idx = left.length;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_equals_raw := {left_start: i32, left_len: i32, right_start: i32, right_len: i32} => (
    if left_start < 0 || right_start < 0 then (
        if left_start == right_start && left_len == right_len then 1 else 0
    ) else if left_len != right_len then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left_len do (
            if input(left_start + idx) != input(right_start + idx) then (
                ok = 0;
                idx = left_len;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_MUT_STRING.start && value.length == SYNTHETIC_MUT_STRING.length then 1 else 0
    ) else if value.length != 3 then (
        0
    ) else (
        if input(value.start) == 'm' then (
            if input(value.start + 1) == 'u' then (
                if input(value.start + 2) == 't' then 1 else 0
            ) else 0
        ) else 0
    )
);


annotation_is_mut := (idx: i32) => (
    if idx == -1 then 0 else (
        nodes(idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => 1,
                    else => 0
                }
            ),
            else => 0
        }
    )
);

annotations_has_mut := (head: i32) => (
    mut current := head;
    mut found := 0;
    while current != -1 do (
        if annotation_is_mut(list_nodes(current).value) == 1 then (
            found = 1;
            current = -1;
        ) else (
            current = list_nodes(current).next;
        );
        {}
    );
    found
);

expr_contains_mut_annotation := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::FunctionCall(info) => (
                if expr_contains_mut_annotation(info.function) == 1 then 1 else (
                    expr_contains_mut_annotation(info.argument)
                )
            ),
            else => 0
        }
    )
);

resolve_binding_from_expr: (i32 -> i32) := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_temp.start = 0;
        binding_temp.length = 0;
        binding_temp.is_mut = 0;
        binding_temp.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                binding_temp.start = id.name.start;
                binding_temp.length = id.name.length;
                binding_temp.is_mut = 0;
                binding_temp.ok = 1;
                1
            ),
            NodeKind::Operation(op) => (
                if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                    resolve_binding_from_expr(op.left)
                ) else (
                    binding_temp.start = 0;
                    binding_temp.length = 0;
                    binding_temp.is_mut = 0;
                    binding_temp.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                resolve_binding_from_expr(info.argument);
                if binding_temp.ok == 0 then (
                    0
                ) else (
                    mut_flag := expr_contains_mut_annotation(info.function);
                    binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                    binding_temp.ok = 1;
                    1
                )
            ),
            else => (
                binding_temp.start = 0;
                binding_temp.length = 0;
                binding_temp.is_mut = 0;
                binding_temp.ok = 0;
                0
            )
        }
    )
);

resolve_binding_pattern: (BindingPattern -> i32) := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Identifier(info) => (
            binding_temp.start = info.name.name.start;
            binding_temp.length = info.name.name.length;
            binding_temp.is_mut = 0;
            binding_temp.ok = 1;
            1
        ),
        BindingPattern::Annotated(info) => (
            resolve_binding_from_expr(info.pattern);
            if binding_temp.ok == 0 then (
                0
            ) else (
                mut_flag := annotations_has_mut(info.annotations);
                binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                binding_temp.ok = 1;
                1
            )
        ),
        BindingPattern::TypeHint(info) => resolve_binding_from_expr(info.pattern),
        else => (
            binding_temp.start = 0;
            binding_temp.length = 0;
            binding_temp.is_mut = 0;
            binding_temp.ok = 0;
            0
        )
    }
);

find_binding_index := (name: StringRef) => (
    mut idx := binding_state.count - 1;
    mut found := -1;
    while idx >= 0 do (
        if string_ref_equals_raw{
            binding_name_start(idx),
            binding_name_length(idx),
            name.start,
            name.length
        } == 1 then (
            found = idx;
            idx = -1;
        ) else (
            idx = idx - 1;
        );
        {}
    );
    found
);

add_binding := {start: i32, length: i32, value: i32, is_mut: i32} => (
    if binding_state.count >= MAX_BINDINGS then (
        set_error(0);
        -1
    ) else (
        idx := binding_state.count;
        binding_name_start(idx) = start;
        binding_name_length(idx) = length;
        binding_values(idx) = value;
        binding_is_mut(idx) = is_mut;
        binding_state.count = idx + 1;
        idx
    )
);

new_list_node := {value: i32, next: i32} => (
    if state.list_count >= MAX_LIST_NODES then (
        set_error(0);
        -1
    ) else (
        idx := state.list_count;
        list_nodes(idx).value = value;
        list_nodes(idx).next = next;
        state.list_count = idx + 1;
        idx
    )
);

string_ref_to_i32 := {start: i32, length: i32} => (
    if start < 0 then (
        -1
    ) else if length <= 0 then (
        -1
    ) else (
        mut idx := 0;
        mut acc := 0;
        mut ok := 1;
        while idx < length do (
            ch := input(start + idx);
            if ch < '0' || ch > '9' then (
                ok = 0;
                idx = length;
            ) else (
                acc = acc * 10 + (ch - '0');
                idx = idx + 1;
            );
            {}
        );
        if ok == 1 then acc else -1
    )
);

record_value_index_by_position := {start: i32, count: i32, index: i32, span_start: i32} => (
    if index < 0 then (
        set_error(span_start);
        -1
    ) else if index >= count then (
        set_error(span_start);
        -1
    ) else (
        start + index * 2 + 1
    )
);

record_find_field_index := {start: i32, count: i32, has_named: i32, name_start: i32, name_length: i32, span_start: i32} => (
    mut found := -1;
    if has_named == 1 && name_length > 0 then (
        mut idx := 0;
        while idx < count do (
            name_idx := start + idx * 2;
            if Value::String(name_ref) := values(name_idx) then (
                if string_ref_equals_raw{
                    name_ref.start,
                    name_ref.length,
                    name_start,
                    name_length
                } == 1 then (
                    found = name_idx + 1;
                    idx = count;
                ) else (
                    idx = idx + 1;
                )
            ) else (
                idx = idx + 1;
            );
            {}
        );
        0
    ) else (
        0
    );
    if found != -1 then (
        found
    ) else (
        idx_num := string_ref_to_i32{name_start, name_length};
        if idx_num < 0 then (
            set_error(span_start);
            -1
        ) else (
            record_value_index_by_position{start, count, idx_num, span_start}
        )
    )
);

op_is1 := {op_start: i32, op_len: i32, ch: u8} => (
    if op_len == 1 then (
        if input(op_start) == ch then 1 else 0
    ) else 0
);

op_is2 := {op_start: i32, op_len: i32, ch1: u8, ch2: u8} => (
    if op_len == 2 then (
        if input(op_start) == ch1 then (
            if input(op_start + 1) == ch2 then 1 else 0
        ) else 0
    ) else 0
);

store_value := (value: Value) => (
    if value_state.count >= MAX_VALUES then (
        set_error(0);
        -1
    ) else (
        idx := value_state.count;
        values(idx) = value;
        value_state.count = value_state.count + 1;
        idx
    )
);

is_empty_struct := (fields: i32) => (
    if fields == -1 then 1 else 0
);


eval_literal := (lit: ExpressionLiteral) => (
    lit |> match {
        ExpressionLiteral::Number(value) => Value::Number(value),
        ExpressionLiteral::Boolean(value) => Value::Boolean(value),
        ExpressionLiteral::Char(value) => Value::Char(value),
        ExpressionLiteral::String(value) => Value::String(value),
        else => Value::Unit
    }
);

eval_expression: (i32 -> i32) := (idx: i32) => (
    if value_state.error != -1 then (
        -1
    ) else if flow_state.kind != FLOW_NONE then (
        flow_state.value
    ) else (
        span_start := nodes(idx).span.start;
        nodes(idx).kind |> match {
            NodeKind::Literal(lit) => store_value(eval_literal(lit)),
            NodeKind::Identifier(id) => (
                binding_idx := find_binding_index(id.name);
                if binding_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    binding_values(binding_idx)
                )
            ),
            NodeKind::Binding(binding) => (
                value_idx := eval_expression(binding.expr);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    if resolve_binding_pattern(binding.pattern) == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        add_binding{binding_temp.start, binding_temp.length, value_idx, binding_temp.is_mut};
                        value_idx
                    )
                )
            ),
            NodeKind::Assignment(info) => (
                value_idx := eval_expression(info.expr);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    info.target |> match {
                        LValue::Identifier(target_info) => (
                            idx := find_binding_index(target_info.name.name);
                            if idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if binding_is_mut(idx) == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                binding_values(idx) = value_idx;
                                value_idx
                            )
                        ),
                        LValue::TypePropertyAccess(target_info) => (
                            if NodeKind::Identifier(id) := nodes(target_info.object).kind then (
                                idx := find_binding_index(id.name);
                                if idx == -1 then (
                                    set_error(span_start);
                                    -1
                                ) else if binding_is_mut(idx) == 0 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    struct_idx := binding_values(idx);
                                    if Value::Record(struct_info) := values(struct_idx) then (
                                        field_idx := record_find_field_index{
                                            struct_info.head,
                                            struct_info.count,
                                            struct_info.has_named,
                                            target_info.property.start,
                                            target_info.property.length,
                                            span_start
                                        };
                                        if field_idx == -1 then (
                                            -1
                                        ) else (
                                            values(field_idx) = values(value_idx);
                                            value_idx
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ),
                        LValue::ArrayIndex(target_info) => (
                            if NodeKind::Identifier(id) := nodes(target_info.array).kind then (
                                idx := find_binding_index(id.name);
                                if idx == -1 then (
                                    set_error(span_start);
                                    -1
                                ) else if binding_is_mut(idx) == 0 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    index_idx := eval_expression(target_info.index);
                                    if index_idx == -1 then (
                                        -1
                                    ) else if flow_state.kind != FLOW_NONE then (
                                        index_idx
                                    ) else (
                                        if Value::Number(index_value) := values(index_idx) then (
                                            struct_idx := binding_values(idx);
                                            if Value::Record(struct_info) := values(struct_idx) then (
                                                field_idx := record_value_index_by_position{
                                                    struct_info.head,
                                                    struct_info.count,
                                                    index_value,
                                                    span_start
                                                };
                                                if field_idx == -1 then (
                                                    -1
                                                ) else (
                                                    values(field_idx) = values(value_idx);
                                                    value_idx
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ),
                        else => (
                            set_error(span_start);
                            -1
                        )
                    }
                )
            ),
            NodeKind::Function(_) => (
                store_value(Value::Function(idx))
            ),
            NodeKind::FunctionCall(info) => (
                if NodeKind::TypePropertyAccess(access) := nodes(info.function).kind then (
                    obj_idx := eval_expression(info.argument);
                    if obj_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        obj_idx
                    ) else (
                        if Value::Record(struct_info) := values(obj_idx) then (
                            field_idx := record_find_field_index{
                                struct_info.head,
                                struct_info.count,
                                struct_info.has_named,
                                access.property.start,
                                access.property.length,
                                span_start
                            };
                            if field_idx == -1 then (
                                -1
                            ) else (
                                field_idx
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                ) else (
                    func_idx := eval_expression(info.function);
                    if func_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        func_idx
                    ) else (
                        arg_idx := eval_expression(info.argument);
                        if arg_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            arg_idx
                        ) else (
                            func_val := values(func_idx);
                            if Value::Function(fn_node) := func_val then (
                                if NodeKind::Function(fn_info) := nodes(fn_node).kind then (
                                runtime_state.function_depth = runtime_state.function_depth + 1;
                                enter_scope{};
                                bind_ok := resolve_binding_pattern(fn_info.parameter);
                                mut result_idx := -1;
                                if bind_ok == 0 then (
                                    set_error(span_start);
                                    result_idx = -1;
                                ) else (
                                    add_binding{binding_temp.start, binding_temp.length, arg_idx, binding_temp.is_mut};
                                    result_idx = eval_expression(fn_info.body);
                                    if flow_state.kind == FLOW_RETURN then (
                                        result_idx = flow_state.value;
                                        flow_state.kind = FLOW_NONE;
                                        flow_state.value = -1;
                                    );
                                );
                                exit_scope{};
                                runtime_state.function_depth = runtime_state.function_depth - 1;
                                result_idx
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    )
                )
            ),
            NodeKind::IntrinsicOperation(info) => (
                info |> match {
                    IntrinsicOperation::Binary(bin) => (
                        left_idx := eval_expression(bin.left);
                        if left_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            left_idx
                        ) else (
                            right_idx := eval_expression(bin.right);
                            if right_idx == -1 then (
                                -1
                            ) else if flow_state.kind != FLOW_NONE then (
                                right_idx
                            ) else (
                                left := values(left_idx);
                                right := values(right_idx);
                                bin.operator |> match {
                                    BinaryIntrinsicOperator::I32Add => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv + rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Subtract => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv - rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Multiply => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv * rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Divide => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                if rv == 0 then (
                                                    set_error(span_start);
                                                    -1
                                                ) else (
                                                    store_value(Value::Number(lv / rv))
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Equal => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32NotEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv < rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv > rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanAnd => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanOr => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanXor => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    else => (
                                        set_error(span_start);
                                        -1
                                    )
                                }
                            )
                        )
                    ),
                    IntrinsicOperation::Unary(unary) => (
                        operand_idx := eval_expression(unary.operand);
                        if operand_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            operand_idx
                        ) else (
                            unary.operator |> match {
                                UnaryIntrinsicOperator::BooleanNot => (
                                    if Value::Boolean(flag) := values(operand_idx) then (
                                        store_value(Value::Boolean(if flag == 1 then 0 else 1))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                else => (
                                    set_error(span_start);
                                    -1
                                )
                            }
                        )
                    ),
                    IntrinsicOperation::InlineAssembly(_) => (
                        set_error(span_start);
                        -1
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Operation(info) => (
                left_idx := eval_expression(info.left);
                if left_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    left_idx
                ) else (
                    right_idx := eval_expression(info.right);
                    if right_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        right_idx
                    ) else (
                        op_start := info.operator.start;
                        op_len := info.operator.length;
                        left := values(left_idx);
                        right := values(right_idx);
                        if Value::Number(lv) := left then (
                            if Value::Number(rv) := right then (
                                if op_is1{op_start, op_len, '+'} == 1 then (
                                    store_value(Value::Number(lv + rv))
                                ) else if op_is1{op_start, op_len, '-'} == 1 then (
                                    store_value(Value::Number(lv - rv))
                                ) else if op_is1{op_start, op_len, '*'} == 1 then (
                                    store_value(Value::Number(lv * rv))
                                ) else if op_is1{op_start, op_len, '/'} == 1 then (
                                    if rv == 0 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        store_value(Value::Number(lv / rv))
                                    )
                                ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::Boolean(lv) := left then (
                            if Value::Boolean(rv) := right then (
                                if op_is2{op_start, op_len, '&', '&'} == 1 then (
                                    store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                                ) else if op_is2{op_start, op_len, '|', '|'} == 1 then (
                                    store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                                ) else if op_is1{op_start, op_len, '^'} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::Char(lv) := left then (
                            if Value::Char(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::String(lv) := left then (
                            if Value::String(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 0 else 1))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::If(info) => (
                cond_idx := eval_expression(info.condition);
                if cond_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    cond_idx
                ) else (
                    cond_value := values(cond_idx);
                    if Value::Boolean(flag) := cond_value then (
                        if flag == 1 then (
                            eval_expression(info.then_branch)
                        ) else (
                            eval_expression(info.else_branch)
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::Block(list) => (
                enter_scope{};
                mut current := list.head;
                mut count := 0;
                mut last_idx: i32 := store_value(Value::Unit);
                while count < list.count && current != -1 do (
                    last_idx = eval_expression(list_nodes(current).value);
                    if value_state.error != -1 || flow_state.kind != FLOW_NONE then (
                        current = -1;
                        0
                    ) else (
                        current = list_nodes(current).next;
                        count = count + 1;
                        0
                    );
                    {}
                );
                exit_scope{};
                last_idx
            ),
            NodeKind::Loop(info) => (
                runtime_state.loop_depth = runtime_state.loop_depth + 1;
                mut last_idx := store_value(Value::Unit);
                mut done := 0;
                while done == 0 do (
                    last_idx = eval_expression(info.body);
                    if value_state.error != -1 then (
                        done = 1;
                        0
                    ) else if flow_state.kind == FLOW_BREAK then (
                        last_idx = flow_state.value;
                        flow_state.kind = FLOW_NONE;
                        flow_state.value = -1;
                        done = 1;
                        0
                    ) else if flow_state.kind == FLOW_RETURN then (
                        done = 1;
                        0
                    ) else (
                        0
                    );
                    {}
                );
                runtime_state.loop_depth = runtime_state.loop_depth - 1;
                last_idx
            ),
            NodeKind::Diverge(info) => (
                info.divergance_type |> match {
                    DivergeExpressionType::Break => (
                        if runtime_state.loop_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FLOW_BREAK;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    DivergeExpressionType::Return => (
                        if runtime_state.function_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FLOW_RETURN;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Match(info) => (
                set_error(span_start);
                -1
            ),
            NodeKind::EnumValue(info) => (
                set_error(span_start);
                -1
            ),
            NodeKind::ArrayIndex(info) => (
                array_idx := eval_expression(info.array);
                if array_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    array_idx
                ) else (
                    index_idx := eval_expression(info.index);
                    if index_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        index_idx
                    ) else (
                        if Value::Number(index_value) := values(index_idx) then (
                            if Value::Record(struct_info) := values(array_idx) then (
                                field_idx := record_value_index_by_position{
                                    struct_info.head,
                                    struct_info.count,
                                    index_value,
                                    span_start
                                };
                                if field_idx == -1 then (
                                    -1
                                ) else (
                                    field_idx
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::TypePropertyAccess(info) => (
                obj_idx := eval_expression(info.object);
                if obj_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    obj_idx
                ) else (
                    if Value::Record(struct_info) := values(obj_idx) then (
                        field_idx := record_find_field_index{
                            struct_info.head,
                            struct_info.count,
                            struct_info.has_named,
                            info.property.start,
                            info.property.length,
                            span_start
                        };
                        if field_idx == -1 then (
                            -1
                        ) else (
                            field_idx
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::ArrayRepeat(info) => (
                value_idx := eval_expression(info.value);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    count_idx := eval_expression(info.count);
                    if count_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        count_idx
                    ) else (
                        if Value::Number(count_value) := values(count_idx) then (
                            if count_value < 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                start_idx := value_state.count;
                                mut idx := 0;
                                while idx < count_value do (
                                    name_idx := store_value(Value::String(EMPTY_STRING));
                                    if name_idx == -1 then (
                                        idx = count_value;
                                    ) else (
                                        val_idx := store_value(values(value_idx));
                                        if val_idx == -1 then (
                                            idx = count_value;
                                        ) else (
                                            idx = idx + 1;
                                        );
                                    );
                                    {}
                                );
                                if value_state.error != -1 then (
                                    -1
                                ) else (
                                    store_value(Value::Record({ head = start_idx, count = count_value, has_named = 0 }))
                                )
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then (
                    store_value(Value::Unit)
                ) else (
                    mut current := info.fields;
                    mut temp_head := -1;
                    mut temp_tail := -1;
                    mut last_idx := -1;
                    while current != -1 do (
                        field_node := list_nodes(current).value;
                        if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                            last_idx = eval_expression(field_binding.expr);
                            if last_idx == -1 then (
                                current = -1;
                            ) else if flow_state.kind != FLOW_NONE then (
                                current = -1;
                            ) else (
                                temp_node := new_list_node{last_idx, -1};
                                if temp_node == -1 then (
                                    current = -1;
                                ) else (
                                    if temp_head == -1 then (
                                        temp_head = temp_node;
                                    ) else (
                                        list_nodes(temp_tail).next = temp_node;
                                    );
                                    temp_tail = temp_node;
                                    current = list_nodes(current).next;
                                )
                            )
                        ) else (
                            set_error(span_start);
                            current = -1;
                        );
                        {}
                    );
                    if value_state.error != -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        last_idx
                    ) else (
                        start_idx := value_state.count;
                        mut count := 0;
                        mut has_named := 0;
                        current = info.fields;
                        mut temp_current := temp_head;
                        while current != -1 && temp_current != -1 do (
                            field_node := list_nodes(current).value;
                            if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                                mut field_name := EMPTY_STRING;
                                field_binding.pattern |> match {
                                    BindingPattern::Identifier(id) => (field_name = id.name.name),
                                    else => (field_name = EMPTY_STRING)
                                };
                                if field_name.length > 0 then (
                                    has_named = 1;
                                    0
                                ) else (
                                    0
                                );
                                name_idx := store_value(Value::String(field_name));
                                if name_idx == -1 then (
                                    current = -1;
                                    temp_current = -1;
                                ) else (
                                    val_idx := store_value(values(list_nodes(temp_current).value));
                                    if val_idx == -1 then (
                                        current = -1;
                                        temp_current = -1;
                                    ) else (
                                        count = count + 1;
                                        current = list_nodes(current).next;
                                        temp_current = list_nodes(temp_current).next;
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                current = -1;
                                temp_current = -1;
                            );
                            {}
                        );
                        if value_state.error != -1 then (
                            -1
                        ) else (
                            store_value(Value::Record({ head = start_idx, count = count, has_named = has_named }))
                        )
                    )
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

value_tag := (value: Value) => (
    value |> match {
        Value::Number(_) => 0,
        Value::Boolean(_) => 1,
        Value::Char(_) => 2,
        Value::String(_) => 3,
        Value::Unit => 4,
        Value::Function(_) => 5,
        Value::Record(_) => 6,
        else => -1
    }
);

(export wasm) interpret := (root: i32) => (
    reset_interpreter{};
    enter_scope{};
    result_idx := eval_expression(root);
    exit_scope{};
    if value_state.error != -1 then (
        -1
    ) else (
        result_idx
    )
);

(export wasm) get_interp_error := {} => (
    value_state.error
);

(export wasm) get_value_tag := (idx: i32) => (
    value_tag(values(idx))
);

(export wasm) get_value_number := (idx: i32) => (
    if Value::Number(value) := values(idx) then value else 0
);

(export wasm) get_value_boolean := (idx: i32) => (
    if Value::Boolean(value) := values(idx) then value else 0
);

(export wasm) get_value_char := (idx: i32) => (
    if Value::Char(value) := values(idx) then value else 0
);

(export wasm) get_value_string_start := (idx: i32) => (
    if Value::String(value) := values(idx) then value.start else -1
);

(export wasm) get_value_string_length := (idx: i32) => (
    if Value::String(value) := values(idx) then value.length else 0
);


