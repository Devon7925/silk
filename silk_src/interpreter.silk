types := use "types.silk";

StringRef := types.StringRef;
SourceSpan := types.SourceSpan;

Identifier := types.Identifier;

TargetLiteral := types.TargetLiteral;

BindingAnnotationLiteral := types.BindingAnnotationLiteral;

ExpressionLiteral := types.ExpressionLiteral;

IntrinsicType := types.IntrinsicType;

UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;

BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;

IntrinsicOperation := types.IntrinsicOperation;

DivergeExpressionType := types.DivergeExpressionType;

BindingPattern := types.BindingPattern;

LValue := types.LValue;

Binding := types.Binding;

ExpressionList := types.ExpressionList;

FunctionTypeInfo := types.FunctionTypeInfo;
FunctionInfo := types.FunctionInfo;
EnumValueInfo := types.EnumValueInfo;
EnumConstructorInfo := types.EnumConstructorInfo;
IfInfo := types.IfInfo;
AttachImplementationInfo := types.AttachImplementationInfo;
ArrayRepeatInfo := types.ArrayRepeatInfo;
OperationInfo := types.OperationInfo;
AssignmentInfo := types.AssignmentInfo;
FunctionCallInfo := types.FunctionCallInfo;
ArrayIndexInfo := types.ArrayIndexInfo;
TypePropertyAccessInfo := types.TypePropertyAccessInfo;
DivergeInfo := types.DivergeInfo;
LoopInfo := types.LoopInfo;
MatchInfo := types.MatchInfo;
StructInfo := types.StructInfo;
EnumTypeInfo := types.EnumTypeInfo;

NodeKind := types.NodeKind;

TypeCache := types.TypeCache;
Node := types.Node;

ListNode := types.ListNode;

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;

EMPTY_STRING := types.EMPTY_STRING;
SYNTHETIC_MUT_STRING := types.SYNTHETIC_MUT_STRING;
SYNTHETIC_OPTION_STRING := types.SYNTHETIC_OPTION_STRING;
SYNTHETIC_SOME_STRING := types.SYNTHETIC_SOME_STRING;
SYNTHETIC_NONE_STRING := { length = 4, start = -14 };
SYNTHETIC_ITER_TY_STRING := types.SYNTHETIC_ITER_TY_STRING;
SYNTHETIC_NEXT_STRING := types.SYNTHETIC_NEXT_STRING;
SYNTHETIC_FOR_ITER_STRING := types.SYNTHETIC_FOR_ITER_STRING;
SYNTHETIC_CURRENT_STRING := { length = 7, start = -15 };
SYNTHETIC_END_STRING := { length = 3, start = -16 };
SYNTHETIC_BOX_STRING := { length = 3, start = -17 };
SYNTHETIC_I32_STRING := { length = 3, start = -8 };
SYNTHETIC_U8_STRING := { length = 2, start = -9 };
SYNTHETIC_BOOL_STRING := { length = 4, start = -10 };
SYNTHETIC_TYPE_STRING := { length = 4, start = -11 };
SYNTHETIC_TARGET_STRING := { length = 6, start = -12 };
SYNTHETIC_BINDING_ANNOTATION_STRING := { length = 18, start = -13 };
SYNTHETIC_JS_STRING := { length = 2, start = -18 };
SYNTHETIC_WASM_STRING := { length = 4, start = -19 };
SYNTHETIC_WGSL_STRING := { length = 4, start = -20 };
SYNTHETIC_RANGE_STRING := { length = 5, start = -21 };
EMPTY_IDENTIFIER := types.EMPTY_IDENTIFIER;
EMPTY_SPAN := types.EMPTY_SPAN;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

State := types.State;

Value := enum {
    Number = i32,
    Boolean = i32,
    Char = i32,
    String = StringRef,
    Unit = {},
    Function = i32,
    Record = { head = i32, count = i32, has_named = i32 },
    Builtin = i32,
    EnumType = { head = i32, count = i32 },
    EnumConstructor = { enum_head = i32, enum_count = i32, variant_idx = i32, expects_payload = i32 },
    Enum = { enum_head = i32, enum_count = i32, variant_idx = i32, payload = i32 },
    MatchFunction = { head = i32, count = i32 },
    Target = i32,
    BindingAnnotation = { kind = i32, target = i32 },
    AsmFunction = i32,
    InlineAssembly = { target = i32, code = StringRef },
};

ValueState := { count = i32, error = i32 };

BindingState := { count = i32, scope_count = i32 };
BindingTemp := { start = i32, length = i32, is_mut = i32, ok = i32 };
BindingTargetState := { depth = i32, acc_mask = i32 };
ImplementationState := { count = i32 };
FileState := { count = i32 };
IntrinsicState := { binding_count = i32 };
AnnotationTemp := { is_mut = i32, target_mask = i32, export_mask = i32, wrap_mask = i32 };

FlowState := { kind = i32, value = i32 };
RuntimeState := {
    loop_depth = i32,
    function_depth = i32,
    option_enum_idx = i32,
    option_i32_enum_idx = i32,
    type_value_idx = i32,
    range_type_idx = i32
};
BindPatternState := { value_idx = i32, inherit_mut = i32, inherit_target_mask = i32, inherit_export_mask = i32, inherit_wrap_mask = i32 };

MAX_VALUES := 10000;
MAX_BINDINGS := 4096;
MAX_IMPLS := 1024;
MAX_SCOPES := 256;
MAX_FILES := 256;

FLOW_NONE := -1;
FLOW_RETURN := 0;
FLOW_BREAK := 1;

BUILTIN_ENUM := 0;
BUILTIN_MATCH := 1;
BUILTIN_EXPORT := 2;
BUILTIN_TARGET := 3;
BUILTIN_WRAP := 4;
BUILTIN_ASM := 5;
BUILTIN_OPTION := 6;
BUILTIN_ITERATOR := 7;
BUILTIN_RANGE_NEXT := 8;
BUILTIN_USE := 9;

TARGET_JS := 0;
TARGET_WASM := 1;
TARGET_WGSL := 2;
TARGET_MASK_JS := 1;
TARGET_MASK_WASM := 2;
TARGET_MASK_WGSL := 4;

BINDING_ANN_MUT := 0;
BINDING_ANN_EXPORT := 1;
BINDING_ANN_TARGET := 2;
BINDING_ANN_WRAP := 3;

EMPTY_VALUE := Value::Unit;

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };
(export wasm) mut values: Box({Value; MAX_VALUES}) := {EMPTY_VALUE; MAX_VALUES};
(export wasm) mut value_state: Box(ValueState) := { count = 0, error = -1 };
mut value_type_values: Box({i32; MAX_VALUES}) := {-1; MAX_VALUES};
mut value_is_box_type: Box({i32; MAX_VALUES}) := {0; MAX_VALUES};
(export wasm) mut binding_name_start: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_name_length: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_values: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_is_mut: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_type_values: Box({i32; MAX_BINDINGS}) := {-1; MAX_BINDINGS};
mut binding_target_mask: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_export_mask: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_wrap_mask: Box({i32; MAX_BINDINGS}) := {0; MAX_BINDINGS};
(export wasm) mut binding_state: Box(BindingState) := { count = 0, scope_count = 0 };
(export wasm) mut binding_temp: Box(BindingTemp) := { start = 0, length = 0, is_mut = 0, ok = 0 };
(export wasm) mut binding_target_state: Box(BindingTargetState) := { depth = 0, acc_mask = 0 };
(export wasm) mut impl_type_values: Box({i32; MAX_IMPLS}) := {0; MAX_IMPLS};
(export wasm) mut impl_value_values: Box({i32; MAX_IMPLS}) := {0; MAX_IMPLS};
(export wasm) mut impl_state: Box(ImplementationState) := { count = 0 };
(export wasm) mut scope_stack: Box({i32; MAX_SCOPES}) := {0; MAX_SCOPES};
mut binding_target_stack: Box({i32; MAX_SCOPES}) := {0; MAX_SCOPES};
mut scope_stack_backup: Box({i32; MAX_SCOPES}) := {0; MAX_SCOPES};
mut binding_target_stack_backup: Box({i32; MAX_SCOPES}) := {0; MAX_SCOPES};
mut intrinsic_state: Box(IntrinsicState) := { binding_count = 0 };
(export wasm) mut file_state: Box(FileState) := { count = 0 };
(export wasm) mut file_path_start: Box({i32; MAX_FILES}) := {0; MAX_FILES};
(export wasm) mut file_path_length: Box({i32; MAX_FILES}) := {0; MAX_FILES};
(export wasm) mut file_root_idx: Box({i32; MAX_FILES}) := {0; MAX_FILES};
mut file_import_value: Box({i32; MAX_FILES}) := {-1; MAX_FILES};
(export wasm) mut flow_state: Box(FlowState) := { kind = FLOW_NONE, value = -1 };
(export wasm) mut runtime_state: Box(RuntimeState) := {
    loop_depth = 0,
    function_depth = 0,
    option_enum_idx = -1,
    option_i32_enum_idx = -1,
    type_value_idx = -1,
    range_type_idx = -1
};
(export wasm) mut bind_pattern_state: Box(BindPatternState) := { value_idx = -1, inherit_mut = 0, inherit_target_mask = 0, inherit_export_mask = 0, inherit_wrap_mask = 0 };
(export wasm) mut annotation_temp: Box(AnnotationTemp) := { is_mut = 0, target_mask = 0, export_mask = 0, wrap_mask = 0 };

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

set_error: (i32 -> i32) := (pos: i32) => (
    if value_state.error == -1 then (
        value_state.error = pos;
        0
    ) else (
        0
    );
    0
);

reset_interpreter := {} => (
    value_state.count = 0;
    value_state.error = -1;
    binding_state.count = 0;
    binding_state.scope_count = 0;
    binding_temp.start = 0;
    binding_temp.length = 0;
    binding_temp.is_mut = 0;
    binding_temp.ok = 0;
    binding_target_state.depth = 0;
    binding_target_state.acc_mask = 0;
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    impl_state.count = 0;
    flow_state.kind = FLOW_NONE;
    flow_state.value = -1;
    runtime_state.loop_depth = 0;
    runtime_state.function_depth = 0;
    runtime_state.option_enum_idx = -1;
    runtime_state.option_i32_enum_idx = -1;
    runtime_state.type_value_idx = -1;
    runtime_state.range_type_idx = -1;
    bind_pattern_state.value_idx = -1;
    bind_pattern_state.inherit_mut = 0;
    bind_pattern_state.inherit_target_mask = 0;
    bind_pattern_state.inherit_export_mask = 0;
    bind_pattern_state.inherit_wrap_mask = 0;
    intrinsic_state.binding_count = 0;
    reset_import_cache{};
    0
);

(export wasm) clear_file_registry := {} => (
    file_state.count = 0;
    0
);

(export wasm) register_file := {path_start: i32, path_length: i32, root_idx: i32} => (
    if file_state.count >= MAX_FILES then (
        -1
    ) else if path_length <= 0 || root_idx < 0 then (
        -1
    ) else (
        idx := file_state.count;
        file_path_start(idx) = path_start;
        file_path_length(idx) = path_length;
        file_root_idx(idx) = root_idx;
        file_import_value(idx) = -1;
        file_state.count = idx + 1;
        idx
    )
);

reset_import_cache := {} => (
    mut idx := 0;
    while idx < file_state.count do (
        file_import_value(idx) = -1;
        idx = idx + 1;
        {}
    );
    0
);

enter_scope := {} => (
    if binding_state.scope_count >= MAX_SCOPES then (
        set_error(0);
        0
    ) else (
        scope_stack(binding_state.scope_count) = binding_state.count;
        binding_state.scope_count = binding_state.scope_count + 1;
        0
    )
);

exit_scope := {} => (
    if binding_state.scope_count <= 0 then (
        set_error(0);
        0
    ) else (
        binding_state.scope_count = binding_state.scope_count - 1;
        binding_state.count = scope_stack(binding_state.scope_count);
        0
    )
);

save_scope_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scope_stack_backup(idx) = scope_stack(idx);
        idx = idx + 1;
        {}
    );
    0
);

restore_scope_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scope_stack(idx) = scope_stack_backup(idx);
        idx = idx + 1;
        {}
    );
    0
);

save_binding_target_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        binding_target_stack_backup(idx) = binding_target_stack(idx);
        idx = idx + 1;
        {}
    );
    0
);

restore_binding_target_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        binding_target_stack(idx) = binding_target_stack_backup(idx);
        idx = idx + 1;
        {}
    );
    0
);

push_binding_target_mask := (mask: i32) => (
    if binding_target_state.depth >= MAX_SCOPES then (
        set_error(0);
        0
    ) else (
        binding_target_stack(binding_target_state.depth) = mask;
        binding_target_state.depth = binding_target_state.depth + 1;
        1
    )
);

pop_binding_target_mask := {} => (
    if binding_target_state.depth <= 0 then (
        set_error(0);
        0
    ) else (
        binding_target_state.depth = binding_target_state.depth - 1;
        1
    )
);

current_binding_target_mask := {} => (
    if binding_target_state.depth <= 0 then -1 else binding_target_stack(binding_target_state.depth - 1)
);

string_ref_equals := {left: StringRef, right: StringRef} => (
    if left.start < 0 || right.start < 0 then (
        if left.start == right.start && left.length == right.length then 1 else 0
    ) else if left.length != right.length then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left.length do (
            if input(left.start + idx) != input(right.start + idx) then (
                ok = 0;
                idx = left.length;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_equals_raw := {left_start: i32, left_len: i32, right_start: i32, right_len: i32} => (
    if left_start < 0 || right_start < 0 then (
        if left_start == right_start && left_len == right_len then 1 else (
            if left_start < 0 then (
                string_ref_equals_synthetic{left_start, left_len, right_start, right_len}
            ) else (
                string_ref_equals_synthetic{right_start, right_len, left_start, left_len}
            )
        )
    ) else if left_len != right_len then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left_len do (
            if input(left_start + idx) != input(right_start + idx) then (
                ok = 0;
                idx = left_len;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_is_mut := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_MUT_STRING.start && value.length == SYNTHETIC_MUT_STRING.length then 1 else 0
    ) else if value.length != 3 then (
        0
    ) else (
        if input(value.start) == 'm' then (
            if input(value.start + 1) == 'u' then (
                if input(value.start + 2) == 't' then 1 else 0
            ) else 0
        ) else 0
    )
);


annotation_is_mut := (idx: i32) => (
    if idx == -1 then 0 else (
        nodes(idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => 1,
                    else => 0
                }
            ),
            else => 0
        }
    )
);

annotations_has_mut := (head: i32) => (
    mut current := head;
    mut found := 0;
    while current != -1 do (
        if annotation_is_mut(list_nodes(current).value) == 1 then (
            found = 1;
            current = -1;
        ) else (
            current = list_nodes(current).next;
        );
        {}
    );
    found
);

resolve_annotation_flags := (head: i32) => (
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    mut current := head;
    mut ok := 1;
    while current != -1 do (
        ann_idx := list_nodes(current).value;
        ann_value_idx := eval_expression(ann_idx);
        if ann_value_idx == -1 then (
            ok = 0;
            current = -1;
        ) else if flow_state.kind != FLOW_NONE then (
            ok = 0;
            current = -1;
        ) else (
            if Value::BindingAnnotation(ann) := values(ann_value_idx) then (
                if ann.kind == BINDING_ANN_MUT then (
                    annotation_temp.is_mut = 1;
                    0
                ) else 0;
                if ann.kind == BINDING_ANN_TARGET then (
                    ann_mask := target_mask_from_tag(ann.target);
                    annotation_temp.target_mask = target_mask_or{annotation_temp.target_mask, ann_mask};
                    0
                ) else 0;
                if ann.kind == BINDING_ANN_EXPORT then (
                    ann_mask := target_mask_from_tag(ann.target);
                    annotation_temp.export_mask = target_mask_or{annotation_temp.export_mask, ann_mask};
                    0
                ) else 0;
                if ann.kind == BINDING_ANN_WRAP then (
                    ann_mask := target_mask_from_tag(ann.target);
                    annotation_temp.wrap_mask = target_mask_or{annotation_temp.wrap_mask, ann_mask};
                    0
                ) else 0;
                current = list_nodes(current).next;
            ) else (
                set_error(nodes(ann_idx).span.start);
                ok = 0;
                current = -1;
            )
        );
        {}
    );
    ok
);

expr_contains_mut_annotation := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::FunctionCall(info) => (
                if expr_contains_mut_annotation(info.function) == 1 then 1 else (
                    expr_contains_mut_annotation(info.argument)
                )
            ),
            else => 0
        }
    )
);

resolve_binding_from_expr: (i32 -> i32) := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_temp.start = 0;
        binding_temp.length = 0;
        binding_temp.is_mut = 0;
        binding_temp.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                binding_temp.start = id.name.start;
                binding_temp.length = id.name.length;
                binding_temp.is_mut = 0;
                binding_temp.ok = 1;
                1
            ),
            NodeKind::Operation(op) => (
                if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                    resolve_binding_from_expr(op.left)
                ) else (
                    binding_temp.start = 0;
                    binding_temp.length = 0;
                    binding_temp.is_mut = 0;
                    binding_temp.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                resolve_binding_from_expr(info.argument);
                if binding_temp.ok == 0 then (
                    0
                ) else (
                    mut_flag := expr_contains_mut_annotation(info.function);
                    binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                    binding_temp.ok = 1;
                    1
                )
            ),
            else => (
                binding_temp.start = 0;
                binding_temp.length = 0;
                binding_temp.is_mut = 0;
                binding_temp.ok = 0;
                0
            )
        }
    )
);

resolve_binding_pattern: (BindingPattern -> i32) := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Identifier(info) => (
            binding_temp.start = info.name.name.start;
            binding_temp.length = info.name.name.length;
            binding_temp.is_mut = 0;
            binding_temp.ok = 1;
            1
        ),
        BindingPattern::Annotated(info) => (
            resolve_binding_from_expr(info.pattern);
            if binding_temp.ok == 0 then (
                0
            ) else (
                mut_flag := annotations_has_mut(info.annotations);
                binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                binding_temp.ok = 1;
                1
            )
        ),
        BindingPattern::TypeHint(info) => resolve_binding_from_expr(info.pattern),
        else => (
            binding_temp.start = 0;
            binding_temp.length = 0;
            binding_temp.is_mut = 0;
            binding_temp.ok = 0;
            0
        )
    }
);

find_binding_index := (name: StringRef) => (
    mut idx := binding_state.count - 1;
    mut found := -1;
    while idx >= 0 do (
        if string_ref_equals_raw{
            binding_name_start(idx),
            binding_name_length(idx),
            name.start,
            name.length
        } == 1 then (
            found = idx;
            idx = -1;
        ) else (
            idx = idx - 1;
        );
        {}
    );
    found
);

find_file_index := (name: StringRef) => (
    mut idx := file_state.count - 1;
    mut found := -1;
    while idx >= 0 do (
        if string_ref_equals_raw{
            file_path_start(idx),
            file_path_length(idx),
            name.start,
            name.length
        } == 1 then (
            found = idx;
            idx = -1;
        ) else (
            idx = idx - 1;
        );
        {}
    );
    found
);

eval_use_from_string := {path_ref: StringRef, span_start: i32} => (
    file_idx := find_file_index(path_ref);
    if file_idx == -1 then (
        set_error(span_start);
        -1
    ) else (
        cached_idx := file_import_value(file_idx);
        if cached_idx != -1 then (
            cached_idx
        ) else (
            import_idx := eval_import_root{file_root_idx(file_idx), span_start};
            if import_idx == -1 then (
                -1
            ) else (
                file_import_value(file_idx) = import_idx;
                import_idx
            )
        )
    )
);

ensure_binding_target_access := {binding_idx: i32, span_start: i32} => (
    required_mask := binding_target_mask(binding_idx);
    if required_mask == 0 then (
        1
    ) else (
        current_mask := current_binding_target_mask{};
        if current_mask == -1 then (
            set_error(span_start);
            0
        ) else if current_mask == 0 then (
            set_error(span_start);
            0
        ) else if target_mask_allows{required_mask, current_mask} == 1 then (
            1
        ) else (
            set_error(span_start);
            0
        )
    )
);

string_ref_is_js := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_JS_STRING.start && value.length == SYNTHETIC_JS_STRING.length then 1 else 0
    ) else if value.length != 2 then (
        0
    ) else (
        if input(value.start) == 'j' then (
            if input(value.start + 1) == 's' then 1 else 0
        ) else 0
    )
);

string_ref_is_wasm := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_WASM_STRING.start && value.length == SYNTHETIC_WASM_STRING.length then 1 else 0
    ) else if value.length != 4 then (
        0
    ) else (
        if input(value.start) == 'w' then (
            if input(value.start + 1) == 'a' then (
                if input(value.start + 2) == 's' then (
                    if input(value.start + 3) == 'm' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_wgsl := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_WGSL_STRING.start && value.length == SYNTHETIC_WGSL_STRING.length then 1 else 0
    ) else if value.length != 4 then (
        0
    ) else (
        if input(value.start) == 'w' then (
            if input(value.start + 1) == 'g' then (
                if input(value.start + 2) == 's' then (
                    if input(value.start + 3) == 'l' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

ensure_asm_target_allowed := {target_tag: i32, span_start: i32} => (
    current_mask := current_binding_target_mask{};
    if current_mask == -1 then (
        set_error(span_start);
        0
    ) else if current_mask == 0 then (
        set_error(span_start);
        0
    ) else if target_mask_has{current_mask, target_tag} == 0 then (
        set_error(span_start);
        0
    ) else (
        1
    )
);

add_binding := {start: i32, length: i32, value: i32, is_mut: i32} => (
    if binding_state.count >= MAX_BINDINGS then (
        set_error(0);
        -1
    ) else (
        idx := binding_state.count;
        binding_name_start(idx) = start;
        binding_name_length(idx) = length;
        binding_values(idx) = value;
        binding_is_mut(idx) = is_mut;
        binding_type_values(idx) = -1;
        binding_target_mask(idx) = 0;
        binding_export_mask(idx) = 0;
        binding_wrap_mask(idx) = 0;
        binding_state.count = idx + 1;
        idx
    )
);

new_list_node := {value: i32, next: i32} => (
    if state.list_count >= MAX_LIST_NODES then (
        set_error(0);
        -1
    ) else (
        idx := state.list_count;
        list_nodes(idx).value = value;
        list_nodes(idx).next = next;
        state.list_count = idx + 1;
        idx
    )
);

add_intrinsic_binding := {name: StringRef} => (
    value_idx := store_value(Value::String(name));
    if value_idx == -1 then (
        -1
    ) else (
        bind_idx := add_binding{name.start, name.length, value_idx, 0};
        if bind_idx == -1 then (
            -1
        ) else (
            ensure_type_value_idx{};
            if runtime_state.type_value_idx == -1 then (
                -1
            ) else (
                value_type_values(value_idx) = runtime_state.type_value_idx;
                bind_idx
            )
        )
    )
);

add_intrinsic_binding_value := {name: StringRef, value: Value} => (
    value_idx := store_value(value);
    if value_idx == -1 then (
        -1
    ) else (
        add_binding{name.start, name.length, value_idx, 0}
    )
);

option_enum_from_type := {payload_type_idx: i32, span_start: i32} => (
    if value_is_type(payload_type_idx) == 0 then (
        set_error(span_start);
        -1
    ) else (
        start_idx := value_state.count;
        name_idx := store_value(Value::String(SYNTHETIC_SOME_STRING));
        if name_idx == -1 then (
            -1
        ) else (
            payload_idx := copy_value(payload_type_idx);
            if payload_idx == -1 then (
                -1
            ) else (
                name_idx2 := store_value(Value::String(SYNTHETIC_NONE_STRING));
                if name_idx2 == -1 then (
                    -1
                ) else (
                    payload_idx2 := store_value(Value::Unit);
                    if payload_idx2 == -1 then (
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = start_idx, count = 2 }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                )
            )
        )
    )
);

init_option_enum := {} => (
    type_bind_idx := find_binding_index(SYNTHETIC_TYPE_STRING);
    if type_bind_idx == -1 then (
        -1
    ) else (
        type_value_idx := binding_values(type_bind_idx);
        option_type_idx := option_enum_from_type{type_value_idx, 0};
        if option_type_idx == -1 then (
            -1
        ) else (
            runtime_state.option_enum_idx = option_type_idx;
            i32_bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
            if i32_bind_idx == -1 then (
                -1
            ) else (
                option_i32_idx := option_enum_from_type{binding_values(i32_bind_idx), 0};
                if option_i32_idx == -1 then (
                    -1
                ) else (
                    runtime_state.option_i32_enum_idx = option_i32_idx;
                    0
                )
            )
        )
    )
);

init_range_binding := {} => (
    i32_bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
    if i32_bind_idx == -1 then (
        -1
    ) else (
        i32_type_idx := binding_values(i32_bind_idx);
        range_type_start := value_state.count;
        name_current := store_value(Value::String(SYNTHETIC_CURRENT_STRING));
        if name_current == -1 then (
            -1
        ) else (
            current_ty := copy_value(i32_type_idx);
            if current_ty == -1 then (
                -1
            ) else (
                name_end := store_value(Value::String(SYNTHETIC_END_STRING));
                if name_end == -1 then (
                    -1
                ) else (
                    end_ty := copy_value(i32_type_idx);
                    if end_ty == -1 then (
                        -1
                    ) else (
                        name_iter_ty := store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
                        if name_iter_ty == -1 then (
                            -1
                        ) else (
                            iter_ty := copy_value(i32_type_idx);
                            if iter_ty == -1 then (
                                -1
                            ) else (
                                name_next := store_value(Value::String(SYNTHETIC_NEXT_STRING));
                                if name_next == -1 then (
                                    -1
                                ) else (
                                    next_value := store_value(Value::Builtin(BUILTIN_RANGE_NEXT));
                                    if next_value == -1 then (
                                        -1
                                    ) else (
                        raw_range_type_idx := store_value(Value::Record({
                            head = range_type_start,
                            count = 4,
                            has_named = 1
                        }));
                        if raw_range_type_idx == -1 then (
                            -1
                        ) else (
                            range_type_idx := mark_value_as_type(raw_range_type_idx);
                            if range_type_idx == -1 then (
                                -1
                            ) else if add_binding{
                                SYNTHETIC_RANGE_STRING.start,
                                SYNTHETIC_RANGE_STRING.length,
                                range_type_idx,
                                0
                            } == -1 then (
                                -1
                            ) else (
                                runtime_state.range_type_idx = range_type_idx;
                                0
                            )
                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

init_intrinsic_context := {} => (
    if add_intrinsic_binding{SYNTHETIC_TYPE_STRING} == -1 then -1 else (
        if add_intrinsic_binding{SYNTHETIC_I32_STRING} == -1 then -1 else (
            if add_intrinsic_binding{SYNTHETIC_U8_STRING} == -1 then -1 else (
                if add_intrinsic_binding{SYNTHETIC_BOOL_STRING} == -1 then -1 else (
                    if add_intrinsic_binding{SYNTHETIC_BINDING_ANNOTATION_STRING} == -1 then -1 else (
                        if add_intrinsic_binding_value{SYNTHETIC_MUT_STRING, Value::BindingAnnotation({
                            kind = BINDING_ANN_MUT,
                            target = -1
                        })} == -1 then -1 else (
                            if add_intrinsic_binding_value{SYNTHETIC_JS_STRING, Value::Target(TARGET_JS)} == -1 then -1 else (
                                if add_intrinsic_binding_value{SYNTHETIC_WASM_STRING, Value::Target(TARGET_WASM)} == -1 then -1 else (
                                    if add_intrinsic_binding_value{SYNTHETIC_WGSL_STRING, Value::Target(TARGET_WGSL)} == -1 then -1 else (
                                        if init_option_enum{} == -1 then -1 else (
                                            if init_range_binding{} == -1 then -1 else (
                                                intrinsic_state.binding_count = binding_state.count;
                                                0
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

list_append := {head: i32, value: i32} => (
    if head == -1 then (
        new_list_node{value, -1}
    ) else (
        mut cur := head;
        while list_nodes(cur).next != -1 do (
            cur = list_nodes(cur).next;
            {}
        );
        new_idx := new_list_node{value, -1};
        list_nodes(cur).next = new_idx;
        head
    )
);

extract_binding_annotations := (expr_idx: i32) => (
    mut current := expr_idx;
    mut args_head := -1;
    mut continue := 1;
    while continue == 1 do (
        if NodeKind::FunctionCall(info) := nodes(current).kind then (
            if NodeKind::FunctionCall(_) := nodes(info.function).kind then (
                args_head = new_list_node{info.argument, args_head};
                current = info.function;
            ) else (
                continue = 0;
            )
        ) else (
            continue = 0;
        );
        {}
    );
    mut head := new_list_node{current, -1};
    mut arg_cur := args_head;
    while arg_cur != -1 do (
        head = list_append{head, list_nodes(arg_cur).value};
        arg_cur = list_nodes(arg_cur).next;
        {}
    );
    head
);

string_ref_is_enum := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 4 then 0 else (
        if input(value.start) == 'e' then (
            if input(value.start + 1) == 'n' then (
                if input(value.start + 2) == 'u' then (
                    if input(value.start + 3) == 'm' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_match := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 5 then 0 else (
        if input(value.start) == 'm' then (
            if input(value.start + 1) == 'a' then (
                if input(value.start + 2) == 't' then (
                    if input(value.start + 3) == 'c' then (
                        if input(value.start + 4) == 'h' then 1 else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_use := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 3 then 0 else (
        if input(value.start) == 'u' then (
            if input(value.start + 1) == 's' then (
                if input(value.start + 2) == 'e' then 1 else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_option := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_OPTION_STRING.start && value.length == SYNTHETIC_OPTION_STRING.length then 1 else 0
    ) else if value.length != 6 then 0 else (
        if input(value.start) == 'O' then (
            if input(value.start + 1) == 'p' then (
                if input(value.start + 2) == 't' then (
                    if input(value.start + 3) == 'i' then (
                        if input(value.start + 4) == 'o' then (
                            if input(value.start + 5) == 'n' then 1 else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_some := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_SOME_STRING.start && value.length == SYNTHETIC_SOME_STRING.length then 1 else 0
    ) else if value.length != 4 then 0 else (
        if input(value.start) == 'S' then (
            if input(value.start + 1) == 'o' then (
                if input(value.start + 2) == 'm' then (
                    if input(value.start + 3) == 'e' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_none := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_NONE_STRING.start && value.length == SYNTHETIC_NONE_STRING.length then 1 else 0
    ) else if value.length != 4 then 0 else (
        if input(value.start) == 'N' then (
            if input(value.start + 1) == 'o' then (
                if input(value.start + 2) == 'n' then (
                    if input(value.start + 3) == 'e' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_iterator := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 8 then 0 else (
        if input(value.start) == 'I' then (
            if input(value.start + 1) == 't' then (
                if input(value.start + 2) == 'e' then (
                    if input(value.start + 3) == 'r' then (
                        if input(value.start + 4) == 'a' then (
                            if input(value.start + 5) == 't' then (
                                if input(value.start + 6) == 'o' then (
                                    if input(value.start + 7) == 'r' then 1 else 0
                                ) else 0
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_iter_ty := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_ITER_TY_STRING.start && value.length == SYNTHETIC_ITER_TY_STRING.length then 1 else 0
    ) else if value.length != 7 then 0 else (
        if input(value.start) == 'i' then (
            if input(value.start + 1) == 't' then (
                if input(value.start + 2) == 'e' then (
                    if input(value.start + 3) == 'r' then (
                        if input(value.start + 4) == '_' then (
                            if input(value.start + 5) == 't' then (
                                if input(value.start + 6) == 'y' then 1 else 0
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_next := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_NEXT_STRING.start && value.length == SYNTHETIC_NEXT_STRING.length then 1 else 0
    ) else if value.length != 4 then 0 else (
        if input(value.start) == 'n' then (
            if input(value.start + 1) == 'e' then (
                if input(value.start + 2) == 'x' then (
                    if input(value.start + 3) == 't' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_for_iter := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_FOR_ITER_STRING.start && value.length == SYNTHETIC_FOR_ITER_STRING.length then 1 else 0
    ) else if value.length != 10 then 0 else (
        if input(value.start) == '_' then (
            if input(value.start + 1) == '_' then (
                if input(value.start + 2) == 'f' then (
                    if input(value.start + 3) == 'o' then (
                        if input(value.start + 4) == 'r' then (
                            if input(value.start + 5) == '_' then (
                                if input(value.start + 6) == 'i' then (
                                    if input(value.start + 7) == 't' then (
                                        if input(value.start + 8) == 'e' then (
                                            if input(value.start + 9) == 'r' then 1 else 0
                                        ) else 0
                                    ) else 0
                                ) else 0
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_current := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_CURRENT_STRING.start && value.length == SYNTHETIC_CURRENT_STRING.length then 1 else 0
    ) else if value.length != 7 then 0 else (
        if input(value.start) == 'c' then (
            if input(value.start + 1) == 'u' then (
                if input(value.start + 2) == 'r' then (
                    if input(value.start + 3) == 'r' then (
                        if input(value.start + 4) == 'e' then (
                            if input(value.start + 5) == 'n' then (
                                if input(value.start + 6) == 't' then 1 else 0
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_end := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_END_STRING.start && value.length == SYNTHETIC_END_STRING.length then 1 else 0
    ) else if value.length != 3 then 0 else (
        if input(value.start) == 'e' then (
            if input(value.start + 1) == 'n' then (
                if input(value.start + 2) == 'd' then 1 else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_range := (value: StringRef) => (
    if value.start < 0 then (
        if value.start == SYNTHETIC_RANGE_STRING.start && value.length == SYNTHETIC_RANGE_STRING.length then 1 else 0
    ) else if value.length != 5 then 0 else (
        if input(value.start) == 'R' then (
            if input(value.start + 1) == 'a' then (
                if input(value.start + 2) == 'n' then (
                    if input(value.start + 3) == 'g' then (
                        if input(value.start + 4) == 'e' then 1 else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_i32 := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 3 then 0 else (
        if input(value.start) == 'i' then (
            if input(value.start + 1) == '3' then (
                if input(value.start + 2) == '2' then 1 else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_u8 := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 2 then 0 else (
        if input(value.start) == 'u' then (
            if input(value.start + 1) == '8' then 1 else 0
        ) else 0
    )
);

string_ref_is_bool := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 4 then 0 else (
        if input(value.start) == 'b' then (
            if input(value.start + 1) == 'o' then (
                if input(value.start + 2) == 'o' then (
                    if input(value.start + 3) == 'l' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_type := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 4 then 0 else (
        if input(value.start) == 't' then (
            if input(value.start + 1) == 'y' then (
                if input(value.start + 2) == 'p' then (
                    if input(value.start + 3) == 'e' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 6 then 0 else (
        if input(value.start) == 't' then (
            if input(value.start + 1) == 'a' then (
                if input(value.start + 2) == 'r' then (
                    if input(value.start + 3) == 'g' then (
                        if input(value.start + 4) == 'e' then (
                            if input(value.start + 5) == 't' then 1 else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_binding_annotation := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 18 then 0 else (
        if input(value.start) == 'b' then (
            if input(value.start + 1) == 'i' then (
                if input(value.start + 2) == 'n' then (
                    if input(value.start + 3) == 'd' then (
                        if input(value.start + 4) == 'i' then (
                            if input(value.start + 5) == 'n' then (
                                if input(value.start + 6) == 'g' then (
                                    if input(value.start + 7) == '_' then (
                                        if input(value.start + 8) == 'a' then (
                                            if input(value.start + 9) == 'n' then (
                                                if input(value.start + 10) == 'n' then (
                                                    if input(value.start + 11) == 'o' then (
                                                        if input(value.start + 12) == 't' then (
                                                            if input(value.start + 13) == 'a' then (
                                                                if input(value.start + 14) == 't' then (
                                                                    if input(value.start + 15) == 'i' then (
                                                                        if input(value.start + 16) == 'o' then (
                                                                            if input(value.start + 17) == 'n' then 1 else 0
                                                                        ) else 0
                                                                    ) else 0
                                                                ) else 0
                                                            ) else 0
                                                        ) else 0
                                                    ) else 0
                                                ) else 0
                                            ) else 0
                                        ) else 0
                                    ) else 0
                                ) else 0
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_underscore := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 1 then 0 else (
        if input(value.start) == '_' then 1 else 0
    )
);

string_ref_is_else := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 4 then 0 else (
        if input(value.start) == 'e' then (
            if input(value.start + 1) == 'l' then (
                if input(value.start + 2) == 's' then (
                    if input(value.start + 3) == 'e' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

builtin_from_identifier := (name: StringRef) => (
    if string_ref_is_enum(name) == 1 then BUILTIN_ENUM else (
        if string_ref_is_match(name) == 1 then BUILTIN_MATCH else (
            if string_ref_is_option(name) == 1 then BUILTIN_OPTION else (
                if string_ref_is_iterator(name) == 1 then BUILTIN_ITERATOR else (
                    if string_ref_is_export(name) == 1 then BUILTIN_EXPORT else (
                    if string_ref_is_target(name) == 1 then BUILTIN_TARGET else (
                        if string_ref_is_wrap(name) == 1 then BUILTIN_WRAP else (
                            if string_ref_is_asm(name) == 1 then BUILTIN_ASM else (
                                if string_ref_is_use(name) == 1 then BUILTIN_USE else -1
                            )
                        )
                    )
                )
            )
        )
        )
    )
);

string_ref_to_i32 := {start: i32, length: i32} => (
    if start < 0 then (
        -1
    ) else if length <= 0 then (
        -1
    ) else (
        mut idx := 0;
        mut acc := 0;
        mut ok := 1;
        while idx < length do (
            ch := input(start + idx);
            if ch < '0' || ch > '9' then (
                ok = 0;
                idx = length;
            ) else (
                acc = acc * 10 + (ch - '0');
                idx = idx + 1;
            );
            {}
        );
        if ok == 1 then acc else -1
    )
);

record_value_index_by_position := {start: i32, count: i32, index: i32, span_start: i32} => (
    if index < 0 then (
        set_error(span_start);
        -1
    ) else if index >= count then (
        set_error(span_start);
        -1
    ) else (
        start + index * 2 + 1
    )
);

record_find_field_index := {start: i32, count: i32, has_named: i32, name_start: i32, name_length: i32, span_start: i32} => (
    mut found := -1;
    if has_named == 1 && name_length > 0 then (
        mut idx := 0;
        while idx < count do (
            name_idx := start + idx * 2;
            if Value::String(name_ref) := values(name_idx) then (
                if string_ref_equals_raw{
                    name_ref.start,
                    name_ref.length,
                    name_start,
                    name_length
                } == 1 then (
                    found = name_idx + 1;
                    idx = count;
                ) else (
                    idx = idx + 1;
                )
            ) else (
                idx = idx + 1;
            );
            {}
        );
        0
    ) else (
        0
    );
    if found != -1 then (
        found
    ) else (
        idx_num := string_ref_to_i32{name_start, name_length};
        if idx_num < 0 then (
            set_error(span_start);
            -1
        ) else (
            record_value_index_by_position{start, count, idx_num, span_start}
        )
    )
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 6 then 0 else (
        if input(value.start) == 'e' then (
            if input(value.start + 1) == 'x' then (
                if input(value.start + 2) == 'p' then (
                    if input(value.start + 3) == 'o' then (
                        if input(value.start + 4) == 'r' then (
                            if input(value.start + 5) == 't' then 1 else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_wrap := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 4 then 0 else (
        if input(value.start) == 'w' then (
            if input(value.start + 1) == 'r' then (
                if input(value.start + 2) == 'a' then (
                    if input(value.start + 3) == 'p' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

string_ref_is_asm := (value: StringRef) => (
    if value.start < 0 then 0 else if value.length != 3 then 0 else (
        if input(value.start) == 'a' then (
            if input(value.start + 1) == 's' then (
                if input(value.start + 2) == 'm' then 1 else 0
            ) else 0
        ) else 0
    )
);

record_value_index_by_position_no_error := {start: i32, count: i32, index: i32} => (
    if index < 0 then (
        -1
    ) else if index >= count then (
        -1
    ) else (
        start + index * 2 + 1
    )
);

record_find_field_index_no_error := {start: i32, count: i32, has_named: i32, name_start: i32, name_length: i32} => (
    mut found := -1;
    if has_named == 1 && name_length > 0 then (
        mut idx := 0;
        while idx < count do (
            name_idx := start + idx * 2;
            if Value::String(name_ref) := values(name_idx) then (
                if string_ref_equals_raw{
                    name_ref.start,
                    name_ref.length,
                    name_start,
                    name_length
                } == 1 then (
                    found = name_idx + 1;
                    idx = count;
                ) else (
                    idx = idx + 1;
                )
            ) else (
                idx = idx + 1;
            );
            {}
        );
        0
    ) else (
        0
    );
    if found != -1 then (
        found
    ) else (
        idx_num := string_ref_to_i32{name_start, name_length};
        if idx_num < 0 then (
            -1
        ) else (
            record_value_index_by_position_no_error{start, count, idx_num}
        )
    )
);

resolve_lvalue_root_binding_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => find_binding_index(id.name),
            NodeKind::TypePropertyAccess(access) => resolve_lvalue_root_binding_from_expr(access.object),
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                    if call.argument == access.object then (
                        resolve_lvalue_root_binding_from_expr(access.object)
                    ) else (
                        -1
                    )
                ) else (
                    resolve_lvalue_root_binding_from_expr(call.function)
                )
            ),
            else => -1
        }
    )
);

resolve_lvalue_expr_value_index := {expr_idx: i32, span_start: i32} => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                bind_idx := find_binding_index(id.name);
                if bind_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    binding_values(bind_idx)
                )
            ),
            NodeKind::TypePropertyAccess(access) => (
                obj_idx := resolve_lvalue_expr_value_index{access.object, span_start};
                if obj_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    obj_idx
                ) else (
                    if Value::Record(struct_info) := values(obj_idx) then (
                        record_find_field_index{
                            struct_info.head,
                            struct_info.count,
                            struct_info.has_named,
                            access.property.start,
                            access.property.length,
                            span_start
                        }
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                    if call.argument == access.object then (
                        obj_idx := resolve_lvalue_expr_value_index{access.object, span_start};
                        if obj_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            obj_idx
                        ) else (
                            if Value::Record(struct_info) := values(obj_idx) then (
                                record_find_field_index{
                                    struct_info.head,
                                    struct_info.count,
                                    struct_info.has_named,
                                    access.property.start,
                                    access.property.length,
                                    span_start
                                }
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                ) else (
                    arr_idx := resolve_lvalue_expr_value_index{call.function, span_start};
                    if arr_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        arr_idx
                    ) else (
                        index_idx := eval_expression(call.argument);
                        if index_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            index_idx
                        ) else (
                            if Value::Number(index_value) := values(index_idx) then (
                                if Value::Record(struct_info) := values(arr_idx) then (
                                    record_value_index_by_position{
                                        struct_info.head,
                                        struct_info.count,
                                        index_value,
                                        span_start
                                    }
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    )
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

impl_add := {type_idx: i32, impl_idx: i32} => (
    if impl_state.count >= MAX_IMPLS then (
        set_error(0);
        -1
    ) else (
        idx := impl_state.count;
        impl_type_values(idx) = type_idx;
        impl_value_values(idx) = impl_idx;
        impl_state.count = idx + 1;
        idx
    )
);

type_values_equal := {left_idx: i32, right_idx: i32} => (
    if left_idx < 0 || right_idx < 0 then 0 else (
        if left_idx == right_idx then 1 else (
            left := values(left_idx);
            right := values(right_idx);
            if value_is_box_type_flag(left_idx) == 1 || value_is_box_type_flag(right_idx) == 1 then (
                if value_is_box_type_flag(left_idx) == 1 && value_is_box_type_flag(right_idx) == 1 then (
                    if Value::Record(lrec) := left then (
                        if Value::Record(rrec) := right then (
                            if lrec.has_named == 0 && rrec.has_named == 0 && lrec.count == 1 && rrec.count == 1 then (
                                type_values_equal{lrec.head + 1, rrec.head + 1}
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else (
                left |> match {
                    Value::String(lstr) => (
                        if Value::String(rstr) := right then (
                            string_ref_equals_raw{lstr.start, lstr.length, rstr.start, rstr.length}
                        ) else 0
                    ),
                    Value::Record(lrec) => (
                        if Value::Record(rrec) := right then (
                            if lrec.has_named == 0 && rrec.has_named == 0 && lrec.count == 1 && rrec.count == 1 then (
                                type_values_equal{lrec.head + 1, rrec.head + 1}
                            ) else 0
                        ) else 0
                    ),
                    Value::EnumType(lenum) => (
                        if Value::EnumType(renum) := right then (
                            if lenum.count != renum.count then (
                                0
                            ) else (
                                mut idx := 0;
                                mut ok := 1;
                                while idx < lenum.count do (
                                    left_name_idx := lenum.head + idx * 2;
                                    right_name_idx := renum.head + idx * 2;
                                    if Value::String(left_name) := values(left_name_idx) then (
                                        if Value::String(right_name) := values(right_name_idx) then (
                                            if string_ref_equals{left_name, right_name} == 0 then (
                                                ok = 0;
                                                idx = lenum.count;
                                            ) else (
                                                left_payload_idx := left_name_idx + 1;
                                                right_payload_idx := right_name_idx + 1;
                                                if Value::Unit := values(left_payload_idx) then (
                                                    if Value::Unit := values(right_payload_idx) then (
                                                        idx = idx + 1;
                                                    ) else (
                                                        ok = 0;
                                                        idx = lenum.count;
                                                    )
                                                ) else if Value::Unit := values(right_payload_idx) then (
                                                    ok = 0;
                                                    idx = lenum.count;
                                                ) else if type_values_equal{left_payload_idx, right_payload_idx} == 0 then (
                                                    ok = 0;
                                                    idx = lenum.count;
                                                ) else (
                                                    idx = idx + 1;
                                                )
                                            )
                                        ) else (
                                            ok = 0;
                                            idx = lenum.count;
                                        )
                                    ) else (
                                        ok = 0;
                                        idx = lenum.count;
                                    );
                                    {}
                                );
                                ok
                            )
                        ) else 0
                    ),
                    else => 0
                }
            )
        )
    )
);

impl_find := (type_idx: i32) => (
    if type_idx < 0 then (
        -1
    ) else (
        mut idx := impl_state.count - 1;
        mut found := -1;
        while idx >= 0 do (
            if impl_type_values(idx) == type_idx then (
                found = impl_value_values(idx);
                idx = -1;
            ) else if type_values_equal{impl_type_values(idx), type_idx} == 1 then (
                found = impl_value_values(idx);
                idx = -1;
            ) else (
                idx = idx - 1;
            );
            {}
        );
        found
    )
);

op_is1 := {op_start: i32, op_len: i32, ch: u8} => (
    if op_len == 1 then (
        if input(op_start) == ch then 1 else 0
    ) else 0
);

op_is2 := {op_start: i32, op_len: i32, ch1: u8, ch2: u8} => (
    if op_len == 2 then (
        if input(op_start) == ch1 then (
            if input(op_start + 1) == ch2 then 1 else 0
        ) else 0
    ) else 0
);

store_value := (value: Value) => (
    if value_state.count >= MAX_VALUES then (
        set_error(0);
        -1
    ) else (
        idx := value_state.count;
        values(idx) = value;
        value_type_values(idx) = -1;
        value_is_box_type(idx) = 0;
        value_state.count = value_state.count + 1;
        idx
    )
);

copy_value := (idx: i32) => (
    if idx == -1 then (
        -1
    ) else (
        new_idx := store_value(values(idx));
        if new_idx == -1 then (
            -1
        ) else (
            value_is_box_type(new_idx) = value_is_box_type(idx);
            if value_type_values(idx) != -1 then (
                value_type_values(new_idx) = value_type_values(idx);
                0
            ) else (
                0
            );
            new_idx
        )
    )
);

ensure_type_value_idx := {} => (
    if runtime_state.type_value_idx == -1 then (
        runtime_state.type_value_idx = store_value(Value::String(SYNTHETIC_TYPE_STRING));
        0
    ) else (
        0
    )
);

mark_value_as_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        ensure_type_value_idx{};
        if runtime_state.type_value_idx == -1 then (
            -1
        ) else (
            value_type_values(value_idx) = runtime_state.type_value_idx;
            value_idx
        )
    )
);

value_is_type_value := (type_idx: i32) => (
    if type_idx == -1 || runtime_state.type_value_idx == -1 then (
        0
    ) else (
        type_values_equal{type_idx, runtime_state.type_value_idx}
    )
);

value_is_type := (value_idx: i32) => (
    if value_idx == -1 then (
        0
    ) else (
        value_is_type_value(value_type_values(value_idx))
    )
);

block_contains_top_level_diverge := (list: ExpressionList) => (
    mut current := list.head;
    mut remaining := list.count;
    mut has_diverge := 0;
    while remaining > 0 && current != -1 && has_diverge == 0 do (
        expr_idx := list_nodes(current).value;
        if NodeKind::Diverge(_) := nodes(expr_idx).kind then (
            has_diverge = 1;
        ) else (
            current = list_nodes(current).next;
            remaining = remaining - 1;
        );
        {}
    );
    has_diverge
);

expression_branch_tag: (i32 -> i32) := (expr_idx: i32) => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(lit) => (
                lit |> match {
                    ExpressionLiteral::Number(_) => 0,
                    ExpressionLiteral::Boolean(_) => 1,
                    ExpressionLiteral::Char(_) => 2,
                    ExpressionLiteral::String(_) => 3,
                    ExpressionLiteral::Target(_) => 12,
                    ExpressionLiteral::BindingAnnotation(_) => 13
                }
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then 4 else 6
            ),
            NodeKind::Diverge(_) => -2,
            NodeKind::Block(list) => (
                if list.count <= 0 || list.head == -1 then (
                    4
                ) else if block_contains_top_level_diverge(list) == 1 then (
                    -2
                ) else (
                    mut current := list.head;
                    while list_nodes(current).next != -1 do (
                        current = list_nodes(current).next;
                        {}
                    );
                    last_idx := list_nodes(current).value;
                    nodes(last_idx).kind |> match {
                        NodeKind::Literal(last_lit) => (
                            last_lit |> match {
                                ExpressionLiteral::Number(_) => 0,
                                ExpressionLiteral::Boolean(_) => 1,
                                ExpressionLiteral::Char(_) => 2,
                                ExpressionLiteral::String(_) => 3,
                                ExpressionLiteral::Target(_) => 12,
                                ExpressionLiteral::BindingAnnotation(_) => 13
                            }
                        ),
                        NodeKind::Struct(last_struct) => (
                            if is_empty_struct(last_struct.fields) == 1 then 4 else 6
                        ),
                        NodeKind::Diverge(_) => -2,
                        else => -1
                    }
                )
            ),
            else => -1
        }
    )
);

check_if_branch_type_compat := {then_expr_idx: i32, else_expr_idx: i32, span_start: i32} => (
    then_tag := expression_branch_tag(then_expr_idx);
    else_tag := expression_branch_tag(else_expr_idx);
    if then_tag == -2 || else_tag == -2 then (
        1
    ) else if then_tag == -1 || else_tag == -1 then (
        1
    ) else if then_tag == else_tag then (
        1
    ) else (
        set_error(span_start);
        0
    )
);

mark_intrinsic_string_value_as_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        value := values(value_idx);
        if Value::String(name_ref) := value then (
            if name_ref.start < 0 then (
                if (name_ref.start == SYNTHETIC_I32_STRING.start && name_ref.length == SYNTHETIC_I32_STRING.length)
                    || (name_ref.start == SYNTHETIC_U8_STRING.start && name_ref.length == SYNTHETIC_U8_STRING.length)
                    || (name_ref.start == SYNTHETIC_BOOL_STRING.start && name_ref.length == SYNTHETIC_BOOL_STRING.length)
                    || (name_ref.start == SYNTHETIC_TYPE_STRING.start && name_ref.length == SYNTHETIC_TYPE_STRING.length)
                    || (name_ref.start == SYNTHETIC_TARGET_STRING.start && name_ref.length == SYNTHETIC_TARGET_STRING.length)
                    || (name_ref.start == SYNTHETIC_BINDING_ANNOTATION_STRING.start && name_ref.length == SYNTHETIC_BINDING_ANNOTATION_STRING.length)
                then (
                    if value_type_values(value_idx) == -1 then (
                        mark_value_as_type(value_idx)
                    ) else (
                        value_idx
                    )
                ) else (
                    value_idx
                )
            ) else (
                value_idx
            )
        ) else (
            value_idx
        )
    )
);

mark_value_as_box_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        value_is_box_type(value_idx) = 1;
        value_idx
    )
);

value_is_box_type_flag := (value_idx: i32) => (
    if value_idx == -1 then (
        0
    ) else (
        if value_is_box_type(value_idx) == 1 then 1 else (
            if Value::Record(rec_info) := values(value_idx) then (
                if rec_info.count == 1 && rec_info.has_named == 0 then (
                    if Value::String(name_ref) := values(rec_info.head) then (
                        if name_ref.start == SYNTHETIC_BOX_STRING.start && name_ref.length == SYNTHETIC_BOX_STRING.length then 1 else 0
                    ) else 0
                ) else 0
            ) else 0
        )
    )
);

is_empty_struct := (fields: i32) => (
    if fields == -1 then 1 else 0
);

target_literal_tag := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TARGET_JS,
        TargetLiteral::WasmTarget => TARGET_WASM,
        TargetLiteral::WgslTarget => TARGET_WGSL,
        else => -1
    }
);

target_mask_from_tag := (target_tag: i32) => (
    if target_tag == TARGET_JS then TARGET_MASK_JS else (
        if target_tag == TARGET_WASM then TARGET_MASK_WASM else (
            if target_tag == TARGET_WGSL then TARGET_MASK_WGSL else 0
        )
    )
);

target_mask_has := {mask: i32, target_tag: i32} => (
    if target_tag == TARGET_JS then (
        if mask == 1 || mask == 3 || mask == 5 || mask == 7 then 1 else 0
    ) else if target_tag == TARGET_WASM then (
        if mask == 2 || mask == 3 || mask == 6 || mask == 7 then 1 else 0
    ) else if target_tag == TARGET_WGSL then (
        if mask == 4 || mask == 5 || mask == 6 || mask == 7 then 1 else 0
    ) else (
        0
    )
);

target_mask_or := {left: i32, right: i32} => (
    mut result := left;
    if target_mask_has{right, TARGET_JS} == 1 && target_mask_has{result, TARGET_JS} == 0 then (
        result = result + TARGET_MASK_JS;
        0
    ) else 0;
    if target_mask_has{right, TARGET_WASM} == 1 && target_mask_has{result, TARGET_WASM} == 0 then (
        result = result + TARGET_MASK_WASM;
        0
    ) else 0;
    if target_mask_has{right, TARGET_WGSL} == 1 && target_mask_has{result, TARGET_WGSL} == 0 then (
        result = result + TARGET_MASK_WGSL;
        0
    ) else 0;
    result
);

target_mask_and := {left: i32, right: i32} => (
    mut result := 0;
    if target_mask_has{left, TARGET_JS} == 1 && target_mask_has{right, TARGET_JS} == 1 then (
        result = result + TARGET_MASK_JS;
        0
    ) else 0;
    if target_mask_has{left, TARGET_WASM} == 1 && target_mask_has{right, TARGET_WASM} == 1 then (
        result = result + TARGET_MASK_WASM;
        0
    ) else 0;
    if target_mask_has{left, TARGET_WGSL} == 1 && target_mask_has{right, TARGET_WGSL} == 1 then (
        result = result + TARGET_MASK_WGSL;
        0
    ) else 0;
    result
);

target_mask_allows := {required: i32, current: i32} => (
    if target_mask_has{current, TARGET_JS} == 1 && target_mask_has{required, TARGET_JS} == 0 then 0 else (
        if target_mask_has{current, TARGET_WASM} == 1 && target_mask_has{required, TARGET_WASM} == 0 then 0 else (
            if target_mask_has{current, TARGET_WGSL} == 1 && target_mask_has{required, TARGET_WGSL} == 0 then 0 else 1
        )
    )
);

target_mask_is_single_target := (mask: i32) => (
    if mask == TARGET_MASK_JS || mask == TARGET_MASK_WASM || mask == TARGET_MASK_WGSL then 1 else 0
);

validate_wrap_export_annotations := {value_idx: i32, export_mask: i32, wrap_mask: i32, span_start: i32} => (
    if wrap_mask == 0 then (
        1
    ) else if target_mask_is_single_target(export_mask) == 0 then (
        set_error(span_start);
        0
    ) else (
        if Value::Function(_) := values(value_idx) then (
            1
        ) else (
            if export_mask == TARGET_MASK_WASM && wrap_mask == TARGET_MASK_JS then (
                1
            ) else (
                set_error(span_start);
                0
            )
        )
    )
);

binding_annotation_from_literal := (ann: BindingAnnotationLiteral) => (
    ann |> match {
        BindingAnnotationLiteral::Mut => Value::BindingAnnotation({ kind = BINDING_ANN_MUT, target = -1 }),
        BindingAnnotationLiteral::Export(target) => Value::BindingAnnotation({
            kind = BINDING_ANN_EXPORT,
            target = target_literal_tag(target)
        }),
        BindingAnnotationLiteral::Target(target) => Value::BindingAnnotation({
            kind = BINDING_ANN_TARGET,
            target = target_literal_tag(target)
        }),
        BindingAnnotationLiteral::Wrap(target) => Value::BindingAnnotation({
            kind = BINDING_ANN_WRAP,
            target = target_literal_tag(target)
        }),
        else => Value::Unit
    }
);


eval_literal := (lit: ExpressionLiteral) => (
    lit |> match {
        ExpressionLiteral::Number(value) => Value::Number(value),
        ExpressionLiteral::Boolean(value) => Value::Boolean(value),
        ExpressionLiteral::Char(value) => Value::Char(value),
        ExpressionLiteral::String(value) => Value::String(value),
        ExpressionLiteral::Target(value) => Value::Target(target_literal_tag(value)),
        ExpressionLiteral::BindingAnnotation(value) => binding_annotation_from_literal(value),
        else => Value::Unit
    }
);

enum_variant_name_matches := {enum_head: i32, enum_count: i32, variant_idx: i32, name_start: i32, name_length: i32} => (
    if enum_head < 0 || enum_count <= 0 then (
        0
    ) else if variant_idx < enum_head || variant_idx >= enum_head + enum_count * 2 then (
        0
    ) else (
        if Value::String(stored_name) := values(variant_idx) then (
            string_ref_equals_raw{
                stored_name.start,
                stored_name.length,
                name_start,
                name_length
            }
        ) else (
            0
        )
    )
);

enum_type_matches := {left_head: i32, left_count: i32, right_head: i32, right_count: i32} => (
    if left_head < 0 || right_head < 0 then (
        0
    ) else if left_count != right_count then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left_count do (
            left_name_idx := left_head + idx * 2;
            right_name_idx := right_head + idx * 2;
            if Value::String(left_name) := values(left_name_idx) then (
                if Value::String(right_name) := values(right_name_idx) then (
                    if string_ref_equals{left_name, right_name} == 0 then (
                        ok = 0;
                        idx = left_count;
                    ) else (
                        left_payload_idx := left_head + idx * 2 + 1;
                        right_payload_idx := right_head + idx * 2 + 1;
                        mut left_has := 0;
                        mut right_has := 0;
                        if Value::Unit := values(left_payload_idx) then (
                            left_has = 0;
                        ) else (
                            left_has = 1;
                        );
                        if Value::Unit := values(right_payload_idx) then (
                            right_has = 0;
                        ) else (
                            right_has = 1;
                        );
                        if left_has != right_has then (
                            ok = 0;
                            idx = left_count;
                        ) else if left_has == 1 then (
                            if type_values_equal{left_payload_idx, right_payload_idx} == 0 then (
                                ok = 0;
                                idx = left_count;
                            ) else (
                                idx = idx + 1;
                            )
                        ) else (
                            idx = idx + 1;
                        );
                    )
                ) else (
                    ok = 0;
                    idx = left_count;
                )
            ) else (
                ok = 0;
                idx = left_count;
            );
            {}
        );
        ok
    )
);

enum_record_payloads_are_types := {enum_head: i32, enum_count: i32} => (
    if enum_head < 0 || enum_count < 0 then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < enum_count do (
            payload_idx := enum_head + idx * 2 + 1;
            payload_ok := values(payload_idx) |> match {
                Value::Number(_) => 0,
                Value::Boolean(_) => 0,
                Value::Char(_) => 0,
                else => 1
            };
            if payload_ok == 0 then (
                ok = 0;
                idx = enum_count;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

enum_value_matches_pattern_type := {enum_type_expr: i32, enum_head: i32, enum_count: i32, span_start: i32} => (
    expected_idx := eval_expression(enum_type_expr);
    if expected_idx == -1 then (
        -1
    ) else if flow_state.kind != FLOW_NONE then (
        -1
    ) else (
        if Value::EnumType(expected_enum) := values(expected_idx) then (
            enum_type_matches{
                enum_head,
                enum_count,
                expected_enum.head,
                expected_enum.count
            }
        ) else (
            set_error(span_start);
            -1
        )
    )
);

string_ref_equals_synthetic := {synthetic_start: i32, synthetic_len: i32, input_start: i32, input_len: i32} => (
    if input_start < 0 then 0 else if synthetic_len != input_len then 0 else (
        input_ref := make_string_ref{input_start, input_len};
        if synthetic_start == SYNTHETIC_MUT_STRING.start then (
            string_ref_is_mut(input_ref)
        ) else if synthetic_start == SYNTHETIC_OPTION_STRING.start then (
            string_ref_is_option(input_ref)
        ) else if synthetic_start == SYNTHETIC_SOME_STRING.start then (
            string_ref_is_some(input_ref)
        ) else if synthetic_start == SYNTHETIC_NONE_STRING.start then (
            string_ref_is_none(input_ref)
        ) else if synthetic_start == SYNTHETIC_ITER_TY_STRING.start then (
            string_ref_is_iter_ty(input_ref)
        ) else if synthetic_start == SYNTHETIC_NEXT_STRING.start then (
            string_ref_is_next(input_ref)
        ) else if synthetic_start == SYNTHETIC_FOR_ITER_STRING.start then (
            string_ref_is_for_iter(input_ref)
        ) else if synthetic_start == SYNTHETIC_CURRENT_STRING.start then (
            string_ref_is_current(input_ref)
        ) else if synthetic_start == SYNTHETIC_END_STRING.start then (
            string_ref_is_end(input_ref)
        ) else if synthetic_start == SYNTHETIC_RANGE_STRING.start then (
            string_ref_is_range(input_ref)
        ) else if synthetic_start == SYNTHETIC_BOX_STRING.start then (
            if input_ref.start < 0 then 0 else if input_ref.length != 3 then 0 else (
                if input(input_ref.start) == 'b' then (
                    if input(input_ref.start + 1) == 'o' then (
                        if input(input_ref.start + 2) == 'x' then 1 else 0
                    ) else 0
                ) else 0
            )
        ) else if synthetic_start == SYNTHETIC_I32_STRING.start then (
            string_ref_is_i32(input_ref)
        ) else if synthetic_start == SYNTHETIC_U8_STRING.start then (
            string_ref_is_u8(input_ref)
        ) else if synthetic_start == SYNTHETIC_BOOL_STRING.start then (
            string_ref_is_bool(input_ref)
        ) else if synthetic_start == SYNTHETIC_TYPE_STRING.start then (
            string_ref_is_type(input_ref)
        ) else if synthetic_start == SYNTHETIC_TARGET_STRING.start then (
            string_ref_is_target(input_ref)
        ) else if synthetic_start == SYNTHETIC_BINDING_ANNOTATION_STRING.start then (
            string_ref_is_binding_annotation(input_ref)
        ) else if synthetic_start == SYNTHETIC_JS_STRING.start then (
            string_ref_is_js(input_ref)
        ) else if synthetic_start == SYNTHETIC_WASM_STRING.start then (
            string_ref_is_wasm(input_ref)
        ) else if synthetic_start == SYNTHETIC_WGSL_STRING.start then (
            string_ref_is_wgsl(input_ref)
        ) else (
            0
        )
    )
);

span_is_underscore := {start: i32, length: i32} => (
    if start < 0 then 0 else if length != 1 then 0 else (
        if input(start) == '_' then 1 else 0
    )
);

span_is_else := {start: i32, length: i32} => (
    if start < 0 then 0 else if length != 4 then 0 else (
        if input(start) == 'e' then (
            if input(start + 1) == 'l' then (
                if input(start + 2) == 's' then (
                    if input(start + 3) == 'e' then 1 else 0
                ) else 0
            ) else 0
        ) else 0
    )
);

add_binding_if_named := {start: i32, length: i32, value_idx: i32, is_mut: i32} => (
    if length <= 0 then (
        binding_state.count
    ) else if span_is_underscore{start, length} == 1 then (
        binding_state.count
    ) else if span_is_else{start, length} == 1 then (
        binding_state.count
    ) else (
        add_binding{start, length, value_idx, is_mut}
    )
);

binding_target_mask_update := (mask: i32) => (
    if binding_target_state.acc_mask == -1 then (
        binding_target_state.acc_mask = mask;
        0
    ) else (
        binding_target_state.acc_mask = target_mask_and{binding_target_state.acc_mask, mask};
        0
    );
    1
);

binding_pattern_target_mask_expr := {pattern_expr: i32, passed_mask: i32} => (
    if pattern_expr == -1 then 1 else (
        nodes(pattern_expr).kind |> match {
            NodeKind::Identifier(_) => binding_target_mask_update(passed_mask),
            NodeKind::Literal(_) => 1,
            NodeKind::Struct(info) => (
                mut current := info.fields;
                while current != -1 do (
                    field_node := list_nodes(current).value;
                    if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                        binding_pattern_target_mask_expr{field_binding.expr, passed_mask};
                        if value_state.error != -1 then (
                            current = -1;
                        ) else (
                            current = list_nodes(current).next;
                        )
                    ) else (
                        set_error(nodes(field_node).span.start);
                        current = -1;
                    );
                    {}
                );
                1
            ),
            NodeKind::Operation(op) => (
                if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                    binding_pattern_target_mask_expr{op.left, passed_mask}
                ) else (
                    1
                )
            ),
            NodeKind::TypePropertyAccess(_) => 1,
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(_) := nodes(call.function).kind then (
                    binding_pattern_target_mask_expr{call.argument, passed_mask}
                ) else (
                    annotations := extract_binding_annotations(call.function);
                    if resolve_annotation_flags(annotations) == 0 then 0 else (
                        combined_mask := target_mask_or{passed_mask, annotation_temp.target_mask};
                        binding_pattern_target_mask_expr{call.argument, combined_mask}
                    )
                )
            ),
            else => 1
        }
    )
);

binding_pattern_target_mask := (pattern: BindingPattern) => (
    binding_target_state.acc_mask = -1;
    pattern |> match {
        BindingPattern::Identifier(_) => binding_target_mask_update(0),
        BindingPattern::Literal(_) => 1,
        BindingPattern::Struct(info) => (
            mut current := info.fields;
            while current != -1 do (
                field_node := list_nodes(current).value;
                if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                    binding_pattern_target_mask_expr{field_binding.expr, 0};
                    if value_state.error != -1 then (
                        current = -1;
                    ) else (
                        current = list_nodes(current).next;
                    )
                ) else (
                    set_error(nodes(field_node).span.start);
                    current = -1;
                );
                {}
            );
            1
        ),
        BindingPattern::EnumVariant(info) => (
            if info.payload == -1 then 1 else binding_pattern_target_mask_expr{info.payload, 0}
        ),
        BindingPattern::TypeHint(info) => binding_pattern_target_mask_expr{info.pattern, 0},
        BindingPattern::Annotated(info) => (
            if resolve_annotation_flags(info.annotations) == 0 then 0 else (
                binding_pattern_target_mask_expr{info.pattern, annotation_temp.target_mask}
            )
        ),
        else => 1
    };
    if value_state.error != -1 then -1 else (
        if binding_target_state.acc_mask == -1 then 0 else binding_target_state.acc_mask
    )
);

bind_payload_pattern := {payload_expr: i32, payload_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    mut payload_mut := inherit_mut;
    nodes(payload_expr).kind |> match {
        NodeKind::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.start, info.name.length, payload_idx, payload_mut};
            if bind_idx == -1 then (
                0
            ) else (
                binding_target_mask(bind_idx) = inherit_target_mask;
                binding_export_mask(bind_idx) = inherit_export_mask;
                binding_wrap_mask(bind_idx) = inherit_wrap_mask;
                1
            )
        ),
        NodeKind::Literal(literal) => (
            payload_value := values(payload_idx);
            literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := payload_value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        NodeKind::Operation(op) => (
            if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                bind_payload_pattern{op.left, payload_idx, payload_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
            ) else (
                0
            )
        ),
        else => 0
    }
);

bind_struct_pattern := {fields_head: i32, value_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    if fields_head == -1 then (
        if Value::Unit := values(value_idx) then (
            1
        ) else if Value::Record(rec_info) := values(value_idx) then (
            if rec_info.count == 0 then 1 else 0
        ) else (
            0
        )
    ) else if Value::Record(rec_info) := values(value_idx) then (
        start_count := binding_state.count;
        mut current := fields_head;
        mut ok := 1;
        mut positional_idx := 0;
        while current != -1 && ok == 1 do (
            field_node := list_nodes(current).value;
            if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                mut field_name := EMPTY_STRING;
                field_binding.pattern |> match {
                    BindingPattern::Identifier(id) => (field_name = id.name.name),
                    else => (field_name = EMPTY_STRING)
                };
                mut field_value_idx := -1;
                if field_name.length <= 0 then (
                    field_value_idx = record_value_index_by_position_no_error{
                        rec_info.head,
                        rec_info.count,
                        positional_idx
                    };
                    positional_idx = positional_idx + 1;
                ) else (
                    field_value_idx = record_find_field_index_no_error{
                        rec_info.head,
                        rec_info.count,
                        rec_info.has_named,
                        field_name.start,
                        field_name.length
                    };
                );
                if field_value_idx == -1 then (
                    ok = 0;
                ) else (
                    if bind_pattern_expr{field_binding.expr, field_value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask} == 0 then (
                        ok = 0;
                    ) else (
                        current = list_nodes(current).next;
                    )
                )
            ) else (
                ok = 0;
            );
            {}
        );
        if ok == 0 then (
            binding_state.count = start_count;
            0
        ) else (
            1
        )
    ) else (
        0
    )
);

bind_pattern_expr := {pattern_expr: i32, value_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    nodes(pattern_expr).kind |> match {
        NodeKind::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.start, info.name.length, value_idx, inherit_mut};
            if bind_idx >= 0 then (
                binding_target_mask(bind_idx) = inherit_target_mask;
                binding_export_mask(bind_idx) = inherit_export_mask;
                binding_wrap_mask(bind_idx) = inherit_wrap_mask;
                0
            ) else 0;
            if value_type_values(value_idx) != -1 then (
                if info.name.length > 0 && span_is_underscore{info.name.start, info.name.length} == 0 && span_is_else{info.name.start, info.name.length} == 0 then (
                    if bind_idx >= 0 then (
                        binding_type_values(bind_idx) = value_type_values(value_idx);
                        0
                    ) else 0
                ) else 0
            ) else 0;
            if bind_idx == -1 then 0 else 1
        ),
        NodeKind::Literal(literal) => (
            value := values(value_idx);
            literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        NodeKind::Struct(info) => bind_struct_pattern{info.fields, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask},
        NodeKind::Operation(op) => (
            if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                bind_pattern_expr{op.left, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
            ) else (
                0
            )
        ),
        NodeKind::TypePropertyAccess(info: TypePropertyAccessInfo) => (
            if Value::Enum(enum_info) := values(value_idx) then (
                type_matches := enum_value_matches_pattern_type{
                    info.object,
                    enum_info.enum_head,
                    enum_info.enum_count,
                    nodes(pattern_expr).span.start
                };
                if type_matches == -1 then (
                    0
                ) else if type_matches == 0 then (
                    0
                ) else (
                    if enum_variant_name_matches{
                        enum_info.enum_head,
                        enum_info.enum_count,
                        enum_info.variant_idx,
                        info.property.start,
                        info.property.length
                    } == 1 then (
                        if enum_info.payload == -1 then 1 else 0
                    ) else (
                        0
                    )
                )
            ) else (
                0
            )
        ),
        NodeKind::FunctionCall(call) => (
            if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                if Value::Enum(enum_info) := values(value_idx) then (
                    type_matches := enum_value_matches_pattern_type{
                        access.object,
                        enum_info.enum_head,
                        enum_info.enum_count,
                        nodes(pattern_expr).span.start
                    };
                    if type_matches == -1 then (
                        0
                    ) else if type_matches == 0 then (
                        0
                    ) else (
                        if enum_variant_name_matches{
                            enum_info.enum_head,
                            enum_info.enum_count,
                            enum_info.variant_idx,
                            access.property.start,
                            access.property.length
                        } == 1 then (
                            if enum_info.payload == -1 then 0 else (
                                bind_payload_pattern{call.argument, enum_info.payload, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
                            )
                        ) else (
                            0
                        )
                    )
                ) else (
                    0
                )
            ) else (
                annotations := extract_binding_annotations(call.function);
                if resolve_annotation_flags(annotations) == 0 then 0 else (
                    mut_flag := if annotation_temp.is_mut == 1 || inherit_mut == 1 then 1 else 0;
                    combined_mask := target_mask_or{inherit_target_mask, annotation_temp.target_mask};
                    combined_export_mask := target_mask_or{inherit_export_mask, annotation_temp.export_mask};
                    combined_wrap_mask := target_mask_or{inherit_wrap_mask, annotation_temp.wrap_mask};
                    if validate_wrap_export_annotations{
                        value_idx,
                        combined_export_mask,
                        combined_wrap_mask,
                        nodes(pattern_expr).span.start
                    } == 0 then (
                        0
                    ) else (
                        bind_pattern_expr{call.argument, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                    )
                )
            )
        ),
        else => 0
    }
);

bind_pattern_simple: (BindingPattern -> i32) := (pattern: BindingPattern) => (
    value_idx := bind_pattern_state.value_idx;
    inherit_mut := bind_pattern_state.inherit_mut;
    inherit_target_mask := bind_pattern_state.inherit_target_mask;
    inherit_export_mask := bind_pattern_state.inherit_export_mask;
    inherit_wrap_mask := bind_pattern_state.inherit_wrap_mask;
    start_count := binding_state.count;
    matched := pattern |> match {
        BindingPattern::Annotated(info) => (
            if resolve_annotation_flags(info.annotations) == 0 then (
                0
            ) else (
                mut_flag := if annotation_temp.is_mut == 1 || inherit_mut == 1 then 1 else 0;
                combined_mask := target_mask_or{inherit_target_mask, annotation_temp.target_mask};
                combined_export_mask := target_mask_or{inherit_export_mask, annotation_temp.export_mask};
                combined_wrap_mask := target_mask_or{inherit_wrap_mask, annotation_temp.wrap_mask};
                if validate_wrap_export_annotations{
                    value_idx,
                    combined_export_mask,
                    combined_wrap_mask,
                    nodes(info.pattern).span.start
                } == 0 then (
                    0
                ) else (
                    if NodeKind::Operation(op) := nodes(info.pattern).kind then (
                        if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                            type_idx := eval_expression(op.right);
                            if type_idx == -1 then (
                                0
                            ) else (
                                if flow_state.kind != FLOW_NONE then (
                                    0
                                ) else (
                                    resolve_binding_from_expr(op.left);
                                    name_ok := binding_temp.ok;
                                    name_start := binding_temp.start;
                                    name_len := binding_temp.length;
                                    matched := bind_pattern_expr{op.left, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask};
                                    if matched == 1 && name_ok == 1 then (
                                        bind_name := make_string_ref{name_start, name_len};
                                        bind_idx := find_binding_index(bind_name);
                                        if bind_idx != -1 then (
                                            existing_type := value_type_values(value_idx);
                                            if existing_type == -1 then (
                                                binding_type_values(bind_idx) = type_idx;
                                                value_type_values(value_idx) = type_idx;
                                                0
                                            ) else (
                                                binding_type_values(bind_idx) = existing_type;
                                                0
                                            )
                                        ) else (
                                            0
                                        )
                                    ) else (
                                        0
                                    );
                                    matched
                                )
                            )
                        ) else (
                            bind_pattern_expr{info.pattern, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                        )
                    ) else (
                        bind_pattern_expr{info.pattern, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                    )
                )
            )
        ),
        BindingPattern::TypeHint(info) => (
            type_idx := eval_expression(info.type_expr);
            if type_idx == -1 then (
                0
            ) else if flow_state.kind != FLOW_NONE then (
                0
            ) else (
                resolve_binding_from_expr(info.pattern);
                name_ok := binding_temp.ok;
                name_start := binding_temp.start;
                name_len := binding_temp.length;
                matched := bind_pattern_expr{info.pattern, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask};
                if matched == 1 && name_ok == 1 then (
                    bind_name := make_string_ref{name_start, name_len};
                    bind_idx := find_binding_index(bind_name);
                    if bind_idx != -1 then (
                        existing_type := value_type_values(value_idx);
                        if existing_type == -1 then (
                            binding_type_values(bind_idx) = type_idx;
                            value_type_values(value_idx) = type_idx;
                            0
                        ) else (
                            binding_type_values(bind_idx) = existing_type;
                            0
                        )
                    ) else (
                        0
                    )
                ) else (
                    0
                );
                matched
            )
        ),
        BindingPattern::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.name.start, info.name.name.length, value_idx, inherit_mut};
            if value_type_values(value_idx) != -1 then (
                if info.name.name.length > 0 && span_is_underscore{info.name.name.start, info.name.name.length} == 0 && span_is_else{info.name.name.start, info.name.name.length} == 0 then (
                    if bind_idx >= 0 then (
                        binding_type_values(bind_idx) = value_type_values(value_idx);
                        0
                    ) else 0
                ) else 0
            ) else 0;
            if bind_idx == -1 then 0 else 1
        ),
        BindingPattern::Literal(info) => (
            value := values(value_idx);
            info.literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        BindingPattern::EnumVariant(info) => (
            if Value::Enum(enum_info) := values(value_idx) then (
                type_matches := enum_value_matches_pattern_type{
                    info.enum_type,
                    enum_info.enum_head,
                    enum_info.enum_count,
                    info.span.start
                };
                if type_matches == -1 then (
                    0
                ) else if type_matches == 0 then (
                    0
                ) else (
                    if enum_variant_name_matches{
                        enum_info.enum_head,
                        enum_info.enum_count,
                        enum_info.variant_idx,
                        info.variant.name.start,
                        info.variant.name.length
                    } == 1 then (
                        if info.payload == -1 then (
                            if enum_info.payload == -1 then 1 else 0
                        ) else (
                            if enum_info.payload == -1 then 0 else (
                                bind_payload_pattern{info.payload, enum_info.payload, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
                            )
                        )
                    ) else (
                        0
                    )
                )
            ) else (
                0
            )
        ),
        BindingPattern::Struct(info) => bind_struct_pattern{info.fields, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask},
        else => 0
    };
    if matched == 0 then (
        binding_state.count = start_count;
        0
    ) else (
        1
    )
);

apply_function_value := {func_idx: i32, arg_idx: i32, span_start: i32} => (
    func_val := values(func_idx);
    func_val |> match {
        Value::String(string_value) => (
            if Value::Number(index_value) := values(arg_idx) then (
                if index_value < 0 || index_value >= string_value.length then (
                    set_error(span_start);
                    -1
                ) else if string_value.start < 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    store_value(Value::Char(input(string_value.start + index_value) + 0))
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::Function(fn_node) => (
            if NodeKind::Function(fn_info) := nodes(fn_node).kind then (
                runtime_state.function_depth = runtime_state.function_depth + 1;
                enter_scope{};
                bind_pattern_state.value_idx = arg_idx;
                bind_pattern_state.inherit_mut = 0;
                bind_pattern_state.inherit_target_mask = 0;
                bind_pattern_state.inherit_export_mask = 0;
                bind_pattern_state.inherit_wrap_mask = 0;
                bind_ok := bind_pattern_simple(fn_info.parameter);
                mut result_idx := -1;
                if bind_ok == 0 then (
                    set_error(span_start);
                    result_idx = -1;
                ) else (
                    result_idx = eval_expression(fn_info.body);
                    if flow_state.kind == FLOW_RETURN then (
                        result_idx = flow_state.value;
                        flow_state.kind = FLOW_NONE;
                        flow_state.value = -1;
                    );
                );
                exit_scope{};
                runtime_state.function_depth = runtime_state.function_depth - 1;
                result_idx
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::EnumConstructor(enum_ctor) => (
            if enum_ctor.expects_payload == 0 then (
                store_value(Value::Enum({
                    enum_head = enum_ctor.enum_head,
                    enum_count = enum_ctor.enum_count,
                    variant_idx = enum_ctor.variant_idx,
                    payload = -1
                }))
            ) else (
                store_value(Value::Enum({
                    enum_head = enum_ctor.enum_head,
                    enum_count = enum_ctor.enum_count,
                    variant_idx = enum_ctor.variant_idx,
                    payload = arg_idx
                }))
            )
        ),
        Value::MatchFunction(match_info) => (
            mut matched := 0;
            mut result_idx := -1;
            mut branch_idx := 0;
            while branch_idx < match_info.count && matched == 0 do (
                branch_value_idx := match_info.head + branch_idx * 2 + 1;
                if Value::Function(branch_fn_node) := values(branch_value_idx) then (
                    if NodeKind::Function(branch_fn) := nodes(branch_fn_node).kind then (
                        enter_scope{};
                        bind_pattern_state.value_idx = arg_idx;
                        bind_pattern_state.inherit_mut = 0;
                        bind_pattern_state.inherit_target_mask = 0;
                        bind_pattern_state.inherit_export_mask = 0;
                        bind_pattern_state.inherit_wrap_mask = 0;
                        if bind_pattern_simple(branch_fn.parameter) == 1 then (
                            matched = 1;
                            runtime_state.function_depth = runtime_state.function_depth + 1;
                            result_idx = eval_expression(branch_fn.body);
                            if flow_state.kind == FLOW_RETURN then (
                                result_idx = flow_state.value;
                                flow_state.kind = FLOW_NONE;
                                flow_state.value = -1;
                            );
                            runtime_state.function_depth = runtime_state.function_depth - 1;
                            0
                        ) else (
                            0
                        );
                        exit_scope{};
                    ) else (
                        set_error(span_start);
                        matched = 1;
                        result_idx = -1;
                    )
                ) else (
                    set_error(span_start);
                    matched = 1;
                    result_idx = -1;
                );
                if matched == 0 then (
                    branch_idx = branch_idx + 1;
                    0
                ) else (
                    0
                );
                {}
            );
            if matched == 0 then (
                set_error(span_start);
                -1
            ) else (
                result_idx
            )
        ),
        Value::Builtin(builtin_id) => (
            if builtin_id == BUILTIN_ENUM then (
                if Value::Record(rec_info) := values(arg_idx) then (
                    if rec_info.has_named == 0 then (
                        set_error(span_start);
                        -1
                    ) else if enum_record_payloads_are_types{rec_info.head, rec_info.count} == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = rec_info.head, count = rec_info.count }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == BUILTIN_MATCH then (
                if Value::Record(rec_info) := values(arg_idx) then (
                    store_value(Value::MatchFunction({ head = rec_info.head, count = rec_info.count }))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == BUILTIN_OPTION then (
                option_enum_idx := option_enum_from_type{arg_idx, span_start};
                if option_enum_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    option_enum_idx
                )
            ) else if builtin_id == BUILTIN_ITERATOR then (
                if runtime_state.option_enum_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    type_bind_idx := find_binding_index(SYNTHETIC_TYPE_STRING);
                    if type_bind_idx == -1 then (
                        set_error(span_start);
                        -1
                    ) else (
                        start_idx := value_state.count;
                        name_idx := store_value(Value::String(SYNTHETIC_BOX_STRING));
                    if name_idx == -1 then (
                        -1
                    ) else (
                        param_idx := store_value(values(arg_idx));
                        if param_idx == -1 then (
                            -1
                        ) else (
                            name_idx2 := store_value(Value::String(EMPTY_STRING));
                            if name_idx2 == -1 then (
                                -1
                            ) else (
                                ret_idx := store_value(values(runtime_state.option_enum_idx));
                                if ret_idx == -1 then (
                                    -1
                                ) else (
                                    fn_type_idx := store_value(Value::Record({ head = start_idx, count = 2, has_named = 0 }));
                                    if fn_type_idx == -1 then (
                                        -1
                                    ) else (
                                        if mark_value_as_type(fn_type_idx) == -1 then (
                                            -1
                                        ) else (
                                        struct_start := value_state.count;
                                        name_idx3 := store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
                                        if name_idx3 == -1 then (
                                            -1
                                        ) else (
                                            iter_ty_idx := copy_value(binding_values(type_bind_idx));
                                            if iter_ty_idx == -1 then (
                                                -1
                                            ) else (
                                                name_idx4 := store_value(Value::String(SYNTHETIC_NEXT_STRING));
                                                if name_idx4 == -1 then (
                                                    -1
                                                ) else (
                                                    next_idx := store_value(values(fn_type_idx));
                                                    if next_idx == -1 then (
                                                        -1
                                                    ) else (
                                                        iter_idx := store_value(Value::Record({ head = struct_start, count = 2, has_named = 1 }));
                                                        if iter_idx == -1 then (
                                                            -1
                                                        ) else (
                                                            mark_value_as_type(iter_idx)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    )
                )
            ) else if builtin_id == BUILTIN_EXPORT || builtin_id == BUILTIN_TARGET || builtin_id == BUILTIN_WRAP then (
                if Value::Target(target_tag) := values(arg_idx) then (
                    if builtin_id == BUILTIN_WRAP && target_tag == TARGET_WGSL then (
                        set_error(span_start);
                        -1
                    ) else (
                        kind := if builtin_id == BUILTIN_EXPORT then BINDING_ANN_EXPORT else (
                            if builtin_id == BUILTIN_TARGET then BINDING_ANN_TARGET else BINDING_ANN_WRAP
                        );
                        store_value(Value::BindingAnnotation({ kind = kind, target = target_tag }))
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == BUILTIN_ASM then (
                if Value::Target(target_tag) := values(arg_idx) then (
                    store_value(Value::AsmFunction(target_tag))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == BUILTIN_USE then (
                if Value::String(path_ref) := values(arg_idx) then (
                    eval_use_from_string{path_ref, span_start}
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == BUILTIN_RANGE_NEXT then (
                if Value::Record(range_info) := values(arg_idx) then (
                    if range_info.count < 2 then (
                        set_error(span_start);
                        -1
                    ) else (
                        current_idx := range_info.head + 1;
                        end_idx := range_info.head + 3;
                        if Value::Number(curr) := values(current_idx) then (
                            if Value::Number(end_val) := values(end_idx) then (
                                if curr < end_val then (
                                    payload_idx := store_value(Value::Number(curr));
                                    if payload_idx == -1 then (
                                        -1
                                    ) else (
                                        values(current_idx) = Value::Number(curr + 1);
                                        if runtime_state.option_i32_enum_idx == -1 then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            if Value::EnumType(enum_info) := values(runtime_state.option_i32_enum_idx) then (
                                                variant_idx := enum_info.head;
                                                store_value(Value::Enum({
                                                    enum_head = enum_info.head,
                                                    enum_count = enum_info.count,
                                                    variant_idx = variant_idx,
                                                    payload = payload_idx
                                                }))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        )
                                    )
                                ) else (
                                    if runtime_state.option_i32_enum_idx == -1 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        if Value::EnumType(enum_info) := values(runtime_state.option_i32_enum_idx) then (
                                            variant_idx := enum_info.head + 2;
                                            store_value(Value::Enum({
                                                enum_head = enum_info.head,
                                                enum_count = enum_info.count,
                                                variant_idx = variant_idx,
                                                payload = -1
                                            }))
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::AsmFunction(target_tag) => (
            if ensure_asm_target_allowed{target_tag, span_start} == 0 then (
                -1
            ) else if Value::String(code_ref) := values(arg_idx) then (
                store_value(Value::InlineAssembly({ target = target_tag, code = code_ref }))
            ) else (
                set_error(span_start);
                -1
            )
        ),
        else => (
            set_error(span_start);
            -1
        )
    }
);

apply_impl_method := {object_idx: i32, object_expr: i32, property: StringRef, span_start: i32} => (
    mut type_idx := -1;
    if NodeKind::Identifier(id) := nodes(object_expr).kind then (
        bind_idx := find_binding_index(id.name);
        if bind_idx != -1 then (
            type_idx = binding_type_values(bind_idx);
            0
        ) else 0;
        0
    ) else 0;
    if type_idx == -1 then (
        if object_idx != -1 then (
            type_idx = value_type_values(object_idx);
            0
        ) else 0
    ) else 0;
    if type_idx == -1 then (
        set_error(span_start);
        -1
    ) else (
        impl_idx := impl_find(type_idx);
        if impl_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            if Value::Record(impl_info) := values(impl_idx) then (
                method_idx := record_find_field_index_no_error{
                    impl_info.head,
                    impl_info.count,
                    impl_info.has_named,
                    property.start,
                    property.length
                };
                if method_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    apply_function_value{method_idx, object_idx, span_start}
                )
            ) else (
                set_error(span_start);
                -1
            )
        )
    )
);

apply_impl_property := {object_expr: i32, object_value_idx: i32, property_start: i32, property_length: i32, span_start: i32} => (
    mut type_idx := -1;
    if NodeKind::Identifier(id) := nodes(object_expr).kind then (
        bind_idx := find_binding_index(id.name);
        if bind_idx != -1 then (
            type_idx = binding_type_values(bind_idx);
            0
        ) else 0;
        0
    ) else 0;
    if type_idx == -1 then (
        if object_value_idx != -1 then (
            type_idx = value_type_values(object_value_idx);
            0
        ) else 0
    ) else 0;
    if type_idx == -1 then (
        set_error(span_start);
        -1
    ) else (
        impl_idx := impl_find(type_idx);
        if impl_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            if Value::Record(impl_info) := values(impl_idx) then (
                field_idx := record_find_field_index_no_error{
                    impl_info.head,
                    impl_info.count,
                    impl_info.has_named,
                    property_start,
                    property_length
                };
                if field_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    field_idx
                )
            ) else (
                set_error(span_start);
                -1
            )
        )
    )
);

eval_import_root := {root_idx: i32, span_start: i32} => (
    saved_binding_count := binding_state.count;
    saved_scope_count := binding_state.scope_count;
    saved_binding_target_depth := binding_target_state.depth;
    saved_binding_target_acc := binding_target_state.acc_mask;
    saved_flow_kind := flow_state.kind;
    saved_flow_value := flow_state.value;
    saved_loop_depth := runtime_state.loop_depth;
    saved_function_depth := runtime_state.function_depth;
    saved_bind_value := bind_pattern_state.value_idx;
    saved_bind_inherit_mut := bind_pattern_state.inherit_mut;
    saved_bind_inherit_target := bind_pattern_state.inherit_target_mask;
    saved_bind_inherit_export := bind_pattern_state.inherit_export_mask;
    saved_bind_inherit_wrap := bind_pattern_state.inherit_wrap_mask;
    saved_ann_mut := annotation_temp.is_mut;
    saved_ann_target := annotation_temp.target_mask;
    saved_ann_export := annotation_temp.export_mask;
    saved_ann_wrap := annotation_temp.wrap_mask;
    saved_temp_start := binding_temp.start;
    saved_temp_length := binding_temp.length;
    saved_temp_is_mut := binding_temp.is_mut;
    saved_temp_ok := binding_temp.ok;

    save_scope_stack(saved_scope_count);
    save_binding_target_stack(saved_binding_target_depth);

    binding_state.count = intrinsic_state.binding_count;
    binding_state.scope_count = 0;
    binding_target_state.depth = 0;
    binding_target_state.acc_mask = 0;
    flow_state.kind = FLOW_NONE;
    flow_state.value = -1;
    runtime_state.loop_depth = 0;
    runtime_state.function_depth = 0;
    bind_pattern_state.value_idx = -1;
    bind_pattern_state.inherit_mut = 0;
    bind_pattern_state.inherit_target_mask = 0;
    bind_pattern_state.inherit_export_mask = 0;
    bind_pattern_state.inherit_wrap_mask = 0;
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    binding_temp.start = 0;
    binding_temp.length = 0;
    binding_temp.is_mut = 0;
    binding_temp.ok = 0;

    enter_scope{};
    mut result_idx := eval_expression(root_idx);
    if flow_state.kind != FLOW_NONE then (
        flow_state.kind = FLOW_NONE;
        flow_state.value = -1;
        set_error(span_start);
        result_idx = -1;
        0
    ) else (
        0
    );
    exit_scope{};

    binding_state.count = saved_binding_count;
    binding_state.scope_count = saved_scope_count;
    restore_scope_stack(saved_scope_count);
    binding_target_state.depth = saved_binding_target_depth;
    binding_target_state.acc_mask = saved_binding_target_acc;
    restore_binding_target_stack(saved_binding_target_depth);
    flow_state.kind = saved_flow_kind;
    flow_state.value = saved_flow_value;
    runtime_state.loop_depth = saved_loop_depth;
    runtime_state.function_depth = saved_function_depth;
    bind_pattern_state.value_idx = saved_bind_value;
    bind_pattern_state.inherit_mut = saved_bind_inherit_mut;
    bind_pattern_state.inherit_target_mask = saved_bind_inherit_target;
    bind_pattern_state.inherit_export_mask = saved_bind_inherit_export;
    bind_pattern_state.inherit_wrap_mask = saved_bind_inherit_wrap;
    annotation_temp.is_mut = saved_ann_mut;
    annotation_temp.target_mask = saved_ann_target;
    annotation_temp.export_mask = saved_ann_export;
    annotation_temp.wrap_mask = saved_ann_wrap;
    binding_temp.start = saved_temp_start;
    binding_temp.length = saved_temp_length;
    binding_temp.is_mut = saved_temp_is_mut;
    binding_temp.ok = saved_temp_ok;

    result_idx
);

eval_expression: (i32 -> i32) := (idx: i32) => (
    if value_state.error != -1 then (
        -1
    ) else if flow_state.kind != FLOW_NONE then (
        flow_state.value
    ) else (
        span_start := nodes(idx).span.start;
        nodes(idx).kind |> match {
            NodeKind::Literal(lit) => store_value(eval_literal(lit)),
            NodeKind::IntrinsicType(ty) => (
                ty |> match {
                    IntrinsicType::I32 => (
                        value_idx := store_value(Value::String(SYNTHETIC_I32_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::U8 => (
                        value_idx := store_value(Value::String(SYNTHETIC_U8_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Boolean => (
                        value_idx := store_value(Value::String(SYNTHETIC_BOOL_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Type => (
                        value_idx := store_value(Value::String(SYNTHETIC_TYPE_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Target => (
                        value_idx := store_value(Value::String(SYNTHETIC_TARGET_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::BindingAnnotation => (
                        value_idx := store_value(Value::String(SYNTHETIC_BINDING_ANNOTATION_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Identifier(id) => (
                binding_idx := find_binding_index(id.name);
                if binding_idx == -1 then (
                    builtin := builtin_from_identifier(id.name);
                    if builtin != -1 then (
                        store_value(Value::Builtin(builtin))
                    ) else (
                        set_error(span_start);
                        -1
                    )
                ) else (
                    if ensure_binding_target_access{binding_idx, span_start} == 0 then (
                        -1
                    ) else (
                        binding_values(binding_idx)
                    )
                )
            ),
            NodeKind::Binding(binding) => (
                target_mask := binding_pattern_target_mask(binding.pattern);
                if target_mask == -1 then (
                    -1
                ) else if push_binding_target_mask(target_mask) == 0 then (
                    -1
                ) else (
                    value_idx := eval_expression(binding.expr);
                    pop_binding_target_mask{};
                    if value_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        value_idx
                    ) else (
                        bind_pattern_state.value_idx = value_idx;
                        bind_pattern_state.inherit_mut = 0;
                        bind_pattern_state.inherit_target_mask = 0;
                        bind_pattern_state.inherit_export_mask = 0;
                        bind_pattern_state.inherit_wrap_mask = 0;
                        matched := bind_pattern_simple(binding.pattern);
                        if matched == 1 then (
                            store_value(Value::Boolean(1))
                        ) else (
                            store_value(Value::Boolean(0))
                        )
                    )
                )
            ),
            NodeKind::Assignment(info) => (
                value_idx := eval_expression(info.expr);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    info.target |> match {
                        LValue::Identifier(target_info) => (
                            idx := find_binding_index(target_info.name.name);
                            if idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{idx, span_start} == 0 then (
                                -1
                            ) else if binding_is_mut(idx) == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                binding_values(idx) = value_idx;
                                if binding_type_values(idx) != -1 then (
                                    value_type_values(value_idx) = binding_type_values(idx);
                                    0
                                ) else (
                                    0
                                );
                                value_idx
                            )
                        ),
                        LValue::TypePropertyAccess(target_info) => (
                            root_idx := resolve_lvalue_root_binding_from_expr(target_info.object);
                            if root_idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{root_idx, span_start} == 0 then (
                                -1
                            ) else if binding_is_mut(root_idx) == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                obj_idx := resolve_lvalue_expr_value_index{target_info.object, span_start};
                                if flow_state.kind != FLOW_NONE then (
                                    flow_state.value
                                ) else if obj_idx == -1 then (
                                    -1
                                ) else (
                                    if Value::Record(struct_info) := values(obj_idx) then (
                                        field_idx := record_find_field_index{
                                            struct_info.head,
                                            struct_info.count,
                                            struct_info.has_named,
                                            target_info.property.start,
                                            target_info.property.length,
                                            span_start
                                        };
                                        if field_idx == -1 then (
                                            -1
                                        ) else (
                                            values(field_idx) = values(value_idx);
                                            value_type_values(field_idx) = value_type_values(value_idx);
                                            value_is_box_type(field_idx) = value_is_box_type(value_idx);
                                            value_idx
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                )
                            )
                        ),
                        LValue::ArrayIndex(target_info) => (
                            root_idx := resolve_lvalue_root_binding_from_expr(target_info.array);
                            if root_idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{root_idx, span_start} == 0 then (
                                -1
                            ) else if binding_is_mut(root_idx) == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                arr_idx := resolve_lvalue_expr_value_index{target_info.array, span_start};
                                if flow_state.kind != FLOW_NONE then (
                                    flow_state.value
                                ) else if arr_idx == -1 then (
                                    -1
                                ) else (
                                    index_idx := eval_expression(target_info.index);
                                    if index_idx == -1 then (
                                        -1
                                    ) else if flow_state.kind != FLOW_NONE then (
                                        flow_state.value
                                    ) else (
                                        if Value::Number(index_value) := values(index_idx) then (
                                            if Value::Record(struct_info) := values(arr_idx) then (
                                                field_idx := record_value_index_by_position{
                                                    struct_info.head,
                                                    struct_info.count,
                                                    index_value,
                                                    span_start
                                                };
                                                if field_idx == -1 then (
                                                    -1
                                                ) else (
                                                    values(field_idx) = values(value_idx);
                                                    value_type_values(field_idx) = value_type_values(value_idx);
                                                    value_is_box_type(field_idx) = value_is_box_type(value_idx);
                                                    value_idx
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                )
                            )
                        ),
                        else => (
                            set_error(span_start);
                            -1
                        )
                    }
                )
            ),
            NodeKind::Function(_) => (
                store_value(Value::Function(idx))
            ),
            NodeKind::BoxType(inner_idx) => (
                inner_value_idx := eval_expression(inner_idx);
                if inner_value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    inner_value_idx
                ) else if value_is_type(inner_value_idx) == 0 then (
                    set_error(span_start);
                    -1
                ) else if value_is_box_type_flag(inner_value_idx) == 1 then (
                    set_error(span_start);
                    -1
                ) else (
                    start_idx := value_state.count;
                    name_idx := store_value(Value::String(SYNTHETIC_BOX_STRING));
                    if name_idx == -1 then (
                        -1
                    ) else (
                        val_idx := store_value(values(inner_value_idx));
                        if val_idx == -1 then (
                            -1
                        ) else (
                            box_idx := store_value(Value::Record({ head = start_idx, count = 1, has_named = 0 }));
                            if box_idx == -1 then (
                                -1
                            ) else (
                                mark_value_as_box_type(box_idx);
                                mark_value_as_type(box_idx)
                            )
                        )
                    )
                )
            ),
            NodeKind::FunctionType(info) => (
                param_value_idx := eval_expression(info.parameter);
                if param_value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    param_value_idx
                ) else if value_is_type(param_value_idx) == 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    ret_value_idx := eval_expression(info.return_type);
                    if ret_value_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        ret_value_idx
                    ) else if value_is_type(ret_value_idx) == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        start_idx := value_state.count;
                        name_idx := store_value(Value::String(EMPTY_STRING));
                        if name_idx == -1 then (
                            -1
                        ) else (
                            param_idx := store_value(values(param_value_idx));
                            if param_idx == -1 then (
                                -1
                            ) else (
                                name_idx2 := store_value(Value::String(EMPTY_STRING));
                                if name_idx2 == -1 then (
                                    -1
                                ) else (
                                    ret_idx := store_value(values(ret_value_idx));
                                    if ret_idx == -1 then (
                                        -1
                                    ) else (
                                        fn_type_idx := store_value(Value::Record({ head = start_idx, count = 2, has_named = 0 }));
                                        if fn_type_idx == -1 then (
                                            -1
                                        ) else (
                                            mark_value_as_type(fn_type_idx)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ),
            NodeKind::FunctionCall(info) => (
                if NodeKind::TypePropertyAccess(access) := nodes(info.function).kind then (
                    obj_idx := eval_expression(access.object);
                    if obj_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        obj_idx
                    ) else (
                        if info.argument == access.object then (
                            obj_val := values(obj_idx);
                            if Value::Record(struct_info) := obj_val then (
                                field_idx := record_find_field_index_no_error{
                                    struct_info.head,
                                    struct_info.count,
                                    struct_info.has_named,
                                    access.property.start,
                                    access.property.length
                                };
                                if field_idx != -1 then (
                                    copy_value(field_idx)
                                ) else (
                                    apply_impl_method{obj_idx, access.object, access.property, span_start}
                                )
                            ) else (
                                apply_impl_method{obj_idx, access.object, access.property, span_start}
                            )
                        ) else (
                            obj_val := values(obj_idx);
                            if Value::EnumType(enum_info) := obj_val then (
                                payload_idx := record_find_field_index_no_error{
                                    enum_info.head,
                                    enum_info.count,
                                    1,
                                    access.property.start,
                                    access.property.length
                                };
                                if payload_idx == -1 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    variant_idx := payload_idx - 1;
                                    expects_payload := if Value::Unit := values(payload_idx) then 0 else 1;
                                    if expects_payload == 0 then (
                                        store_value(Value::Enum({
                                            enum_head = enum_info.head,
                                            enum_count = enum_info.count,
                                            variant_idx = variant_idx,
                                            payload = -1
                                        }))
                                    ) else (
                                        payload_value_idx := eval_expression(info.argument);
                                        if payload_value_idx == -1 then (
                                            -1
                                        ) else if flow_state.kind != FLOW_NONE then (
                                            payload_value_idx
                                        ) else (
                                            store_value(Value::Enum({
                                                enum_head = enum_info.head,
                                                enum_count = enum_info.count,
                                                variant_idx = variant_idx,
                                                payload = payload_value_idx
                                            }))
                                        )
                                    )
                                )
                            ) else (
                                prop_idx := if Value::Record(struct_info) := obj_val then (
                                    field_idx := record_find_field_index_no_error{
                                        struct_info.head,
                                        struct_info.count,
                                        struct_info.has_named,
                                        access.property.start,
                                        access.property.length
                                    };
                                    if field_idx == -1 then (
                                        apply_impl_property{
                                            access.object,
                                            obj_idx,
                                            access.property.start,
                                            access.property.length,
                                            span_start
                                        }
                                    ) else (
                                        field_idx
                                    )
                                ) else (
                                    apply_impl_property{
                                        access.object,
                                        obj_idx,
                                        access.property.start,
                                        access.property.length,
                                        span_start
                                    }
                                );
                                if prop_idx == -1 then (
                                    -1
                                ) else (
                                    arg_idx := eval_expression(info.argument);
                                    if arg_idx == -1 then (
                                        -1
                                    ) else if flow_state.kind != FLOW_NONE then (
                                        arg_idx
                                    ) else (
                                        apply_function_value{prop_idx, arg_idx, span_start}
                                    )
                                )
                            )
                        )
                    )
                ) else (
                    func_idx := eval_expression(info.function);
                    if func_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        func_idx
                    ) else (
                        arg_idx := eval_expression(info.argument);
                        if arg_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            arg_idx
                        ) else (
                            apply_function_value{func_idx, arg_idx, span_start}
                        )
                    )
                )
            ),
            NodeKind::AttachImplementation(info) => (
                type_idx := eval_expression(info.type_expr);
                if type_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    type_idx
                ) else (
                    impl_idx := eval_expression(info.implementation);
                    if impl_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        impl_idx
                    ) else (
                        if Value::Record(_) := values(impl_idx) then (
                            if impl_add{type_idx, impl_idx} == -1 then (
                                -1
                            ) else (
                                type_idx
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::IntrinsicOperation(info) => (
                info |> match {
                    IntrinsicOperation::Binary(bin) => (
                        left_idx := eval_expression(bin.left);
                        if left_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            left_idx
                        ) else (
                            right_idx := eval_expression(bin.right);
                            if right_idx == -1 then (
                                -1
                            ) else if flow_state.kind != FLOW_NONE then (
                                right_idx
                            ) else (
                                left := values(left_idx);
                                right := values(right_idx);
                                bin.operator |> match {
                                    BinaryIntrinsicOperator::I32Add => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv + rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Subtract => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv - rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Multiply => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv * rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Divide => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                if rv == 0 then (
                                                    set_error(span_start);
                                                    -1
                                                ) else (
                                                    store_value(Value::Number(lv / rv))
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Equal => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32NotEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv < rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv > rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanAnd => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanOr => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanXor => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    else => (
                                        set_error(span_start);
                                        -1
                                    )
                                }
                            )
                        )
                    ),
                    IntrinsicOperation::Unary(unary) => (
                        operand_idx := eval_expression(unary.operand);
                        if operand_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            operand_idx
                        ) else (
                            unary.operator |> match {
                                UnaryIntrinsicOperator::BooleanNot => (
                                    if Value::Boolean(flag) := values(operand_idx) then (
                                        store_value(Value::Boolean(if flag == 1 then 0 else 1))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::EnumFromStruct => (
                                    if Value::Record(rec_info) := values(operand_idx) then (
                                        if rec_info.has_named == 0 then (
                                            set_error(span_start);
                                            -1
                                        ) else if enum_record_payloads_are_types{rec_info.head, rec_info.count} == 0 then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            enum_idx := store_value(Value::EnumType({ head = rec_info.head, count = rec_info.count }));
                                            if enum_idx == -1 then (
                                                -1
                                            ) else (
                                                mark_value_as_type(enum_idx)
                                            )
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::MatchFromStruct => (
                                    if Value::Record(rec_info) := values(operand_idx) then (
                                        store_value(Value::MatchFunction({ head = rec_info.head, count = rec_info.count }))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::UseFromString => (
                                    if Value::String(path_ref) := values(operand_idx) then (
                                        eval_use_from_string{path_ref, span_start}
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BoxFromType => (
                                    if value_is_type(operand_idx) == 0 then (
                                        set_error(span_start);
                                        -1
                                    ) else if value_is_box_type_flag(operand_idx) == 1 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        start_idx := value_state.count;
                                        name_idx := store_value(Value::String(EMPTY_STRING));
                                        if name_idx == -1 then (
                                            -1
                                        ) else (
                                            val_idx := store_value(values(operand_idx));
                                            if val_idx == -1 then (
                                                -1
                                            ) else (
                                                box_idx := store_value(Value::Record({ head = start_idx, count = 1, has_named = 0 }));
                                                if box_idx == -1 then (
                                                    -1
                                                ) else (
                                                    mark_value_as_box_type(box_idx);
                                                    mark_value_as_type(box_idx)
                                                )
                                            )
                                        )
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationExportFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx) then (
                                        store_value(Value::BindingAnnotation({
                                            kind = BINDING_ANN_EXPORT,
                                            target = target_tag
                                        }))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationTargetFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx) then (
                                        store_value(Value::BindingAnnotation({
                                            kind = BINDING_ANN_TARGET,
                                            target = target_tag
                                        }))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationWrapFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx) then (
                                        if target_tag == TARGET_WGSL then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            store_value(Value::BindingAnnotation({
                                                kind = BINDING_ANN_WRAP,
                                                target = target_tag
                                            }))
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::AssemblyFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx) then (
                                        store_value(Value::AsmFunction(target_tag))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                else => (
                                    set_error(span_start);
                                    -1
                                )
                            }
                        )
                    ),
                    IntrinsicOperation::InlineAssembly(info) => (
                        code_idx := eval_expression(info.code);
                        if code_idx == -1 then (
                            -1
                        ) else if flow_state.kind != FLOW_NONE then (
                            code_idx
                        ) else (
                            target_tag := target_literal_tag(info.target);
                            if ensure_asm_target_allowed{target_tag, span_start} == 0 then (
                                -1
                            ) else if Value::String(code_ref) := values(code_idx) then (
                                store_value(Value::InlineAssembly({
                                    target = target_tag,
                                    code = code_ref
                                }))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Operation(info) => (
                left_idx := eval_expression(info.left);
                if left_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    left_idx
                ) else (
                    right_idx := eval_expression(info.right);
                    if right_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        right_idx
                    ) else (
                        op_start := info.operator.start;
                        op_len := info.operator.length;
                        left := values(left_idx);
                        right := values(right_idx);
                        if Value::Number(lv) := left then (
                            if Value::Number(rv) := right then (
                                if op_is1{op_start, op_len, '+'} == 1 then (
                                    store_value(Value::Number(lv + rv))
                                ) else if op_is1{op_start, op_len, '-'} == 1 then (
                                    store_value(Value::Number(lv - rv))
                                ) else if op_is1{op_start, op_len, '*'} == 1 then (
                                    store_value(Value::Number(lv * rv))
                                ) else if op_is1{op_start, op_len, '/'} == 1 then (
                                    if rv == 0 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        store_value(Value::Number(lv / rv))
                                    )
                                ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '.', '.'} == 1 then (
                                    range_start := value_state.count;
                                    name_idx := store_value(Value::String(SYNTHETIC_CURRENT_STRING));
                                    if name_idx == -1 then (
                                        -1
                                    ) else (
                                        current_idx := store_value(Value::Number(lv));
                                        if current_idx == -1 then (
                                            -1
                                        ) else (
                                            name_idx2 := store_value(Value::String(SYNTHETIC_END_STRING));
                                            if name_idx2 == -1 then (
                                                -1
                                            ) else (
                                                end_idx := store_value(Value::Number(rv));
                                                if end_idx == -1 then (
                                                    -1
                                                ) else (
                                                    name_idx3 := store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
                                                    if name_idx3 == -1 then (
                                                        -1
                                                    ) else (
                                                        iter_ty_idx := store_value(Value::String(SYNTHETIC_I32_STRING));
                                                        if iter_ty_idx == -1 then (
                                                            -1
                                                        ) else (
                                                            if mark_value_as_type(iter_ty_idx) == -1 then (
                                                                -1
                                                            ) else (
                                                                name_idx4 := store_value(Value::String(SYNTHETIC_NEXT_STRING));
                                                                if name_idx4 == -1 then (
                                                                    -1
                                                                ) else (
                                                                    next_idx := store_value(Value::Builtin(BUILTIN_RANGE_NEXT));
                                                                    if next_idx == -1 then (
                                                                        -1
                                                                    ) else (
                                                                        range_idx := store_value(Value::Record({ head = range_start, count = 4, has_named = 1 }));
                                                                        if range_idx == -1 then (
                                                                            -1
                                                                        ) else (
                                                                            if runtime_state.range_type_idx != -1 then (
                                                                                value_type_values(range_idx) = runtime_state.range_type_idx;
                                                                                0
                                                                            ) else (
                                                                                0
                                                                            );
                                                                            range_idx
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::Boolean(lv) := left then (
                            if Value::Boolean(rv) := right then (
                                if op_is2{op_start, op_len, '&', '&'} == 1 then (
                                    store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                                ) else if op_is2{op_start, op_len, '|', '|'} == 1 then (
                                    store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                                ) else if op_is1{op_start, op_len, '^'} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::Char(lv) := left then (
                            if Value::Char(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '<'} == 1 then (
                                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                                ) else if op_is1{op_start, op_len, '>'} == 1 then (
                                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '<', '='} == 1 then (
                                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '>', '='} == 1 then (
                                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::String(lv) := left then (
                            if Value::String(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 0 else 1))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::Target(lv) := left then (
                            if Value::Target(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else if Value::BindingAnnotation(lv) := left then (
                            if Value::BindingAnnotation(rv) := right then (
                                if op_is2{op_start, op_len, '=', '='} == 1 then (
                                    store_value(Value::Boolean(
                                        if lv.kind == rv.kind && lv.target == rv.target then 1 else 0
                                    ))
                                ) else if op_is2{op_start, op_len, '!', '='} == 1 then (
                                    store_value(Value::Boolean(
                                        if lv.kind == rv.kind && lv.target == rv.target then 0 else 1
                                    ))
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::If(info) => (
                cond_idx := eval_expression(info.condition);
                if cond_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    cond_idx
                ) else (
                    cond_value := values(cond_idx);
                    if Value::Boolean(flag) := cond_value then (
                        if check_if_branch_type_compat{
                            info.then_branch,
                            info.else_branch,
                            span_start
                        } == 0 then (
                            -1
                        ) else if flag == 1 then (
                            eval_expression(info.then_branch)
                        ) else (
                            eval_expression(info.else_branch)
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::Block(list) => (
                enter_scope{};
                mut current := list.head;
                mut count := 0;
                mut last_idx: i32 := store_value(Value::Unit);
                while count < list.count && current != -1 do (
                    last_idx = eval_expression(list_nodes(current).value);
                    if value_state.error != -1 || flow_state.kind != FLOW_NONE then (
                        current = -1;
                        0
                    ) else (
                        current = list_nodes(current).next;
                        count = count + 1;
                        0
                    );
                    {}
                );
                exit_scope{};
                last_idx
            ),
            NodeKind::Loop(info) => (
                runtime_state.loop_depth = runtime_state.loop_depth + 1;
                mut last_idx := store_value(Value::Unit);
                mut done := 0;
                while done == 0 do (
                    last_idx = eval_expression(info.body);
                    if value_state.error != -1 then (
                        done = 1;
                        0
                    ) else if flow_state.kind == FLOW_BREAK then (
                        last_idx = flow_state.value;
                        flow_state.kind = FLOW_NONE;
                        flow_state.value = -1;
                        done = 1;
                        0
                    ) else if flow_state.kind == FLOW_RETURN then (
                        done = 1;
                        0
                    ) else (
                        0
                    );
                    {}
                );
                runtime_state.loop_depth = runtime_state.loop_depth - 1;
                last_idx
            ),
            NodeKind::Diverge(info) => (
                info.divergance_type |> match {
                    DivergeExpressionType::Break => (
                        if runtime_state.loop_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FLOW_BREAK;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    DivergeExpressionType::Return => (
                        if runtime_state.function_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FLOW_RETURN;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::EnumType(info) => (
                mut current := info.variants;
                mut temp_head := -1;
                mut temp_tail := -1;
                mut last_idx := -1;
                mut type_ok := 1;
                while current != -1 do (
                    variant_node := list_nodes(current).value;
                    if NodeKind::Binding(variant_binding) := nodes(variant_node).kind then (
                        last_idx = eval_expression(variant_binding.expr);
                        if last_idx == -1 then (
                            current = -1;
                        ) else if flow_state.kind != FLOW_NONE then (
                            current = -1;
                        ) else if value_is_type(last_idx) == 0 then (
                            type_ok = 0;
                            current = -1;
                        ) else (
                            temp_node := new_list_node{last_idx, -1};
                            if temp_node == -1 then (
                                current = -1;
                            ) else (
                                if temp_head == -1 then (
                                    temp_head = temp_node;
                                ) else (
                                    list_nodes(temp_tail).next = temp_node;
                                );
                                temp_tail = temp_node;
                                current = list_nodes(current).next;
                            )
                        )
                    ) else (
                        set_error(span_start);
                        current = -1;
                    );
                    {}
                );
                if value_state.error != -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    last_idx
                ) else if type_ok == 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    start_idx := value_state.count;
                    mut count := 0;
                    current = info.variants;
                    mut temp_current := temp_head;
                    while current != -1 && temp_current != -1 do (
                        variant_node := list_nodes(current).value;
                        if NodeKind::Binding(variant_binding) := nodes(variant_node).kind then (
                            mut variant_name := EMPTY_STRING;
                            variant_binding.pattern |> match {
                                BindingPattern::Identifier(id) => (variant_name = id.name.name),
                                else => (variant_name = EMPTY_STRING)
                            };
                            if variant_name.length <= 0 then (
                                set_error(span_start);
                                current = -1;
                                temp_current = -1;
                            ) else (
                                name_idx := store_value(Value::String(variant_name));
                                if name_idx == -1 then (
                                    current = -1;
                                    temp_current = -1;
                                ) else (
                                    val_idx := copy_value(list_nodes(temp_current).value);
                                    if val_idx == -1 then (
                                        current = -1;
                                        temp_current = -1;
                                    ) else (
                                        normalized_val_idx := mark_intrinsic_string_value_as_type(val_idx);
                                        if normalized_val_idx == -1 then (
                                            current = -1;
                                            temp_current = -1;
                                        ) else (
                                        count = count + 1;
                                        current = list_nodes(current).next;
                                        temp_current = list_nodes(temp_current).next;
                                        )
                                    )
                                )
                            )
                        ) else (
                            set_error(span_start);
                            current = -1;
                            temp_current = -1;
                        );
                        {}
                    );
                    if value_state.error != -1 then (
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = start_idx, count = count }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                )
            ),
            NodeKind::Match(info) => (
                value_idx := eval_expression(info.value);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    mut matched := 0;
                    mut result_idx := -1;
                    mut current := info.branches;
                    while current != -1 && matched == 0 do (
                        branch_node := list_nodes(current).value;
                        if NodeKind::Binding(branch_binding) := nodes(branch_node).kind then (
                            enter_scope{};
                            bind_pattern_state.value_idx = value_idx;
                            bind_pattern_state.inherit_mut = 0;
                            bind_pattern_state.inherit_target_mask = 0;
                            bind_pattern_state.inherit_export_mask = 0;
                            bind_pattern_state.inherit_wrap_mask = 0;
                            if bind_pattern_simple(branch_binding.pattern) == 1 then (
                                matched = 1;
                                result_idx = eval_expression(branch_binding.expr);
                                0
                            ) else (
                                0
                            );
                            exit_scope{};
                        ) else (
                            set_error(span_start);
                            matched = 1;
                            result_idx = -1;
                        );
                        if matched == 0 then (
                            current = list_nodes(current).next;
                            0
                        ) else (
                            0
                        );
                        {}
                    );
                    if matched == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        result_idx
                    )
                )
            ),
            NodeKind::EnumValue(info) => (
                enum_idx := eval_expression(info.enum_type);
                if enum_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    enum_idx
                ) else (
                    payload_idx := eval_expression(info.payload);
                    if payload_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        payload_idx
                    ) else (
                        if Value::EnumType(enum_info) := values(enum_idx) then (
                            payload_slot := record_find_field_index_no_error{
                                enum_info.head,
                                enum_info.count,
                                1,
                                info.variant.name.start,
                                info.variant.name.length
                            };
                            if payload_slot == -1 then (
                                set_error(span_start);
                                -1
                            ) else (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    payload = payload_idx
                                }))
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::EnumConstructor(info) => (
                enum_idx := eval_expression(info.enum_type);
                if enum_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    enum_idx
                ) else (
                    payload_type_idx := eval_expression(info.payload_type);
                    if payload_type_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        payload_type_idx
                    ) else if value_is_type(payload_type_idx) == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        if Value::EnumType(enum_info) := values(enum_idx) then (
                            expects_payload := if Value::Unit := values(payload_type_idx) then 0 else 1;
                            payload_slot := record_find_field_index_no_error{
                                enum_info.head,
                                enum_info.count,
                                1,
                                info.variant.name.start,
                                info.variant.name.length
                            };
                            if payload_slot == -1 then (
                                set_error(span_start);
                                -1
                            ) else if expects_payload == 0 then (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    payload = -1
                                }))
                            ) else (
                                store_value(Value::EnumConstructor({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    expects_payload = 1
                                }))
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::ArrayIndex(info) => (
                array_idx := eval_expression(info.array);
                if array_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    array_idx
                ) else (
                    index_idx := eval_expression(info.index);
                    if index_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        index_idx
                    ) else (
                        if Value::Number(index_value) := values(index_idx) then (
                            if Value::String(string_value) := values(array_idx) then (
                                if index_value < 0 || index_value >= string_value.length then (
                                    set_error(span_start);
                                    -1
                                ) else if string_value.start < 0 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    store_value(Value::Char(input(string_value.start + index_value) + 0))
                                )
                            ) else if Value::Record(struct_info) := values(array_idx) then (
                                field_idx := record_value_index_by_position{
                                    struct_info.head,
                                    struct_info.count,
                                    index_value,
                                    span_start
                                };
                                if field_idx == -1 then (
                                    -1
                                ) else (
                                    field_idx
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::TypePropertyAccess(info: TypePropertyAccessInfo) => (
                obj_idx := eval_expression(info.object);
                if obj_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    obj_idx
                ) else (
                    obj_val := values(obj_idx);
                    if Value::EnumType(enum_info) := obj_val then (
                        payload_idx := record_find_field_index_no_error{
                            enum_info.head,
                            enum_info.count,
                            1,
                            info.property.start,
                            info.property.length
                        };
                        if payload_idx == -1 then (
                            set_error(span_start);
                            -1
                        ) else (
                            variant_idx := payload_idx - 1;
                            expects_payload := if Value::Unit := values(payload_idx) then 0 else 1;
                            if expects_payload == 0 then (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = variant_idx,
                                    payload = -1
                                }))
                            ) else (
                                store_value(Value::EnumConstructor({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = variant_idx,
                                    expects_payload = 1
                                }))
                            )
                        )
                    ) else if Value::Record(struct_info) := obj_val then (
                        field_idx := record_find_field_index_no_error{
                            struct_info.head,
                            struct_info.count,
                            struct_info.has_named,
                            info.property.start,
                            info.property.length
                        };
                        if field_idx == -1 then (
                            apply_impl_property{
                                info.object,
                                obj_idx,
                                info.property.start,
                                info.property.length,
                                span_start
                            }
                        ) else (
                            copied_idx := copy_value(field_idx);
                            if copied_idx == -1 then (
                                -1
                            ) else (
                                copied_val := values(copied_idx);
                                if Value::String(name_ref) := copied_val then (
                                    if name_ref.start < 0 then (
                                        if (name_ref.start == SYNTHETIC_I32_STRING.start && name_ref.length == SYNTHETIC_I32_STRING.length)
                                            || (name_ref.start == SYNTHETIC_U8_STRING.start && name_ref.length == SYNTHETIC_U8_STRING.length)
                                            || (name_ref.start == SYNTHETIC_BOOL_STRING.start && name_ref.length == SYNTHETIC_BOOL_STRING.length)
                                            || (name_ref.start == SYNTHETIC_TYPE_STRING.start && name_ref.length == SYNTHETIC_TYPE_STRING.length)
                                        then (
                                            if mark_value_as_type(copied_idx) == -1 then (
                                                -1
                                            ) else (
                                                copied_idx
                                            )
                                        ) else (
                                            copied_idx
                                        )
                                    ) else (
                                        copied_idx
                                    )
                                ) else (
                                    copied_idx
                                )
                            )
                        )
                    ) else (
                        apply_impl_property{
                            info.object,
                            obj_idx,
                            info.property.start,
                            info.property.length,
                            span_start
                        }
                    )
                )
            ),
            NodeKind::ArrayRepeat(info) => (
                value_idx := eval_expression(info.value);
                if value_idx == -1 then (
                    -1
                ) else if flow_state.kind != FLOW_NONE then (
                    value_idx
                ) else (
                    count_is_literal := if NodeKind::Literal(ExpressionLiteral::Number(_)) := nodes(info.count).kind then 1 else 0;
                    count_idx := eval_expression(info.count);
                    if count_idx == -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        count_idx
                    ) else (
                        if Value::Number(count_value) := values(count_idx) then (
                            if count_value < 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                start_idx := value_state.count;
                                mut idx := 0;
                                while idx < count_value do (
                                    name_idx := store_value(Value::String(EMPTY_STRING));
                                    if name_idx == -1 then (
                                        idx = count_value;
                                    ) else (
                                        val_idx := store_value(values(value_idx));
                                        if val_idx == -1 then (
                                            idx = count_value;
                                        ) else (
                                            idx = idx + 1;
                                        );
                                    );
                                    {}
                                );
                                if value_state.error != -1 then (
                                    -1
                                ) else (
                                    array_idx := store_value(Value::Record({ head = start_idx, count = count_value, has_named = 0 }));
                                    if array_idx == -1 then (
                                        -1
                                    ) else if count_is_literal == 1 && value_is_type(value_idx) == 1 then (
                                        mark_value_as_type(array_idx)
                                    ) else (
                                        array_idx
                                    )
                                )
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then (
                    unit_idx := store_value(Value::Unit);
                    if unit_idx == -1 then (
                        -1
                    ) else (
                        mark_value_as_type(unit_idx)
                    )
                ) else (
                    mut current := info.fields;
                    mut temp_head := -1;
                    mut temp_tail := -1;
                    mut last_idx := -1;
                    mut struct_is_type := 1;
                    while current != -1 do (
                        field_node := list_nodes(current).value;
                        if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                            last_idx = eval_expression(field_binding.expr);
                            if last_idx == -1 then (
                                current = -1;
                            ) else if flow_state.kind != FLOW_NONE then (
                                current = -1;
                            ) else (
                                if value_is_type(last_idx) == 0 then (
                                    struct_is_type = 0;
                                    0
                                ) else (
                                    0
                                );
                                temp_node := new_list_node{last_idx, -1};
                                if temp_node == -1 then (
                                    current = -1;
                                ) else (
                                    if temp_head == -1 then (
                                        temp_head = temp_node;
                                    ) else (
                                        list_nodes(temp_tail).next = temp_node;
                                    );
                                    temp_tail = temp_node;
                                    current = list_nodes(current).next;
                                )
                            )
                        ) else (
                            set_error(span_start);
                            current = -1;
                        );
                        {}
                    );
                    if value_state.error != -1 then (
                        -1
                    ) else if flow_state.kind != FLOW_NONE then (
                        last_idx
                    ) else (
                        start_idx := value_state.count;
                        mut count := 0;
                        mut has_named := 0;
                        current = info.fields;
                        mut temp_current := temp_head;
                        while current != -1 && temp_current != -1 do (
                            field_node := list_nodes(current).value;
                            if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                                mut field_name := EMPTY_STRING;
                                field_binding.pattern |> match {
                                    BindingPattern::Identifier(id) => (field_name = id.name.name),
                                    else => (field_name = EMPTY_STRING)
                                };
                                if field_name.length > 0 then (
                                    has_named = 1;
                                    0
                                ) else (
                                    0
                                );
                                name_idx := store_value(Value::String(field_name));
                                if name_idx == -1 then (
                                    current = -1;
                                    temp_current = -1;
                                ) else (
                                    val_idx := copy_value(list_nodes(temp_current).value);
                                    if val_idx == -1 then (
                                        current = -1;
                                        temp_current = -1;
                                    ) else (
                                        normalized_val_idx := mark_intrinsic_string_value_as_type(val_idx);
                                        if normalized_val_idx == -1 then (
                                            current = -1;
                                            temp_current = -1;
                                        ) else (
                                        count = count + 1;
                                        current = list_nodes(current).next;
                                        temp_current = list_nodes(temp_current).next;
                                        )
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                current = -1;
                                temp_current = -1;
                            );
                            {}
                        );
                        if value_state.error != -1 then (
                            -1
                        ) else (
                            struct_idx := store_value(Value::Record({ head = start_idx, count = count, has_named = has_named }));
                            if struct_idx == -1 then (
                                -1
                            ) else if struct_is_type == 1 then (
                                mark_value_as_type(struct_idx)
                            ) else (
                                struct_idx
                            )
                        )
                    )
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

value_tag := (value: Value) => (
    value |> match {
        Value::Number(_) => 0,
        Value::Boolean(_) => 1,
        Value::Char(_) => 2,
        Value::String(_) => 3,
        Value::Unit => 4,
        Value::Function(_) => 5,
        Value::Record(_) => 6,
        Value::Builtin(_) => 7,
        Value::EnumType(_) => 8,
        Value::EnumConstructor(_) => 9,
        Value::Enum(_) => 10,
        Value::MatchFunction(_) => 11,
        Value::Target(_) => 12,
        Value::BindingAnnotation(_) => 13,
        Value::AsmFunction(_) => 14,
        Value::InlineAssembly(_) => 15,
        else => -1
    }
);

(export wasm) interpret := (root: i32) => (
    reset_interpreter{};
    enter_scope{};
    init_last := init_intrinsic_context{};
    if init_last < 0 then (
        set_error(0);
        exit_scope{};
        -1
    ) else (
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut count := 0;
            mut last_idx: i32 := store_value(Value::Unit);
            while count < list.count && current != -1 do (
                last_idx = eval_expression(list_nodes(current).value);
                if value_state.error != -1 || flow_state.kind != FLOW_NONE then (
                    current = -1;
                    0
                ) else (
                    current = list_nodes(current).next;
                    count = count + 1;
                    0
                );
                {}
            );
            if value_state.error != -1 then (
                exit_scope{};
                -1
            ) else (
                last_idx
            )
        ) else (
            result_idx := eval_expression(root);
            if value_state.error != -1 then (
                exit_scope{};
                -1
            ) else (
                result_idx
            )
        )
    )
);

(export wasm) get_interp_error := {} => (
    value_state.error
);

(export wasm) get_value_tag := (idx: i32) => (
    value_tag(values(idx))
);

(export wasm) get_value_number := (idx: i32) => (
    if Value::Number(value) := values(idx) then value else 0
);

(export wasm) get_value_boolean := (idx: i32) => (
    if Value::Boolean(value) := values(idx) then value else 0
);

(export wasm) get_value_char := (idx: i32) => (
    if Value::Char(value) := values(idx) then value else 0
);

(export wasm) get_value_string_start := (idx: i32) => (
    if Value::String(value) := values(idx) then value.start else -1
);

(export wasm) get_value_string_length := (idx: i32) => (
    if Value::String(value) := values(idx) then value.length else 0
);

(export wasm) get_binding_count := {} => (
    binding_state.count
);

(export wasm) get_binding_name_start := (idx: i32) => (
    binding_name_start(idx)
);

(export wasm) get_binding_name_length := (idx: i32) => (
    binding_name_length(idx)
);

(export wasm) get_binding_target_mask := (idx: i32) => (
    binding_target_mask(idx)
);

(export wasm) get_binding_export_mask := (idx: i32) => (
    binding_export_mask(idx)
);

(export wasm) get_binding_wrap_mask := (idx: i32) => (
    binding_wrap_mask(idx)
);



