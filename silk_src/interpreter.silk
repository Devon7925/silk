types := use "types.silk";

StringRef := types.StringRef;
SourceSpan := types.SourceSpan;

Identifier := types.Identifier;

TargetLiteral := types.TargetLiteral;

BindingAnnotationLiteral := types.BindingAnnotationLiteral;

ExpressionLiteral := types.ExpressionLiteral;

IntrinsicType := types.IntrinsicType;

UnaryIntrinsicOperator := types.UnaryIntrinsicOperator;

BinaryIntrinsicOperator := types.BinaryIntrinsicOperator;

IntrinsicOperation := types.IntrinsicOperation;

DivergeExpressionType := types.DivergeExpressionType;

BindingPattern := types.BindingPattern;

LValue := types.LValue;

Binding := types.Binding;

ExpressionList := types.ExpressionList;

FunctionTypeInfo := types.FunctionTypeInfo;
FunctionInfo := types.FunctionInfo;
EnumValueInfo := types.EnumValueInfo;
EnumConstructorInfo := types.EnumConstructorInfo;
IfInfo := types.IfInfo;
AttachImplementationInfo := types.AttachImplementationInfo;
ArrayRepeatInfo := types.ArrayRepeatInfo;
OperationInfo := types.OperationInfo;
AssignmentInfo := types.AssignmentInfo;
FunctionCallInfo := types.FunctionCallInfo;
ArrayIndexInfo := types.ArrayIndexInfo;
TypePropertyAccessInfo := types.TypePropertyAccessInfo;
DivergeInfo := types.DivergeInfo;
LoopInfo := types.LoopInfo;
MatchInfo := types.MatchInfo;
StructInfo := types.StructInfo;
EnumTypeInfo := types.EnumTypeInfo;

NodeKind := types.NodeKind;

TypeCache := types.TypeCache;
Node := types.Node;

ListNode := types.ListNode;

MAX_INPUT := types.MAX_INPUT;
MAX_NODES := types.MAX_NODES;
MAX_LIST_NODES := types.MAX_LIST_NODES;

EMPTY_STRING := types.EMPTY_STRING;
SYNTHETIC_MUT_STRING := types.SYNTHETIC_MUT_STRING;
SYNTHETIC_OPTION_STRING := types.SYNTHETIC_OPTION_STRING;
SYNTHETIC_SOME_STRING := types.SYNTHETIC_SOME_STRING;
SYNTHETIC_NONE_STRING := { length = 4, start = -14 };
SYNTHETIC_ITER_TY_STRING := types.SYNTHETIC_ITER_TY_STRING;
SYNTHETIC_NEXT_STRING := types.SYNTHETIC_NEXT_STRING;
SYNTHETIC_FOR_ITER_STRING := types.SYNTHETIC_FOR_ITER_STRING;
SYNTHETIC_CURRENT_STRING := { length = 7, start = -15 };
SYNTHETIC_END_STRING := { length = 3, start = -16 };
SYNTHETIC_BOX_STRING := { length = 3, start = -17 };
SYNTHETIC_I32_STRING := { length = 3, start = -8 };
SYNTHETIC_U8_STRING := { length = 2, start = -9 };
SYNTHETIC_BOOL_STRING := { length = 4, start = -10 };
SYNTHETIC_TYPE_STRING := { length = 4, start = -11 };
SYNTHETIC_TARGET_STRING := { length = 6, start = -12 };
SYNTHETIC_BINDING_ANNOTATION_STRING := { length = 18, start = -13 };
SYNTHETIC_JS_STRING := { length = 2, start = -18 };
SYNTHETIC_WASM_STRING := { length = 4, start = -19 };
SYNTHETIC_WGSL_STRING := { length = 4, start = -20 };
SYNTHETIC_RANGE_STRING := { length = 5, start = -21 };
SYNTHETIC_OP_ADD_STRING := { length = 1, start = -22 };
SYNTHETIC_OP_SUBTRACT_STRING := { length = 1, start = -23 };
SYNTHETIC_OP_MULTIPLY_STRING := { length = 1, start = -24 };
SYNTHETIC_OP_DIVIDE_STRING := { length = 1, start = -25 };
SYNTHETIC_OP_EQUAL_STRING := { length = 2, start = -26 };
SYNTHETIC_OP_NOT_EQUAL_STRING := { length = 2, start = -27 };
SYNTHETIC_OP_LESS_THAN_STRING := { length = 1, start = -28 };
SYNTHETIC_OP_GREATER_THAN_STRING := { length = 1, start = -29 };
SYNTHETIC_OP_LESS_THAN_OR_EQUAL_STRING := { length = 2, start = -30 };
SYNTHETIC_OP_GREATER_THAN_OR_EQUAL_STRING := { length = 2, start = -31 };
SYNTHETIC_OP_RANGE_STRING := { length = 2, start = -32 };
SYNTHETIC_OP_AND_STRING := { length = 2, start = -33 };
SYNTHETIC_OP_OR_STRING := { length = 2, start = -34 };
SYNTHETIC_OP_XOR_STRING := { length = 1, start = -35 };
SYNTHETIC_TARGET_TYPE_BINDING_STRING := { length = 13, start = -36 };
EMPTY_IDENTIFIER := types.EMPTY_IDENTIFIER;
EMPTY_SPAN := types.EMPTY_SPAN;
EMPTY_NODE := types.EMPTY_NODE;
EMPTY_LIST_NODE := types.EMPTY_LIST_NODE;

State := types.State;

TargetTag := types.TargetTag;

BindingAnnotationValue := enum {
    Mut = {},
    Export = TargetTag,
    Target = TargetTag,
    Wrap = TargetTag,
};

FlowKind := enum {
    None = {},
    Return = {},
    Break = {},
};

Value := enum {
    Number = i32,
    Boolean = i32,
    Char = i32,
    String = StringRef,
    Unit = {},
    Function = { node = i32, closure_head = i32, closure_count = i32 },
    Record = { head = i32, count = i32, has_named = i32 },
    Builtin = i32,
    EnumType = { head = i32, count = i32 },
    EnumConstructor = { enum_head = i32, enum_count = i32, variant_idx = i32, expects_payload = i32 },
    Enum = { enum_head = i32, enum_count = i32, variant_idx = i32, payload = i32 },
    MatchFunction = { head = i32, count = i32 },
    Target = TargetTag,
    BindingAnnotation = BindingAnnotationValue,
    AsmFunction = TargetTag,
    InlineAssembly = { target = TargetTag, code = StringRef },
    IntrinsicBinaryMethod = BinaryIntrinsicOperator,
    IntrinsicBinaryPartial = { operator = i32, left = i32 },
    RangeMethod = {},
    RangePartial = i32,
};

ValueState := { count = i32, error = i32, error_code = i32 };

BindingState := { count = i32, scope_count = i32 };
BindingTemp := { start = i32, length = i32, is_mut = i32, ok = i32 };
BindingTargetState := { depth = i32, acc_mask = i32 };
ImplementationState := { count = i32 };
FileState := { count = i32 };
IntrinsicState := { binding_count = i32 };
AnnotationTemp := { is_mut = i32, target_mask = i32, export_mask = i32, wrap_mask = i32 };

FlowState := { kind = FlowKind, value = i32 };
RuntimeState := {
    loop_depth = i32,
    function_depth = i32,
    option_enum_idx = i32,
    option_i32_enum_idx = i32,
    type_value_idx = i32,
    range_type_idx = i32
};
BindPatternState := { value_idx = i32, inherit_mut = i32, inherit_target_mask = i32, inherit_export_mask = i32, inherit_wrap_mask = i32 };
DebugState := { error_binding_count = i32, init_binding_count = i32 };
ValueSlot := { value = Value, type_value = i32, is_box_type = i32 };
BindingSlot := {
    name_start = i32,
    name_length = i32,
    value = i32,
    is_mut = i32,
    type_value = i32,
    target_mask = i32,
    export_mask = i32,
    wrap_mask = i32
};
ImplementationSlot := { type_value = i32, value = i32 };
ScopeSlot := { scope = i32, binding_target = i32, scope_backup = i32, binding_target_backup = i32 };
FileSlot := { path_start = i32, path_length = i32, root_idx = i32, import_value = i32 };

MAX_VALUES := 200000;
MAX_BINDINGS := 4096;
MAX_IMPLS := 1024;
MAX_SCOPES := 256;
MAX_FILES := 256;

flow_kind_is_none := (kind: FlowKind) => (
    kind |> match {
        FlowKind::None => 1,
        else => 0
    }
);

flow_kind_is_return := (kind: FlowKind) => (
    kind |> match {
        FlowKind::Return => 1,
        else => 0
    }
);

flow_kind_is_break := (kind: FlowKind) => (
    kind |> match {
        FlowKind::Break => 1,
        else => 0
    }
);

InterpError := enum {
    None = {},
    Generic = {},
    ArrayIndexOutOfRange = {},
    WrapRequiresSingleExportTarget = {},
    WrapGlobalOnlyWasmToJs = {},
    UnboundIdentifier = {},
    IfBranchTypeMismatch = {},
    MatchNoBranch = {},
    MissingField = {},
    TraitMissingField = {},
};

interp_error_code := (err: InterpError) => (
    err |> match {
        InterpError::None => 0,
        InterpError::Generic => 1,
        InterpError::ArrayIndexOutOfRange => 2,
        InterpError::WrapRequiresSingleExportTarget => 3,
        InterpError::WrapGlobalOnlyWasmToJs => 4,
        InterpError::UnboundIdentifier => 5,
        InterpError::IfBranchTypeMismatch => 6,
        InterpError::MatchNoBranch => 7,
        InterpError::MissingField => 8,
        InterpError::TraitMissingField => 9,
        else => 1
    }
);

interp_err_none := {} => interp_error_code(InterpError::None);
interp_err_generic := {} => interp_error_code(InterpError::Generic);
interp_err_array_index_out_of_range := {} => interp_error_code(InterpError::ArrayIndexOutOfRange);
interp_err_wrap_requires_single_export_target := {} => interp_error_code(InterpError::WrapRequiresSingleExportTarget);
interp_err_wrap_global_only_wasm_to_js := {} => interp_error_code(InterpError::WrapGlobalOnlyWasmToJs);
interp_err_unbound_identifier := {} => interp_error_code(InterpError::UnboundIdentifier);
interp_err_if_branch_type_mismatch := {} => interp_error_code(InterpError::IfBranchTypeMismatch);
interp_err_match_no_branch := {} => interp_error_code(InterpError::MatchNoBranch);
interp_err_missing_field := {} => interp_error_code(InterpError::MissingField);
interp_err_trait_missing_field := {} => interp_error_code(InterpError::TraitMissingField);

BuiltinKind := enum {
    Enum = {},
    Match = {},
    Export = {},
    Target = {},
    Wrap = {},
    Asm = {},
    Option = {},
    Iterator = {},
    RangeNext = {},
    Use = {},
};

builtin_kind_tag := (kind: BuiltinKind) => (
    kind |> match {
        BuiltinKind::Enum => 0,
        BuiltinKind::Match => 1,
        BuiltinKind::Export => 2,
        BuiltinKind::Target => 3,
        BuiltinKind::Wrap => 4,
        BuiltinKind::Asm => 5,
        BuiltinKind::Option => 6,
        BuiltinKind::Iterator => 7,
        BuiltinKind::RangeNext => 8,
        BuiltinKind::Use => 9,
        else => -1
    }
);

builtin_enum := {} => builtin_kind_tag(BuiltinKind::Enum);
builtin_match := {} => builtin_kind_tag(BuiltinKind::Match);
builtin_export := {} => builtin_kind_tag(BuiltinKind::Export);
builtin_target := {} => builtin_kind_tag(BuiltinKind::Target);
builtin_wrap := {} => builtin_kind_tag(BuiltinKind::Wrap);
builtin_asm := {} => builtin_kind_tag(BuiltinKind::Asm);
builtin_option := {} => builtin_kind_tag(BuiltinKind::Option);
builtin_iterator := {} => builtin_kind_tag(BuiltinKind::Iterator);
builtin_range_next := {} => builtin_kind_tag(BuiltinKind::RangeNext);
builtin_use := {} => builtin_kind_tag(BuiltinKind::Use);

TARGET_JS := types.TARGET_JS;
TARGET_WASM := types.TARGET_WASM;
TARGET_WGSL := types.TARGET_WGSL;

TARGET_MASK_JS := types.TARGET_MASK_JS;
TARGET_MASK_WASM := types.TARGET_MASK_WASM;
TARGET_MASK_WGSL := types.TARGET_MASK_WGSL;

target_tag_value := (target: TargetTag) => (
    target |> match {
        TargetTag::Js => TARGET_JS,
        TargetTag::Wasm => TARGET_WASM,
        TargetTag::Wgsl => TARGET_WGSL,
        else => -1
    }
);

target_js := {} => target_tag_value(TargetTag::Js);
target_wasm := {} => target_tag_value(TargetTag::Wasm);
target_wgsl := {} => target_tag_value(TargetTag::Wgsl);

TargetMaskBit := types.TargetMaskBit;

target_mask_bit := (mask: TargetMaskBit) => (
    mask |> match {
        TargetMaskBit::Js => TARGET_MASK_JS,
        TargetMaskBit::Wasm => TARGET_MASK_WASM,
        TargetMaskBit::Wgsl => TARGET_MASK_WGSL,
        else => 0
    }
);

target_mask_js := {} => target_mask_bit(TargetMaskBit::Js);
target_mask_wasm := {} => target_mask_bit(TargetMaskBit::Wasm);
target_mask_wgsl := {} => target_mask_bit(TargetMaskBit::Wgsl);

target_mask_from_target := (target_tag: TargetTag) => (
    target_tag |> match {
        TargetTag::Js => target_mask_js{},
        TargetTag::Wasm => target_mask_wasm{},
        TargetTag::Wgsl => target_mask_wgsl{},
        else => 0
    }
);

target_mask_from_tag := (target_tag: i32) => (
    if target_tag == target_js{} then target_mask_js{}
    else if target_tag == target_wasm{} then target_mask_wasm{}
    else if target_tag == target_wgsl{} then target_mask_wgsl{}
    else 0
);

target_mask_has := {mask: i32, target_tag: i32} => (
    if target_tag == target_js{} then (
        if mask == 1 || mask == 3 || mask == 5 || mask == 7 then 1 else 0
    ) else if target_tag == target_wasm{} then (
        if mask == 2 || mask == 3 || mask == 6 || mask == 7 then 1 else 0
    ) else if target_tag == target_wgsl{} then (
        if mask == 4 || mask == 5 || mask == 6 || mask == 7 then 1 else 0
    ) else (
        0
    )
);

target_mask_or := {left: i32, right: i32} => (
    js := if target_mask_has{left, target_js{}} == 1 || target_mask_has{right, target_js{}} == 1 then target_mask_js{} else 0;
    wasm := if target_mask_has{left, target_wasm{}} == 1 || target_mask_has{right, target_wasm{}} == 1 then target_mask_wasm{} else 0;
    wgsl := if target_mask_has{left, target_wgsl{}} == 1 || target_mask_has{right, target_wgsl{}} == 1 then target_mask_wgsl{} else 0;
    js + wasm + wgsl
);

target_mask_and := {left: i32, right: i32} => (
    js := if target_mask_has{left, target_js{}} == 1 && target_mask_has{right, target_js{}} == 1 then target_mask_js{} else 0;
    wasm := if target_mask_has{left, target_wasm{}} == 1 && target_mask_has{right, target_wasm{}} == 1 then target_mask_wasm{} else 0;
    wgsl := if target_mask_has{left, target_wgsl{}} == 1 && target_mask_has{right, target_wgsl{}} == 1 then target_mask_wgsl{} else 0;
    js + wasm + wgsl
);

target_mask_allows := {required: i32, current: i32} => (
    js_blocked := target_mask_has{current, target_js{}} == 1 && target_mask_has{required, target_js{}} == 0;
    wasm_blocked := target_mask_has{current, target_wasm{}} == 1 && target_mask_has{required, target_wasm{}} == 0;
    wgsl_blocked := target_mask_has{current, target_wgsl{}} == 1 && target_mask_has{required, target_wgsl{}} == 0;
    if js_blocked || wasm_blocked || wgsl_blocked then 0 else 1
);

target_mask_is_single_target := (mask: i32) => (
    if mask == target_mask_js{} || mask == target_mask_wasm{} || mask == target_mask_wgsl{} then 1 else 0
);

EMPTY_VALUE := Value::Unit;
EMPTY_VALUE_SLOT := { value = EMPTY_VALUE, type_value = -1, is_box_type = 0 };
EMPTY_BINDING_SLOT := {
    name_start = 0,
    name_length = 0,
    value = 0,
    is_mut = 0,
    type_value = -1,
    target_mask = 0,
    export_mask = 0,
    wrap_mask = 0
};
EMPTY_IMPLEMENTATION_SLOT := { type_value = 0, value = 0 };
EMPTY_SCOPE_SLOT := { scope = 0, binding_target = 0, scope_backup = 0, binding_target_backup = 0 };
EMPTY_FILE_SLOT := { path_start = 0, path_length = 0, root_idx = 0, import_value = -1 };

(export wasm) input: Box({u8; MAX_INPUT}) := {0; MAX_INPUT};
(export wasm) mut nodes: Box({Node; MAX_NODES}) := {EMPTY_NODE; MAX_NODES};
(export wasm) mut list_nodes: Box({ListNode; MAX_LIST_NODES}) := {EMPTY_LIST_NODE; MAX_LIST_NODES};
(export wasm) mut state: Box(State) := { count = 0, cursor = 0, error = 0, list_count = 0 };
(export wasm) mut values: Box({ValueSlot; MAX_VALUES}) := {EMPTY_VALUE_SLOT; MAX_VALUES};
(export wasm) mut value_state: Box(ValueState) := { count = 0, error = -1, error_code = interp_err_none{} };
(export wasm) mut bindings: Box({BindingSlot; MAX_BINDINGS}) := {EMPTY_BINDING_SLOT; MAX_BINDINGS};
(export wasm) mut binding_state: Box(BindingState) := { count = 0, scope_count = 0 };
(export wasm) mut binding_temp: Box(BindingTemp) := { start = 0, length = 0, is_mut = 0, ok = 0 };
(export wasm) mut binding_target_state: Box(BindingTargetState) := { depth = 0, acc_mask = 0 };
(export wasm) mut implementations: Box({ImplementationSlot; MAX_IMPLS}) := {EMPTY_IMPLEMENTATION_SLOT; MAX_IMPLS};
(export wasm) mut impl_state: Box(ImplementationState) := { count = 0 };
(export wasm) mut scopes: Box({ScopeSlot; MAX_SCOPES}) := {EMPTY_SCOPE_SLOT; MAX_SCOPES};
mut intrinsic_state: Box(IntrinsicState) := { binding_count = 0 };
(export wasm) mut file_state: Box(FileState) := { count = 0 };
(export wasm) mut files: Box({FileSlot; MAX_FILES}) := {EMPTY_FILE_SLOT; MAX_FILES};
mut debug_state: Box(DebugState) := { error_binding_count = 0, init_binding_count = 0 };
(export wasm) mut flow_state: Box(FlowState) := { kind = FlowKind::None, value = -1 };
(export wasm) mut runtime_state: Box(RuntimeState) := {
    loop_depth = 0,
    function_depth = 0,
    option_enum_idx = -1,
    option_i32_enum_idx = -1,
    type_value_idx = -1,
    range_type_idx = -1
};
(export wasm) mut bind_pattern_state: Box(BindPatternState) := { value_idx = -1, inherit_mut = 0, inherit_target_mask = 0, inherit_export_mask = 0, inherit_wrap_mask = 0 };
(export wasm) mut annotation_temp: Box(AnnotationTemp) := { is_mut = 0, target_mask = 0, export_mask = 0, wrap_mask = 0 };

make_string_ref := {start: i32, length: i32} => (
    { start = start, length = length }
);

set_error_with_code := {pos: i32, code: i32} => (
    if value_state.error != -1 then (
        0
    ) else (
        value_state.error = pos;
        value_state.error_code = code;
        debug_state.error_binding_count = binding_state.count;
        0
    );
    0
);

set_error: (i32 -> i32) := (pos: i32) => (
    if value_state.error != -1 then (
        0
    ) else (
        value_state.error = pos;
        value_state.error_code = interp_err_generic{};
        debug_state.error_binding_count = binding_state.count;
        0
    );
    0
);

reset_interpreter := {} => (
    value_state.count = 0;
    value_state.error = -1;
    value_state.error_code = interp_err_none{};
    binding_state.count = 0;
    binding_state.scope_count = 0;
    binding_temp.start = 0;
    binding_temp.length = 0;
    binding_temp.is_mut = 0;
    binding_temp.ok = 0;
    binding_target_state.depth = 0;
    binding_target_state.acc_mask = 0;
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    impl_state.count = 0;
    flow_state.kind = FlowKind::None;
    flow_state.value = -1;
    runtime_state.loop_depth = 0;
    runtime_state.function_depth = 0;
    runtime_state.option_enum_idx = -1;
    runtime_state.option_i32_enum_idx = -1;
    runtime_state.type_value_idx = -1;
    runtime_state.range_type_idx = -1;
    debug_state.error_binding_count = 0;
    debug_state.init_binding_count = 0;
    bind_pattern_state.value_idx = -1;
    bind_pattern_state.inherit_mut = 0;
    bind_pattern_state.inherit_target_mask = 0;
    bind_pattern_state.inherit_export_mask = 0;
    bind_pattern_state.inherit_wrap_mask = 0;
    intrinsic_state.binding_count = 0;
    reset_import_cache{};
    0
);

(export wasm) clear_file_registry := {} => (
    file_state.count = 0;
    0
);

(export wasm) register_file := {path_start: i32, path_length: i32, root_idx: i32} => (
    if file_state.count >= MAX_FILES then (
        -1
    ) else if path_length <= 0 || root_idx < 0 then (
        -1
    ) else (
        idx := file_state.count;
        files(idx).path_start = path_start;
        files(idx).path_length = path_length;
        files(idx).root_idx = root_idx;
        files(idx).import_value = -1;
        file_state.count = idx + 1;
        idx
    )
);

reset_import_cache := {} => (
    mut idx := 0;
    while idx < file_state.count do (
        files(idx).import_value = -1;
        idx = idx + 1;
        {}
    );
    0
);

enter_scope := {} => (
    if binding_state.scope_count >= MAX_SCOPES then (
        set_error(0);
        0
    ) else (
        scopes(binding_state.scope_count).scope = binding_state.count;
        binding_state.scope_count = binding_state.scope_count + 1;
        0
    )
);

exit_scope := {} => (
    if binding_state.scope_count <= 0 then (
        set_error(0);
        0
    ) else (
        binding_state.scope_count = binding_state.scope_count - 1;
        binding_state.count = scopes(binding_state.scope_count).scope;
        0
    )
);

save_scope_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scopes(idx).scope_backup = scopes(idx).scope;
        idx = idx + 1;
        {}
    );
    0
);

restore_scope_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scopes(idx).scope = scopes(idx).scope_backup;
        idx = idx + 1;
        {}
    );
    0
);

save_binding_target_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scopes(idx).binding_target_backup = scopes(idx).binding_target;
        idx = idx + 1;
        {}
    );
    0
);

restore_binding_target_stack := (count: i32) => (
    mut idx := 0;
    while idx < count do (
        scopes(idx).binding_target = scopes(idx).binding_target_backup;
        idx = idx + 1;
        {}
    );
    0
);

push_binding_target_mask := (mask: i32) => (
    if binding_target_state.depth >= MAX_SCOPES then (
        set_error(0);
        0
    ) else (
        scopes(binding_target_state.depth).binding_target = mask;
        binding_target_state.depth = binding_target_state.depth + 1;
        1
    )
);

pop_binding_target_mask := {} => (
    if binding_target_state.depth <= 0 then (
        set_error(0);
        0
    ) else (
        binding_target_state.depth = binding_target_state.depth - 1;
        1
    )
);

current_binding_target_mask := {} => (
    if binding_target_state.depth <= 0 then -1 else scopes(binding_target_state.depth - 1).binding_target
);

string_ref_equals := {left: StringRef, right: StringRef} => (
    if left.start < 0 || right.start < 0 then (
        if left.start == right.start && left.length == right.length then 1 else 0
    ) else if left.length != right.length then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left.length do (
            if input(left.start + idx) != input(right.start + idx) then (
                ok = 0;
                idx = left.length;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_equals_raw := {left_start: i32, left_len: i32, right_start: i32, right_len: i32} => (
    if left_start < 0 || right_start < 0 then (
        if left_start == right_start && left_len == right_len then 1 else (
            if left_start < 0 then (
                string_ref_equals_synthetic{left_start, left_len, right_start, right_len}
            ) else (
                string_ref_equals_synthetic{right_start, right_len, left_start, left_len}
            )
        )
    ) else if left_len != right_len then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left_len do (
            if input(left_start + idx) != input(right_start + idx) then (
                ok = 0;
                idx = left_len;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

string_ref_matches_1 := {value: StringRef, c0: u8} => (
    if value.start < 0 || value.length != 1 then 0
    else if input(value.start) == c0 then 1 else 0
);

string_ref_matches_2 := {value: StringRef, c0: u8, c1: u8} => (
    if value.start < 0 || value.length != 2 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 then 1 else 0
);

string_ref_matches_3 := {value: StringRef, c0: u8, c1: u8, c2: u8} => (
    if value.start < 0 || value.length != 3 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 && input(value.start + 2) == c2 then 1 else 0
);

string_ref_matches_4 := {value: StringRef, c0: u8, c1: u8, c2: u8, c3: u8} => (
    if value.start < 0 || value.length != 4 then 0
    else if input(value.start) == c0 && input(value.start + 1) == c1 && input(value.start + 2) == c2 && input(value.start + 3) == c3 then 1 else 0
);

string_ref_is_mut := (value: StringRef) => (
    if value.start == SYNTHETIC_MUT_STRING.start && value.length == SYNTHETIC_MUT_STRING.length then 1
    else string_ref_matches_3{value, 'm', 'u', 't'}
);


annotation_is_mut := (idx: i32) => (
    if idx == -1 then 0 else (
        nodes(idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::Literal(ExpressionLiteral::BindingAnnotation(value)) => (
                value |> match {
                    BindingAnnotationLiteral::Mut => 1,
                    else => 0
                }
            ),
            else => 0
        }
    )
);

annotations_has_mut := (head: i32) => (
    mut current := head;
    mut found := 0;
    while current != -1 do (
        if annotation_is_mut(list_nodes(current).value) == 1 then (
            found = 1;
            current = -1;
        ) else (
            current = list_nodes(current).next;
        );
        {}
    );
    found
);

resolve_annotation_flags := (head: i32) => (
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    mut current := head;
    mut ok := 1;
    while current != -1 do (
        ann_idx := list_nodes(current).value;
        ann_value_idx := eval_expression(ann_idx);
        if ann_value_idx == -1 then (
            ok = 0;
            current = -1;
        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
            ok = 0;
            current = -1;
        ) else (
            if Value::BindingAnnotation(ann) := values(ann_value_idx).value then (
                ann |> match {
                    BindingAnnotationValue::Mut => (
                        annotation_temp.is_mut = 1;
                        0
                    ),
                    BindingAnnotationValue::Target(target) => (
                        ann_mask := target_mask_from_target(target);
                        annotation_temp.target_mask = target_mask_or{annotation_temp.target_mask, ann_mask};
                        0
                    ),
                    BindingAnnotationValue::Export(target) => (
                        ann_mask := target_mask_from_target(target);
                        annotation_temp.export_mask = target_mask_or{annotation_temp.export_mask, ann_mask};
                        0
                    ),
                    BindingAnnotationValue::Wrap(target) => (
                        ann_mask := target_mask_from_target(target);
                        annotation_temp.wrap_mask = target_mask_or{annotation_temp.wrap_mask, ann_mask};
                        0
                    ),
                    else => 0
                };
                current = list_nodes(current).next;
            ) else (
                set_error(nodes(ann_idx).span.start);
                ok = 0;
                current = -1;
            )
        );
        {}
    );
    ok
);

expr_contains_mut_annotation := (expr_idx: i32) => (
    if expr_idx == -1 then 0 else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => string_ref_is_mut(id.name),
            NodeKind::FunctionCall(info) => (
                if expr_contains_mut_annotation(info.function) == 1 || expr_contains_mut_annotation(info.argument) == 1 then 1 else 0
            ),
            else => 0
        }
    )
);

resolve_binding_from_expr: (i32 -> i32) := (expr_idx: i32) => (
    if expr_idx == -1 then (
        binding_temp.start = 0;
        binding_temp.length = 0;
        binding_temp.is_mut = 0;
        binding_temp.ok = 0;
        0
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                binding_temp.start = id.name.start;
                binding_temp.length = id.name.length;
                binding_temp.is_mut = 0;
                binding_temp.ok = 1;
                1
            ),
            NodeKind::Operation(op) => (
                if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                    resolve_binding_from_expr(op.left)
                ) else (
                    binding_temp.start = 0;
                    binding_temp.length = 0;
                    binding_temp.is_mut = 0;
                    binding_temp.ok = 0;
                    0
                )
            ),
            NodeKind::FunctionCall(info) => (
                resolve_binding_from_expr(info.argument);
                if binding_temp.ok == 0 then (
                    0
                ) else (
                    mut_flag := expr_contains_mut_annotation(info.function);
                    binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                    binding_temp.ok = 1;
                    1
                )
            ),
            else => (
                binding_temp.start = 0;
                binding_temp.length = 0;
                binding_temp.is_mut = 0;
                binding_temp.ok = 0;
                0
            )
        }
    )
);

resolve_binding_pattern: (BindingPattern -> i32) := (pattern: BindingPattern) => (
    pattern |> match {
        BindingPattern::Identifier(info) => (
            binding_temp.start = info.name.name.start;
            binding_temp.length = info.name.name.length;
            binding_temp.is_mut = 0;
            binding_temp.ok = 1;
            1
        ),
        BindingPattern::Annotated(info) => (
            resolve_binding_from_expr(info.pattern);
            if binding_temp.ok == 0 then (
                0
            ) else (
                mut_flag := annotations_has_mut(info.annotations);
                binding_temp.is_mut = if binding_temp.is_mut == 1 || mut_flag == 1 then 1 else 0;
                binding_temp.ok = 1;
                1
            )
        ),
        BindingPattern::TypeHint(info) => resolve_binding_from_expr(info.pattern),
        else => (
            binding_temp.start = 0;
            binding_temp.length = 0;
            binding_temp.is_mut = 0;
            binding_temp.ok = 0;
            0
        )
    }
);

find_binding_index := (name: StringRef) => (
    mut idx := binding_state.count - 1;
    mut found := -1;
    while idx >= 0 do (
        if string_ref_equals_raw{
            bindings(idx).name_start,
            bindings(idx).name_length,
            name.start,
            name.length
        } == 1 then (
            found = idx;
            idx = -1;
        ) else (
            idx = idx - 1;
        );
        {}
    );
    found
);

find_file_index := (name: StringRef) => (
    mut idx := file_state.count - 1;
    mut found := -1;
    while idx >= 0 do (
        if string_ref_equals_raw{
            files(idx).path_start,
            files(idx).path_length,
            name.start,
            name.length
        } == 1 then (
            found = idx;
            idx = -1;
        ) else (
            idx = idx - 1;
        );
        {}
    );
    found
);

eval_use_from_string := {path_ref: StringRef, span_start: i32} => (
    file_idx := find_file_index(path_ref);
    if file_idx == -1 then (
        set_error(span_start);
        -1
    ) else (
        cached_idx := files(file_idx).import_value;
        if cached_idx != -1 then (
            cached_idx
        ) else (
            import_idx := eval_import_root{files(file_idx).root_idx, span_start};
            if import_idx == -1 then (
                -1
            ) else (
                files(file_idx).import_value = import_idx;
                import_idx
            )
        )
    )
);

ensure_binding_target_access := {binding_idx: i32, span_start: i32} => (
    required_mask := bindings(binding_idx).target_mask;
    if required_mask == 0 then (
        1
    ) else (
        current_mask := current_binding_target_mask{};
        if current_mask <= 0 || target_mask_allows{required_mask, current_mask} == 0 then (
            set_error(span_start);
            0
        ) else 1
    )
);

string_ref_is_js := (value: StringRef) => (
    if value.start == SYNTHETIC_JS_STRING.start && value.length == SYNTHETIC_JS_STRING.length then 1
    else string_ref_matches_2{value, 'j', 's'}
);

string_ref_is_wasm := (value: StringRef) => (
    if value.start == SYNTHETIC_WASM_STRING.start && value.length == SYNTHETIC_WASM_STRING.length then 1
    else string_ref_matches_4{value, 'w', 'a', 's', 'm'}
);

string_ref_is_wgsl := (value: StringRef) => (
    if value.start == SYNTHETIC_WGSL_STRING.start && value.length == SYNTHETIC_WGSL_STRING.length then 1
    else string_ref_matches_4{value, 'w', 'g', 's', 'l'}
);

ensure_asm_target_allowed := {target_tag: i32, span_start: i32} => (
    current_mask := current_binding_target_mask{};
    if current_mask <= 0 || target_mask_has{current_mask, target_tag} == 0 then (
        set_error(span_start);
        0
    ) else 1
);

add_binding := {start: i32, length: i32, value: i32, is_mut: i32} => (
    if binding_state.count >= MAX_BINDINGS then (
        set_error(0);
        -1
    ) else (
        idx := binding_state.count;
        bindings(idx).name_start = start;
        bindings(idx).name_length = length;
        bindings(idx).value = value;
        bindings(idx).is_mut = is_mut;
        bindings(idx).type_value = -1;
        bindings(idx).target_mask = 0;
        bindings(idx).export_mask = 0;
        bindings(idx).wrap_mask = 0;
        binding_state.count = idx + 1;
        idx
    )
);

add_binding_with_metadata := {
    start: i32,
    length: i32,
    value_idx: i32,
    is_mut: i32,
    type_value_idx: i32,
    target_mask: i32,
    export_mask: i32,
    wrap_mask: i32
} => (
    bind_idx := add_binding{start, length, value_idx, is_mut};
    if bind_idx == -1 then (
        -1
    ) else (
        bindings(bind_idx).type_value = type_value_idx;
        bindings(bind_idx).target_mask = target_mask;
        bindings(bind_idx).export_mask = export_mask;
        bindings(bind_idx).wrap_mask = wrap_mask;
        bind_idx
    )
);

capture_closure_bindings := {} => (
    head := value_state.count;
    if binding_state.count <= intrinsic_state.binding_count then (
        { head = head, count = 0 }
    ) else (
        idx := binding_state.count - 1;
        name_idx := store_value(Value::String(make_string_ref{
            bindings(idx).name_start,
            bindings(idx).name_length
        }));
        if name_idx == -1 then (
            { head = -1, count = 0 }
        ) else (
            captured_value_idx := copy_value(bindings(idx).value);
            if captured_value_idx == -1 then (
                { head = -1, count = 0 }
            ) else (
                is_mut_idx := store_value(Value::Number(bindings(idx).is_mut));
                if is_mut_idx == -1 then (
                    { head = -1, count = 0 }
                ) else (
                    type_idx := store_value(Value::Number(bindings(idx).type_value));
                    if type_idx == -1 then (
                        { head = -1, count = 0 }
                    ) else (
                        target_idx := store_value(Value::Number(bindings(idx).target_mask));
                        if target_idx == -1 then (
                            { head = -1, count = 0 }
                        ) else (
                            export_idx := store_value(Value::Number(bindings(idx).export_mask));
                            if export_idx == -1 then (
                                { head = -1, count = 0 }
                            ) else (
                                wrap_idx := store_value(Value::Number(bindings(idx).wrap_mask));
                                if wrap_idx == -1 then (
                                    { head = -1, count = 0 }
                                ) else (
                                    { head = head, count = 1 }
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

restore_closure_bindings := {head: i32, count: i32} => (
    if count <= 0 then (
        1
    ) else if head < 0 then (
        set_error(0);
        0
    ) else (
        mut restored := 0;
        mut ok := 1;
        while restored < count && ok == 1 do (
            base := head + restored * 7;
            if base < 0 || base + 6 >= value_state.count then (
                set_error(0);
                ok = 0;
            ) else (
                if Value::String(name_ref) := values(base).value then (
                    restored_value_idx := copy_value(base + 1);
                    if restored_value_idx == -1 then (
                        ok = 0;
                    ) else if Value::Number(restored_is_mut) := values(base + 2).value then (
                        if Value::Number(restored_type) := values(base + 3).value then (
                            if Value::Number(restored_target_mask) := values(base + 4).value then (
                                if Value::Number(restored_export_mask) := values(base + 5).value then (
                                    if Value::Number(restored_wrap_mask) := values(base + 6).value then (
                                        bind_idx := add_binding_with_metadata{
                                            name_ref.start,
                                            name_ref.length,
                                            restored_value_idx,
                                            restored_is_mut,
                                            restored_type,
                                            restored_target_mask,
                                            restored_export_mask,
                                            restored_wrap_mask
                                        };
                                        if bind_idx == -1 then (
                                            ok = 0;
                                        ) else (
                                            restored = restored + 1;
                                        )
                                    ) else (
                                        set_error(0);
                                        ok = 0;
                                    )
                                ) else (
                                    set_error(0);
                                    ok = 0;
                                )
                            ) else (
                                set_error(0);
                                ok = 0;
                            )
                        ) else (
                            set_error(0);
                            ok = 0;
                        )
                    ) else (
                        set_error(0);
                        ok = 0;
                    )
                ) else (
                    set_error(0);
                    ok = 0;
                )
            );
            {}
        );
        ok
    )
);

new_list_node := {value: i32, next: i32} => (
    if state.list_count >= MAX_LIST_NODES then (
        set_error(0);
        -1
    ) else (
        idx := state.list_count;
        list_nodes(idx).value = value;
        list_nodes(idx).next = next;
        state.list_count = idx + 1;
        idx
    )
);

add_intrinsic_binding := {name: StringRef} => (
    value_idx := store_value(Value::String(name));
    if value_idx == -1 then (
        -1
    ) else (
        bind_idx := add_binding{name.start, name.length, value_idx, 0};
        if bind_idx == -1 then (
            -1
        ) else (
            ensure_type_value_idx{};
            if runtime_state.type_value_idx == -1 then (
                -1
            ) else (
                values(value_idx).type_value = runtime_state.type_value_idx;
                bind_idx
            )
        )
    )
);

add_intrinsic_binding_value := {name: StringRef, value: Value} => (
    value_idx := store_value(value);
    if value_idx == -1 then (
        -1
    ) else (
        add_binding{name.start, name.length, value_idx, 0}
    )
);

add_intrinsic_target_binding_value := {name: StringRef, target_tag: TargetTag, target_type_idx: i32} => (
    bind_idx := add_intrinsic_binding_value{name, Value::Target(target_tag)};
    if bind_idx == -1 then (
        -1
    ) else (
        value_idx := bindings(bind_idx).value;
        values(value_idx).type_value = target_type_idx;
        bind_idx
    )
);

option_enum_from_type := {payload_type_idx: i32, span_start: i32} => (
    if value_is_type_like(payload_type_idx) == 0 then (
        set_error(span_start);
        -1
    ) else (
        start_idx := value_state.count;
        name_idx := store_value(Value::String(SYNTHETIC_SOME_STRING));
        if name_idx == -1 then (
            -1
        ) else (
            payload_idx := copy_value(payload_type_idx);
            if payload_idx == -1 then (
                -1
            ) else (
                name_idx2 := store_value(Value::String(SYNTHETIC_NONE_STRING));
                if name_idx2 == -1 then (
                    -1
                ) else (
                    payload_idx2 := store_value(Value::Unit);
                    if payload_idx2 == -1 then (
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = start_idx, count = 2 }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                )
            )
        )
    )
);

init_option_enum := {} => (
    type_bind_idx := find_binding_index(SYNTHETIC_TYPE_STRING);
    if type_bind_idx == -1 then (
        -1
    ) else (
        type_value_idx := bindings(type_bind_idx).value;
        option_type_idx := option_enum_from_type{type_value_idx, 0};
        if option_type_idx == -1 then (
            -1
        ) else (
            runtime_state.option_enum_idx = option_type_idx;
            i32_bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
            if i32_bind_idx == -1 then (
                -1
            ) else (
                option_i32_idx := option_enum_from_type{bindings(i32_bind_idx).value, 0};
                if option_i32_idx == -1 then (
                    -1
                ) else (
                    runtime_state.option_i32_enum_idx = option_i32_idx;
                    0
                )
            )
        )
    )
);

init_range_binding := {} => (
    i32_bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
    if i32_bind_idx == -1 then (
        -1
    ) else (
        i32_type_idx := bindings(i32_bind_idx).value;
        range_type_start := value_state.count;
        name_current := store_value(Value::String(SYNTHETIC_CURRENT_STRING));
        if name_current == -1 then (
            -1
        ) else (
            current_ty := copy_value(i32_type_idx);
            if current_ty == -1 then (
                -1
            ) else (
                name_end := store_value(Value::String(SYNTHETIC_END_STRING));
                if name_end == -1 then (
                    -1
                ) else (
                    end_ty := copy_value(i32_type_idx);
                    if end_ty == -1 then (
                        -1
                    ) else (
                        name_iter_ty := store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
                        if name_iter_ty == -1 then (
                            -1
                        ) else (
                            iter_ty := copy_value(i32_type_idx);
                            if iter_ty == -1 then (
                                -1
                            ) else (
                                name_next := store_value(Value::String(SYNTHETIC_NEXT_STRING));
                                if name_next == -1 then (
                                    -1
                                ) else (
                                    next_value := store_value(Value::Builtin(builtin_range_next{}));
                                    if next_value == -1 then (
                                        -1
                                    ) else (
                        raw_range_type_idx := store_value(Value::Record({
                            head = range_type_start,
                            count = 4,
                            has_named = 1
                        }));
                        if raw_range_type_idx == -1 then (
                            -1
                        ) else (
                            range_type_idx := mark_value_as_type(raw_range_type_idx);
                            if range_type_idx == -1 then (
                                -1
                            ) else if add_binding{
                                SYNTHETIC_RANGE_STRING.start,
                                SYNTHETIC_RANGE_STRING.length,
                                range_type_idx,
                                0
                            } == -1 then (
                                -1
                            ) else (
                                runtime_state.range_type_idx = range_type_idx;
                                0
                            )
                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

add_intrinsic_impl_field := {name: StringRef, value: Value} => (
    name_idx := store_value(Value::String(name));
    if name_idx == -1 then (
        -1
    ) else (
        store_value(value)
    )
);

init_i32_intrinsic_impl := {type_idx: i32} => (
    impl_start := value_state.count;
    if add_intrinsic_impl_field{SYNTHETIC_OP_ADD_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Add)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_SUBTRACT_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Subtract)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_MULTIPLY_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Multiply)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_DIVIDE_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Divide)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Equal)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_NOT_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32NotEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_LESS_THAN_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32LessThan)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_GREATER_THAN_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32GreaterThan)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_LESS_THAN_OR_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32LessThanOrEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_GREATER_THAN_OR_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32GreaterThanOrEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_RANGE_STRING, Value::RangeMethod} == -1 then (
        -1
    ) else (
        impl_value_idx := store_value(Value::Record({
            head = impl_start,
            count = 11,
            has_named = 1
        }));
        if impl_value_idx == -1 then (
            -1
        ) else (
            impl_add{type_idx, impl_value_idx}
        )
    )
);

init_u8_intrinsic_impl := {type_idx: i32} => (
    impl_start := value_state.count;
    if add_intrinsic_impl_field{SYNTHETIC_OP_ADD_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Add)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_SUBTRACT_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Subtract)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_MULTIPLY_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Multiply)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_DIVIDE_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Divide)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Equal)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_NOT_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32NotEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_LESS_THAN_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32LessThan)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_GREATER_THAN_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32GreaterThan)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_LESS_THAN_OR_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32LessThanOrEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_GREATER_THAN_OR_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32GreaterThanOrEqual)} == -1 then (
        -1
    ) else (
        impl_value_idx := store_value(Value::Record({
            head = impl_start,
            count = 10,
            has_named = 1
        }));
        if impl_value_idx == -1 then (
            -1
        ) else (
            impl_add{type_idx, impl_value_idx}
        )
    )
);

init_bool_intrinsic_impl := {type_idx: i32} => (
    impl_start := value_state.count;
    if add_intrinsic_impl_field{SYNTHETIC_OP_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Equal)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_NOT_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32NotEqual)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_AND_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::BooleanAnd)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_OR_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::BooleanOr)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_XOR_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::BooleanXor)} == -1 then (
        -1
    ) else (
        impl_value_idx := store_value(Value::Record({
            head = impl_start,
            count = 5,
            has_named = 1
        }));
        if impl_value_idx == -1 then (
            -1
        ) else (
            impl_add{type_idx, impl_value_idx}
        )
    )
);

init_eq_intrinsic_impl := {type_idx: i32} => (
    impl_start := value_state.count;
    if add_intrinsic_impl_field{SYNTHETIC_OP_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32Equal)} == -1 then (
        -1
    ) else if add_intrinsic_impl_field{SYNTHETIC_OP_NOT_EQUAL_STRING, Value::IntrinsicBinaryMethod(BinaryIntrinsicOperator::I32NotEqual)} == -1 then (
        -1
    ) else (
        impl_value_idx := store_value(Value::Record({
            head = impl_start,
            count = 2,
            has_named = 1
        }));
        if impl_value_idx == -1 then (
            -1
        ) else (
            impl_add{type_idx, impl_value_idx}
        )
    )
);

init_intrinsic_operator_impls := {} => (
    i32_bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
    if i32_bind_idx == -1 then (
        -1
    ) else (
        u8_bind_idx := find_binding_index(SYNTHETIC_U8_STRING);
        if u8_bind_idx == -1 then (
            -1
        ) else (
            bool_bind_idx := find_binding_index(SYNTHETIC_BOOL_STRING);
            if bool_bind_idx == -1 then (
                -1
            ) else (
                target_type_bind_idx := find_binding_index(SYNTHETIC_TARGET_TYPE_BINDING_STRING);
                if target_type_bind_idx == -1 then (
                    -1
                ) else (
                    binding_annotation_bind_idx := find_binding_index(SYNTHETIC_BINDING_ANNOTATION_STRING);
                    if binding_annotation_bind_idx == -1 then (
                        -1
                    ) else (
                        i32_type_idx := bindings(i32_bind_idx).value;
                        u8_type_idx := bindings(u8_bind_idx).value;
                        bool_type_idx := bindings(bool_bind_idx).value;
                        target_type_idx := bindings(target_type_bind_idx).value;
                        binding_annotation_type_idx := bindings(binding_annotation_bind_idx).value;
                        if init_i32_intrinsic_impl{i32_type_idx} == -1 then (
                            -1
                        ) else if init_u8_intrinsic_impl{u8_type_idx} == -1 then (
                            -1
                        ) else if init_bool_intrinsic_impl{bool_type_idx} == -1 then (
                            -1
                        ) else if init_eq_intrinsic_impl{target_type_idx} == -1 then (
                            -1
                        ) else (
                            init_eq_intrinsic_impl{binding_annotation_type_idx}
                        )
                    )
                )
            )
        )
    )
);

init_intrinsic_context := {} => (
    if add_intrinsic_binding{SYNTHETIC_TYPE_STRING} == -1 then -1 else (
        if add_intrinsic_binding{SYNTHETIC_I32_STRING} == -1 then -1 else (
            if add_intrinsic_binding{SYNTHETIC_U8_STRING} == -1 then -1 else (
                if add_intrinsic_binding{SYNTHETIC_BOOL_STRING} == -1 then -1 else (
                    if add_intrinsic_binding{SYNTHETIC_BINDING_ANNOTATION_STRING} == -1 then -1 else (
                        target_type_value_idx := store_value(Value::String(SYNTHETIC_TARGET_STRING));
                        if target_type_value_idx == -1 then -1 else (
                            if mark_value_as_type(target_type_value_idx) == -1 then -1 else (
                                if add_binding{
                                    SYNTHETIC_TARGET_TYPE_BINDING_STRING.start,
                                    SYNTHETIC_TARGET_TYPE_BINDING_STRING.length,
                                    target_type_value_idx,
                                    0
                                } == -1 then -1 else (
                                    if add_intrinsic_binding_value{SYNTHETIC_MUT_STRING, Value::BindingAnnotation(BindingAnnotationValue::Mut)} == -1 then -1 else (
                                        if add_intrinsic_target_binding_value{SYNTHETIC_JS_STRING, TargetTag::Js, target_type_value_idx} == -1 then -1 else (
                                            if add_intrinsic_target_binding_value{SYNTHETIC_WASM_STRING, TargetTag::Wasm, target_type_value_idx} == -1 then -1 else (
                                                if add_intrinsic_target_binding_value{SYNTHETIC_WGSL_STRING, TargetTag::Wgsl, target_type_value_idx} == -1 then -1 else (
                                                    if init_option_enum{} == -1 then -1 else (
                                                        if init_range_binding{} == -1 then -1 else (
                                                            if init_intrinsic_operator_impls{} == -1 then -1 else (
                                                                intrinsic_state.binding_count = binding_state.count;
                                                                0
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

ensure_import_intrinsics := {} => (
    if intrinsic_state.binding_count > 0 then (
        if find_binding_index(SYNTHETIC_TYPE_STRING) != -1
            && find_binding_index(SYNTHETIC_I32_STRING) != -1
            && find_binding_index(SYNTHETIC_U8_STRING) != -1
            && find_binding_index(SYNTHETIC_BOOL_STRING) != -1
            && find_binding_index(SYNTHETIC_BINDING_ANNOTATION_STRING) != -1
            && find_binding_index(SYNTHETIC_TARGET_TYPE_BINDING_STRING) != -1
        then 0 else (
            binding_state.count = 0;
            binding_state.scope_count = 0;
            init_intrinsic_context{}
        )
    ) else (
        binding_state.count = 0;
        binding_state.scope_count = 0;
        init_intrinsic_context{}
    )
);

list_append := {head: i32, value: i32} => (
    if head == -1 then (
        new_list_node{value, -1}
    ) else (
        mut cur := head;
        while list_nodes(cur).next != -1 do (
            cur = list_nodes(cur).next;
            {}
        );
        new_idx := new_list_node{value, -1};
        list_nodes(cur).next = new_idx;
        head
    )
);

extract_binding_annotations := (expr_idx: i32) => (
    mut current := expr_idx;
    mut args_head := -1;
    mut continue := 1;
    while continue == 1 do (
        if NodeKind::FunctionCall(info) := nodes(current).kind then (
            if NodeKind::FunctionCall(_) := nodes(info.function).kind then (
                args_head = new_list_node{info.argument, args_head};
                current = info.function;
            ) else (
                continue = 0;
            )
        ) else (
            continue = 0;
        );
        {}
    );
    mut head := new_list_node{current, -1};
    mut arg_cur := args_head;
    while arg_cur != -1 do (
        head = list_append{head, list_nodes(arg_cur).value};
        arg_cur = list_nodes(arg_cur).next;
        {}
    );
    head
);

string_ref_is_enum := (value: StringRef) => (
    string_ref_matches_4{value, 'e', 'n', 'u', 'm'}
);

string_ref_is_match := (value: StringRef) => (
    if value.start < 0 || value.length != 5 then 0
    else if input(value.start) == 'm'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 't'
        && input(value.start + 3) == 'c'
        && input(value.start + 4) == 'h'
    then 1 else 0
);

string_ref_is_use := (value: StringRef) => (
    string_ref_matches_3{value, 'u', 's', 'e'}
);

string_ref_is_option := (value: StringRef) => (
    if value.start == SYNTHETIC_OPTION_STRING.start && value.length == SYNTHETIC_OPTION_STRING.length then 1
    else if value.start < 0 || value.length != 6 then 0
    else if input(value.start) == 'O'
        && input(value.start + 1) == 'p'
        && input(value.start + 2) == 't'
        && input(value.start + 3) == 'i'
        && input(value.start + 4) == 'o'
        && input(value.start + 5) == 'n'
    then 1 else 0
);

string_ref_is_some := (value: StringRef) => (
    if value.start == SYNTHETIC_SOME_STRING.start && value.length == SYNTHETIC_SOME_STRING.length then 1
    else string_ref_matches_4{value, 'S', 'o', 'm', 'e'}
);

string_ref_is_none := (value: StringRef) => (
    if value.start == SYNTHETIC_NONE_STRING.start && value.length == SYNTHETIC_NONE_STRING.length then 1
    else string_ref_matches_4{value, 'N', 'o', 'n', 'e'}
);

string_ref_is_iterator := (value: StringRef) => (
    if value.start < 0 || value.length != 8 then 0
    else if input(value.start) == 'I'
        && input(value.start + 1) == 't'
        && input(value.start + 2) == 'e'
        && input(value.start + 3) == 'r'
        && input(value.start + 4) == 'a'
        && input(value.start + 5) == 't'
        && input(value.start + 6) == 'o'
        && input(value.start + 7) == 'r'
    then 1 else 0
);

string_ref_is_iter_ty := (value: StringRef) => (
    if value.start == SYNTHETIC_ITER_TY_STRING.start && value.length == SYNTHETIC_ITER_TY_STRING.length then 1
    else if value.start < 0 || value.length != 7 then 0
    else if input(value.start) == 'i'
        && input(value.start + 1) == 't'
        && input(value.start + 2) == 'e'
        && input(value.start + 3) == 'r'
        && input(value.start + 4) == '_'
        && input(value.start + 5) == 't'
        && input(value.start + 6) == 'y'
    then 1 else 0
);

string_ref_is_next := (value: StringRef) => (
    if value.start == SYNTHETIC_NEXT_STRING.start && value.length == SYNTHETIC_NEXT_STRING.length then 1
    else string_ref_matches_4{value, 'n', 'e', 'x', 't'}
);

string_ref_is_for_iter := (value: StringRef) => (
    if value.start == SYNTHETIC_FOR_ITER_STRING.start && value.length == SYNTHETIC_FOR_ITER_STRING.length then 1
    else if value.start < 0 || value.length != 10 then 0
    else if input(value.start) == '_'
        && input(value.start + 1) == '_'
        && input(value.start + 2) == 'f'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == '_'
        && input(value.start + 6) == 'i'
        && input(value.start + 7) == 't'
        && input(value.start + 8) == 'e'
        && input(value.start + 9) == 'r'
    then 1 else 0
);

string_ref_is_current := (value: StringRef) => (
    if value.start == SYNTHETIC_CURRENT_STRING.start && value.length == SYNTHETIC_CURRENT_STRING.length then 1
    else if value.start < 0 || value.length != 7 then 0
    else if input(value.start) == 'c'
        && input(value.start + 1) == 'u'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'r'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 'n'
        && input(value.start + 6) == 't'
    then 1 else 0
);

string_ref_is_end := (value: StringRef) => (
    if value.start == SYNTHETIC_END_STRING.start && value.length == SYNTHETIC_END_STRING.length then 1
    else string_ref_matches_3{value, 'e', 'n', 'd'}
);

string_ref_is_range := (value: StringRef) => (
    if value.start == SYNTHETIC_RANGE_STRING.start && value.length == SYNTHETIC_RANGE_STRING.length then 1
    else if value.start < 0 || value.length != 5 then 0
    else if input(value.start) == 'R'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'n'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
    then 1 else 0
);

string_ref_is_i32 := (value: StringRef) => (
    string_ref_matches_3{value, 'i', '3', '2'}
);

string_ref_is_u8 := (value: StringRef) => (
    string_ref_matches_2{value, 'u', '8'}
);

string_ref_is_bool := (value: StringRef) => (
    string_ref_matches_4{value, 'b', 'o', 'o', 'l'}
);

string_ref_is_type := (value: StringRef) => (
    string_ref_matches_4{value, 't', 'y', 'p', 'e'}
);

string_ref_is_target := (value: StringRef) => (
    if value.start < 0 || value.length != 6 then 0
    else if input(value.start) == 't'
        && input(value.start + 1) == 'a'
        && input(value.start + 2) == 'r'
        && input(value.start + 3) == 'g'
        && input(value.start + 4) == 'e'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_binding_annotation := (value: StringRef) => (
    if value.start < 0 || value.length != 18 then 0
    else if input(value.start) == 'b'
        && input(value.start + 1) == 'i'
        && input(value.start + 2) == 'n'
        && input(value.start + 3) == 'd'
        && input(value.start + 4) == 'i'
        && input(value.start + 5) == 'n'
        && input(value.start + 6) == 'g'
        && input(value.start + 7) == '_'
        && input(value.start + 8) == 'a'
        && input(value.start + 9) == 'n'
        && input(value.start + 10) == 'n'
        && input(value.start + 11) == 'o'
        && input(value.start + 12) == 't'
        && input(value.start + 13) == 'a'
        && input(value.start + 14) == 't'
        && input(value.start + 15) == 'i'
        && input(value.start + 16) == 'o'
        && input(value.start + 17) == 'n'
    then 1 else 0
);

string_ref_is_underscore := (value: StringRef) => (
    string_ref_matches_1{value, '_'}
);

string_ref_is_else := (value: StringRef) => (
    string_ref_matches_4{value, 'e', 'l', 's', 'e'}
);

builtin_from_identifier := (name: StringRef) => (
    if string_ref_is_enum(name) == 1 then builtin_enum{}
    else if string_ref_is_match(name) == 1 then builtin_match{}
    else if string_ref_is_option(name) == 1 then builtin_option{}
    else if string_ref_is_iterator(name) == 1 then builtin_iterator{}
    else if string_ref_is_export(name) == 1 then builtin_export{}
    else if string_ref_is_target(name) == 1 then builtin_target{}
    else if string_ref_is_wrap(name) == 1 then builtin_wrap{}
    else if string_ref_is_asm(name) == 1 then builtin_asm{}
    else if string_ref_is_use(name) == 1 then builtin_use{}
    else -1
);

string_ref_to_i32 := {start: i32, length: i32} => (
    if start < 0 then (
        -1
    ) else if length <= 0 then (
        -1
    ) else (
        mut idx := 0;
        mut acc := 0;
        mut ok := 1;
        while idx < length do (
            ch := input(start + idx);
            if ch < '0' || ch > '9' then (
                ok = 0;
                idx = length;
            ) else (
                acc = acc * 10 + (ch - '0');
                idx = idx + 1;
            );
            {}
        );
        if ok == 1 then acc else -1
    )
);

record_value_index_by_position := {start: i32, count: i32, has_named: i32, index: i32, span_start: i32} => (
    if index < 0 then (
        set_error_with_code{span_start, interp_err_array_index_out_of_range{}};
        -1
    ) else if index >= count then (
        set_error_with_code{span_start, interp_err_array_index_out_of_range{}};
        -1
    ) else (
        if has_named == -1 then (
            start + 1
        ) else (
            start + index * 2 + 1
        )
    )
);

record_find_field_index := {start: i32, count: i32, has_named: i32, name_start: i32, name_length: i32, span_start: i32} => (
    mut found := -1;
    if has_named == 1 && name_length > 0 then (
        mut idx := 0;
        while idx < count do (
            name_idx := start + idx * 2;
            if Value::String(name_ref) := values(name_idx).value then (
                if string_ref_equals_raw{
                    name_ref.start,
                    name_ref.length,
                    name_start,
                    name_length
                } == 1 then (
                    found = name_idx + 1;
                    idx = count;
                ) else (
                    idx = idx + 1;
                )
            ) else (
                idx = idx + 1;
            );
            {}
        );
        0
    ) else (
        0
    );
    if found != -1 then (
        found
    ) else (
        idx_num := string_ref_to_i32{name_start, name_length};
        if idx_num < 0 then (
            set_error(span_start);
            -1
        ) else (
            record_value_index_by_position{start, count, has_named, idx_num, span_start}
        )
    )
);

string_ref_is_export := (value: StringRef) => (
    if value.start < 0 || value.length != 6 then 0
    else if input(value.start) == 'e'
        && input(value.start + 1) == 'x'
        && input(value.start + 2) == 'p'
        && input(value.start + 3) == 'o'
        && input(value.start + 4) == 'r'
        && input(value.start + 5) == 't'
    then 1 else 0
);

string_ref_is_wrap := (value: StringRef) => (
    string_ref_matches_4{value, 'w', 'r', 'a', 'p'}
);

string_ref_is_asm := (value: StringRef) => (
    string_ref_matches_3{value, 'a', 's', 'm'}
);

record_name_index_by_position_no_error := {start: i32, count: i32, has_named: i32, index: i32} => (
    if index < 0 then (
        -1
    ) else if index >= count then (
        -1
    ) else (
        if has_named == -1 then (
            start
        ) else (
            start + index * 2
        )
    )
);

record_value_index_by_position_no_error := {start: i32, count: i32, has_named: i32, index: i32} => (
    if index < 0 then (
        -1
    ) else if index >= count then (
        -1
    ) else (
        if has_named == -1 then (
            start + 1
        ) else (
            start + index * 2 + 1
        )
    )
);

record_find_field_index_no_error := {start: i32, count: i32, has_named: i32, name_start: i32, name_length: i32} => (
    mut found := -1;
    if has_named == 1 && name_length > 0 then (
        mut idx := 0;
        while idx < count do (
            name_idx := start + idx * 2;
            if Value::String(name_ref) := values(name_idx).value then (
                if string_ref_equals_raw{
                    name_ref.start,
                    name_ref.length,
                    name_start,
                    name_length
                } == 1 then (
                    found = name_idx + 1;
                    idx = count;
                ) else (
                    idx = idx + 1;
                )
            ) else (
                idx = idx + 1;
            );
            {}
        );
        0
    ) else (
        0
    );
    if found != -1 then (
        found
    ) else (
        idx_num := string_ref_to_i32{name_start, name_length};
        if idx_num < 0 then (
            -1
        ) else (
            record_value_index_by_position_no_error{start, count, has_named, idx_num}
        )
    )
);

materialize_repeated_record := {record_idx: i32, span_start: i32} => (
    if record_idx == -1 then (
        -1
    ) else (
        if Value::Record(rec_info) := values(record_idx).value then (
            if rec_info.has_named != -1 || rec_info.count <= 1 then (
                record_idx
            ) else (
                source_name_idx := rec_info.head;
                source_value_idx := rec_info.head + 1;
                start_idx := value_state.count;
                mut idx := 0;
                while idx < rec_info.count do (
                    name_idx := store_value(values(source_name_idx).value);
                    if name_idx == -1 then (
                        idx = rec_info.count;
                    ) else (
                        value_idx := store_value(values(source_value_idx).value);
                        if value_idx == -1 then (
                            idx = rec_info.count;
                        ) else (
                            idx = idx + 1;
                        );
                    );
                    {}
                );
                if value_state.error != -1 then (
                    -1
                ) else (
                    values(record_idx).value = Value::Record({ head = start_idx, count = rec_info.count, has_named = 0 });
                    record_idx
                )
            )
        ) else (
            set_error(span_start);
            -1
        )
    )
);

resolve_lvalue_root_binding_from_expr := (expr_idx: i32) => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => find_binding_index(id.name),
            NodeKind::TypePropertyAccess(access) => resolve_lvalue_root_binding_from_expr(access.object),
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                    if call.argument == access.object then (
                        resolve_lvalue_root_binding_from_expr(access.object)
                    ) else (
                        -1
                    )
                ) else (
                    resolve_lvalue_root_binding_from_expr(call.function)
                )
            ),
            else => -1
        }
    )
);

resolve_lvalue_expr_value_index := {expr_idx: i32, span_start: i32} => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Identifier(id) => (
                bind_idx := find_binding_index(id.name);
                if bind_idx == -1 then (
                    set_error_with_code{span_start, interp_err_unbound_identifier{}};
                    -1
                ) else (
                    bindings(bind_idx).value
                )
            ),
            NodeKind::TypePropertyAccess(access) => (
                obj_idx := resolve_lvalue_expr_value_index{access.object, span_start};
                if obj_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    obj_idx
                ) else (
                    if Value::Record(struct_info) := values(obj_idx).value then (
                        record_find_field_index{
                            struct_info.head,
                            struct_info.count,
                            struct_info.has_named,
                            access.property.start,
                            access.property.length,
                            span_start
                        }
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                    if call.argument == access.object then (
                        obj_idx := resolve_lvalue_expr_value_index{access.object, span_start};
                        if obj_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            obj_idx
                        ) else (
                            if Value::Record(struct_info) := values(obj_idx).value then (
                                record_find_field_index{
                                    struct_info.head,
                                    struct_info.count,
                                    struct_info.has_named,
                                    access.property.start,
                                    access.property.length,
                                    span_start
                                }
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                ) else (
                    arr_idx := resolve_lvalue_expr_value_index{call.function, span_start};
                    if arr_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        arr_idx
                    ) else (
                        index_idx := eval_expression(call.argument);
                        if index_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            index_idx
                        ) else (
                            if Value::Number(index_value) := values(index_idx).value then (
                                if Value::Record(struct_info) := values(arr_idx).value then (
                                    arr_idx2 := if struct_info.has_named == -1 then (
                                        materialize_repeated_record{arr_idx, span_start}
                                    ) else (
                                        arr_idx
                                    );
                                    if arr_idx2 == -1 then (
                                        -1
                                    ) else (
                                        if Value::Record(struct_info2) := values(arr_idx2).value then (
                                            record_value_index_by_position{
                                                struct_info2.head,
                                                struct_info2.count,
                                                struct_info2.has_named,
                                                index_value,
                                                span_start
                                            }
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                ) else (
                                    set_error(span_start);
                                    -1
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    )
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

impl_add := {type_idx: i32, impl_idx: i32} => (
    if impl_state.count >= MAX_IMPLS then (
        set_error(0);
        -1
    ) else (
        idx := impl_state.count;
        implementations(idx).type_value = type_idx;
        implementations(idx).value = impl_idx;
        impl_state.count = idx + 1;
        idx
    )
);

type_values_equal := {left_idx: i32, right_idx: i32} => (
    if left_idx < 0 || right_idx < 0 then 0 else (
        if left_idx == right_idx then 1 else (
            left := values(left_idx).value;
            right := values(right_idx).value;
            if value_is_box_type_flag(left_idx) == 1 || value_is_box_type_flag(right_idx) == 1 then (
                if value_is_box_type_flag(left_idx) == 1 && value_is_box_type_flag(right_idx) == 1 then (
                    if Value::Record(lrec) := left then (
                        if Value::Record(rrec) := right then (
                            if lrec.has_named == 0 && rrec.has_named == 0 && lrec.count == 1 && rrec.count == 1 then (
                                type_values_equal{lrec.head + 1, rrec.head + 1}
                            ) else 0
                        ) else 0
                    ) else 0
                ) else 0
            ) else (
                left |> match {
                    Value::String(lstr) => (
                        if Value::String(rstr) := right then (
                            if string_ref_equals_raw{lstr.start, lstr.length, rstr.start, rstr.length} == 1 then (
                                1
                            ) else (
                                left_is_i32 := string_ref_equals_raw{
                                    lstr.start,
                                    lstr.length,
                                    SYNTHETIC_I32_STRING.start,
                                    SYNTHETIC_I32_STRING.length
                                };
                                left_is_u8 := string_ref_equals_raw{
                                    lstr.start,
                                    lstr.length,
                                    SYNTHETIC_U8_STRING.start,
                                    SYNTHETIC_U8_STRING.length
                                };
                                right_is_i32 := string_ref_equals_raw{
                                    rstr.start,
                                    rstr.length,
                                    SYNTHETIC_I32_STRING.start,
                                    SYNTHETIC_I32_STRING.length
                                };
                                right_is_u8 := string_ref_equals_raw{
                                    rstr.start,
                                    rstr.length,
                                    SYNTHETIC_U8_STRING.start,
                                    SYNTHETIC_U8_STRING.length
                                };
                                if (left_is_i32 == 1 && right_is_u8 == 1)
                                    || (left_is_u8 == 1 && right_is_i32 == 1) then (
                                    1
                                ) else (
                                    0
                                )
                            )
                        ) else 0
                    ),
                    Value::Record(lrec) => (
                        if Value::Record(rrec) := right then (
                            if lrec.count != rrec.count then (
                                0
                            ) else if lrec.has_named == 1 && rrec.has_named == 1 then (
                                mut idx := 0;
                                mut ok := 1;
                                while idx < lrec.count && ok == 1 do (
                                    left_name_idx := lrec.head + idx * 2;
                                    left_value_idx := left_name_idx + 1;
                                    if Value::String(left_name) := values(left_name_idx).value then (
                                        right_value_idx := record_find_field_index_no_error{
                                            rrec.head,
                                            rrec.count,
                                            rrec.has_named,
                                            left_name.start,
                                            left_name.length
                                        };
                                        if right_value_idx == -1 then (
                                            ok = 0;
                                        ) else if type_values_equal{left_value_idx, right_value_idx} == 0 then (
                                            ok = 0;
                                        ) else (
                                            idx = idx + 1;
                                        )
                                    ) else (
                                        ok = 0;
                                    );
                                    {}
                                );
                                ok
                            ) else (
                                mut idx := 0;
                                mut ok := 1;
                                while idx < lrec.count && ok == 1 do (
                                    left_name_idx := record_name_index_by_position_no_error{
                                        lrec.head,
                                        lrec.count,
                                        lrec.has_named,
                                        idx
                                    };
                                    right_name_idx := record_name_index_by_position_no_error{
                                        rrec.head,
                                        rrec.count,
                                        rrec.has_named,
                                        idx
                                    };
                                    left_value_idx := record_value_index_by_position_no_error{
                                        lrec.head,
                                        lrec.count,
                                        lrec.has_named,
                                        idx
                                    };
                                    right_value_idx := record_value_index_by_position_no_error{
                                        rrec.head,
                                        rrec.count,
                                        rrec.has_named,
                                        idx
                                    };
                                    if left_name_idx == -1 || right_name_idx == -1 || left_value_idx == -1 || right_value_idx == -1 then (
                                        ok = 0;
                                    ) else if Value::String(_) := values(left_name_idx).value then (
                                        if Value::String(_) := values(right_name_idx).value then (
                                            if type_values_equal{left_value_idx, right_value_idx} == 0 then (
                                                ok = 0;
                                            ) else (
                                                idx = idx + 1;
                                            )
                                        ) else (
                                            ok = 0;
                                        )
                                    ) else (
                                        ok = 0;
                                    );
                                    {}
                                );
                                ok
                            )
                        ) else 0
                    ),
                    Value::EnumType(lenum) => (
                        if Value::EnumType(renum) := right then (
                            if lenum.count != renum.count then (
                                0
                            ) else (
                                mut idx := 0;
                                mut ok := 1;
                                while idx < lenum.count do (
                                    left_name_idx := lenum.head + idx * 2;
                                    right_name_idx := renum.head + idx * 2;
                                    if Value::String(left_name) := values(left_name_idx).value then (
                                        if Value::String(right_name) := values(right_name_idx).value then (
                                            if string_ref_equals{left_name, right_name} == 0 then (
                                                ok = 0;
                                                idx = lenum.count;
                                            ) else (
                                                left_payload_idx := left_name_idx + 1;
                                                right_payload_idx := right_name_idx + 1;
                                                if Value::Unit := values(left_payload_idx).value then (
                                                    if Value::Unit := values(right_payload_idx).value then (
                                                        idx = idx + 1;
                                                    ) else (
                                                        ok = 0;
                                                        idx = lenum.count;
                                                    )
                                                ) else if Value::Unit := values(right_payload_idx).value then (
                                                    ok = 0;
                                                    idx = lenum.count;
                                                ) else if type_values_equal{left_payload_idx, right_payload_idx} == 0 then (
                                                    ok = 0;
                                                    idx = lenum.count;
                                                ) else (
                                                    idx = idx + 1;
                                                )
                                            )
                                        ) else (
                                            ok = 0;
                                            idx = lenum.count;
                                        )
                                    ) else (
                                        ok = 0;
                                        idx = lenum.count;
                                    );
                                    {}
                                );
                                ok
                            )
                        ) else 0
                    ),
                    else => 0
                }
            )
        )
    )
);

impl_find := (type_idx: i32) => (
    if type_idx < 0 then (
        -1
    ) else (
        mut idx := impl_state.count - 1;
        mut found := -1;
        while idx >= 0 do (
            if implementations(idx).type_value == type_idx then (
                found = implementations(idx).value;
                idx = -1;
            ) else if type_values_equal{implementations(idx).type_value, type_idx} == 1 then (
                found = implementations(idx).value;
                idx = -1;
            ) else (
                idx = idx - 1;
            );
            {}
        );
        found
    )
);

impl_find_field_index := {
    type_idx: i32,
    property_start: i32,
    property_length: i32
} => (
    if type_idx < 0 then (
        -1
    ) else (
        mut idx := impl_state.count - 1;
        mut found := -1;
        while idx >= 0 && found == -1 do (
            impl_type_idx := implementations(idx).type_value;
            if impl_type_idx == type_idx || type_values_equal{impl_type_idx, type_idx} == 1 then (
                impl_idx := implementations(idx).value;
                if Value::Record(impl_info) := values(impl_idx).value then (
                    field_idx := record_find_field_index_no_error{
                        impl_info.head,
                        impl_info.count,
                        impl_info.has_named,
                        property_start,
                        property_length
                    };
                    if field_idx != -1 then (
                        found = field_idx;
                        idx = -1;
                    ) else (
                        idx = idx - 1;
                    )
                ) else (
                    idx = idx - 1;
                )
            ) else (
                idx = idx - 1;
            );
            {}
        );
        found
    )
);

ensure_trait_requirements := {type_value_idx: i32, trait_expr_idx: i32, span_start: i32} => (
    if value_is_type_like(type_value_idx) == 0 then (
        set_error(span_start);
        0
    ) else (
        trait_idx := eval_expression(trait_expr_idx);
        if trait_idx == -1 then (
            0
        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
            0
        ) else (
            required_idx := apply_function_value{trait_idx, type_value_idx, span_start};
            if required_idx == -1 then (
                0
            ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                0
            ) else (
                if Value::Record(required_info) := values(required_idx).value then (
                    mut field_idx := 0;
                    mut ok := 1;
                    while field_idx < required_info.count && ok == 1 do (
                        required_name_idx := record_name_index_by_position_no_error{
                            required_info.head,
                            required_info.count,
                            required_info.has_named,
                            field_idx
                        };
                        required_value_idx := record_value_index_by_position_no_error{
                            required_info.head,
                            required_info.count,
                            required_info.has_named,
                            field_idx
                        };
                        if required_name_idx == -1 || required_value_idx == -1 then (
                            set_error(span_start);
                            ok = 0;
                        ) else if Value::String(required_name) := values(required_name_idx).value then (
                            mut found_idx := -1;
                            if Value::Record(type_info) := values(type_value_idx).value then (
                                found_idx = record_find_field_index_no_error{
                                    type_info.head,
                                    type_info.count,
                                    type_info.has_named,
                                    required_name.start,
                                    required_name.length
                                };
                                0
                            ) else 0;
                            if found_idx == -1 then (
                                found_idx = impl_find_field_index{
                                    type_value_idx,
                                    required_name.start,
                                    required_name.length
                                };
                                0
                            ) else 0;
                            if found_idx == -1 then (
                                set_error_with_code{required_name.start, interp_err_trait_missing_field{}};
                                ok = 0;
                            ) else (
                                found_type_idx := values(found_idx).type_value;
                                if found_type_idx != -1 then (
                                    if type_values_equal{found_type_idx, required_value_idx} == 0 then (
                                        set_error(span_start);
                                        ok = 0
                                    ) else 0
                                ) else 0;
                            )
                        ) else (
                            set_error(span_start);
                            ok = 0;
                        );
                        if ok == 1 then (
                            field_idx = field_idx + 1;
                            0
                        ) else 0;
                        {}
                    );
                    ok
                ) else (
                    set_error(span_start);
                    0
                )
            )
        )
    )
);

op_is1 := {op_start: i32, op_len: i32, ch: u8} => (
    if op_len == 1 then (
        if input(op_start) == ch then 1 else 0
    ) else 0
);

op_is2 := {op_start: i32, op_len: i32, ch1: u8, ch2: u8} => (
    if op_len == 2 then (
        if input(op_start) == ch1 then (
            if input(op_start + 1) == ch2 then 1 else 0
        ) else 0
    ) else 0
);

binary_intrinsic_operator_from_tag := (operator_tag: i32) => (
    if operator_tag == 0 then BinaryIntrinsicOperator::I32Add
    else if operator_tag == 1 then BinaryIntrinsicOperator::I32Subtract
    else if operator_tag == 2 then BinaryIntrinsicOperator::I32Multiply
    else if operator_tag == 3 then BinaryIntrinsicOperator::I32Divide
    else if operator_tag == 4 then BinaryIntrinsicOperator::I32Equal
    else if operator_tag == 5 then BinaryIntrinsicOperator::I32NotEqual
    else if operator_tag == 6 then BinaryIntrinsicOperator::I32LessThan
    else if operator_tag == 7 then BinaryIntrinsicOperator::I32GreaterThan
    else if operator_tag == 8 then BinaryIntrinsicOperator::I32LessThanOrEqual
    else if operator_tag == 9 then BinaryIntrinsicOperator::I32GreaterThanOrEqual
    else if operator_tag == 10 then BinaryIntrinsicOperator::BooleanAnd
    else if operator_tag == 11 then BinaryIntrinsicOperator::BooleanOr
    else if operator_tag == 12 then BinaryIntrinsicOperator::BooleanXor
    else BinaryIntrinsicOperator::I32Add
);

binary_intrinsic_operator_tag := (operator: BinaryIntrinsicOperator) => (
    operator |> match {
        BinaryIntrinsicOperator::I32Add => 0,
        BinaryIntrinsicOperator::I32Subtract => 1,
        BinaryIntrinsicOperator::I32Multiply => 2,
        BinaryIntrinsicOperator::I32Divide => 3,
        BinaryIntrinsicOperator::I32Equal => 4,
        BinaryIntrinsicOperator::I32NotEqual => 5,
        BinaryIntrinsicOperator::I32LessThan => 6,
        BinaryIntrinsicOperator::I32GreaterThan => 7,
        BinaryIntrinsicOperator::I32LessThanOrEqual => 8,
        BinaryIntrinsicOperator::I32GreaterThanOrEqual => 9,
        BinaryIntrinsicOperator::BooleanAnd => 10,
        BinaryIntrinsicOperator::BooleanOr => 11,
        BinaryIntrinsicOperator::BooleanXor => 12,
        else => 0
    }
);

eval_binary_intrinsic_values := {
    left_idx: i32,
    right_idx: i32,
    operator: i32,
    span_start: i32
} => (
    left := values(left_idx).value;
    right := values(right_idx).value;
    normalized_operator := binary_intrinsic_operator_from_tag(operator);
    normalized_operator |> match {
        BinaryIntrinsicOperator::I32Add => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Number(lv + rv))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32Subtract => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Number(lv - rv))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32Multiply => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Number(lv * rv))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32Divide => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    if rv == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        store_value(Value::Number(lv / rv))
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32Equal => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Boolean(lv) := left then (
                if Value::Boolean(rv) := right then (
                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv == rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::String(lv) := left then (
                if Value::String(rv) := right then (
                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Target(lv) := left then (
                if Value::Target(rv) := right then (
                    store_value(Value::Boolean(target_tags_equal{lv, rv}))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::BindingAnnotation(lv) := left then (
                if Value::BindingAnnotation(rv) := right then (
                    store_value(Value::Boolean(binding_annotation_equals{lv, rv}))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32NotEqual => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Boolean(lv) := left then (
                if Value::Boolean(rv) := right then (
                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::String(lv) := left then (
                if Value::String(rv) := right then (
                    store_value(Value::Boolean(if string_ref_equals{lv, rv} == 1 then 0 else 1))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Target(lv) := left then (
                if Value::Target(rv) := right then (
                    store_value(Value::Boolean(if target_tags_equal{lv, rv} == 1 then 0 else 1))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::BindingAnnotation(lv) := left then (
                if Value::BindingAnnotation(rv) := right then (
                    store_value(Value::Boolean(if binding_annotation_equals{lv, rv} == 1 then 0 else 1))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32LessThan => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv < rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32GreaterThan => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv > rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32LessThanOrEqual => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv <= rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::I32GreaterThanOrEqual => (
            if Value::Number(lv) := left then (
                if Value::Number(rv) := right then (
                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if Value::Char(lv) := left then (
                if Value::Char(rv) := right then (
                    store_value(Value::Boolean(if lv >= rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::BooleanAnd => (
            if Value::Boolean(lv) := left then (
                if Value::Boolean(rv) := right then (
                    store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::BooleanOr => (
            if Value::Boolean(lv) := left then (
                if Value::Boolean(rv) := right then (
                    store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        BinaryIntrinsicOperator::BooleanXor => (
            if Value::Boolean(lv) := left then (
                if Value::Boolean(rv) := right then (
                    store_value(Value::Boolean(if lv != rv then 1 else 0))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        else => (
            set_error(span_start);
            -1
        )
    }
);

eval_range_from_values := {left_idx: i32, right_idx: i32, span_start: i32} => (
    if Value::Number(lv) := values(left_idx).value then (
        if Value::Number(rv) := values(right_idx).value then (
            range_start := value_state.count;
            name_idx := store_value(Value::String(SYNTHETIC_CURRENT_STRING));
            current_idx := if name_idx == -1 then -1 else store_value(Value::Number(lv));
            name_idx2 := if current_idx == -1 then -1 else store_value(Value::String(SYNTHETIC_END_STRING));
            end_idx := if name_idx2 == -1 then -1 else store_value(Value::Number(rv));
            name_idx3 := if end_idx == -1 then -1 else store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
            iter_ty_idx := if name_idx3 == -1 then -1 else store_value(Value::String(SYNTHETIC_I32_STRING));
            marked_iter_ty_idx := if iter_ty_idx == -1 then -1 else mark_value_as_type(iter_ty_idx);
            name_idx4 := if marked_iter_ty_idx == -1 then -1 else store_value(Value::String(SYNTHETIC_NEXT_STRING));
            next_idx := if name_idx4 == -1 then -1 else store_value(Value::Builtin(builtin_range_next{}));
            if name_idx == -1 then (
                -1
            ) else if current_idx == -1 then (
                -1
            ) else if name_idx2 == -1 then (
                -1
            ) else if end_idx == -1 then (
                -1
            ) else if name_idx3 == -1 then (
                -1
            ) else if iter_ty_idx == -1 then (
                -1
            ) else if marked_iter_ty_idx == -1 then (
                -1
            ) else if name_idx4 == -1 then (
                -1
            ) else if next_idx == -1 then (
                -1
            ) else (
                range_idx := store_value(Value::Record({ head = range_start, count = 4, has_named = 1 }));
                if range_idx == -1 then (
                    -1
                ) else (
                    if runtime_state.range_type_idx != -1 then (
                        values(range_idx).type_value = runtime_state.range_type_idx;
                        0
                    ) else (
                        0
                    );
                    range_idx
                )
            )
        ) else (
            set_error(span_start);
            -1
        )
    ) else (
        set_error(span_start);
        -1
    )
);

infer_type_value_idx_from_value := (value_idx: i32) => (
    if value_idx < 0 || value_idx >= value_state.count then (
        -1
    ) else if values(value_idx).type_value != -1 then (
        values(value_idx).type_value
    ) else (
        values(value_idx).value |> match {
            Value::Number(_) => (
                bind_idx := find_binding_index(SYNTHETIC_I32_STRING);
                if bind_idx == -1 then -1 else bindings(bind_idx).value
            ),
            Value::Char(_) => (
                bind_idx := find_binding_index(SYNTHETIC_U8_STRING);
                if bind_idx == -1 then -1 else bindings(bind_idx).value
            ),
            Value::Boolean(_) => (
                bind_idx := find_binding_index(SYNTHETIC_BOOL_STRING);
                if bind_idx == -1 then -1 else bindings(bind_idx).value
            ),
            Value::Target(_) => (
                bind_idx := find_binding_index(SYNTHETIC_TARGET_TYPE_BINDING_STRING);
                if bind_idx == -1 then -1 else bindings(bind_idx).value
            ),
            Value::BindingAnnotation(_) => (
                bind_idx := find_binding_index(SYNTHETIC_BINDING_ANNOTATION_STRING);
                if bind_idx == -1 then -1 else bindings(bind_idx).value
            ),
            else => -1
        }
    )
);

lookup_intrinsic_operation_method := {
    value_idx: i32,
    property_start: i32,
    property_length: i32
} => (
    type_idx := infer_type_value_idx_from_value(value_idx);
    if type_idx == -1 then (
        -1
    ) else (
        field_idx := impl_find_field_index{type_idx, property_start, property_length};
        if field_idx == -1 then (
            -1
        ) else (
            copy_value(field_idx)
        )
    )
);

eval_operation_self_call := {
    object_expr: i32,
    object_idx: i32,
    property_start: i32,
    property_length: i32,
    span_start: i32
} => (
    obj_val := values(object_idx).value;
    if Value::Record(struct_info) := obj_val then (
        field_idx := record_find_field_index_no_error{
            struct_info.head,
            struct_info.count,
            struct_info.has_named,
            property_start,
            property_length
        };
        if field_idx != -1 then (
            copy_value(field_idx)
        ) else (
            apply_impl_method{
                object_idx,
                object_expr,
                property_start,
                property_length,
                span_start
            }
        )
    ) else (
        apply_impl_method{
            object_idx,
            object_expr,
            property_start,
            property_length,
            span_start
        }
    )
);

store_value := (value: Value) => (
    if value_state.count >= MAX_VALUES then (
        set_error(0);
        -1
    ) else (
        idx := value_state.count;
        values(idx).value = value;
        values(idx).type_value = -1;
        values(idx).is_box_type = 0;
        value_state.count = value_state.count + 1;
        idx
    )
);

copy_value := (idx: i32) => (
    if idx == -1 then (
        -1
    ) else (
        new_idx := store_value(values(idx).value);
        if new_idx == -1 then (
            -1
        ) else (
            values(new_idx).is_box_type = values(idx).is_box_type;
            if values(idx).type_value != -1 then (
                values(new_idx).type_value = values(idx).type_value;
                0
            ) else (
                0
            );
            new_idx
        )
    )
);

ensure_type_value_idx := {} => (
    if runtime_state.type_value_idx == -1 then (
        runtime_state.type_value_idx = store_value(Value::String(SYNTHETIC_TYPE_STRING));
        0
    ) else (
        0
    )
);

mark_value_as_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        ensure_type_value_idx{};
        if runtime_state.type_value_idx == -1 then (
            -1
        ) else (
            values(value_idx).type_value = runtime_state.type_value_idx;
            value_idx
        )
    )
);

value_is_type_value := (type_idx: i32) => (
    if type_idx == -1 then (
        0
    ) else if runtime_state.type_value_idx == -1 then (
        if Value::String(type_name) := values(type_idx).value then (
            if string_ref_is_type(type_name) == 1 then 1 else 0
        ) else (
            0
        )
    ) else (
        type_values_equal{type_idx, runtime_state.type_value_idx}
    )
);

value_is_type := (value_idx: i32) => (
    if value_idx == -1 then (
        0
    ) else (
        value_is_type_value(values(value_idx).type_value)
    )
);

value_is_type_like := (value_idx: i32) => (
    if value_idx == -1 then (
        0
    ) else if value_is_type(value_idx) == 1 then (
        1
    ) else (
        value := values(value_idx).value;
        value |> match {
            Value::Unit => 1,
            Value::String(name_ref) => (
                if name_ref.start < 0 then (
                    if (name_ref.start == SYNTHETIC_I32_STRING.start && name_ref.length == SYNTHETIC_I32_STRING.length)
                        || (name_ref.start == SYNTHETIC_U8_STRING.start && name_ref.length == SYNTHETIC_U8_STRING.length)
                        || (name_ref.start == SYNTHETIC_BOOL_STRING.start && name_ref.length == SYNTHETIC_BOOL_STRING.length)
                        || (name_ref.start == SYNTHETIC_TYPE_STRING.start && name_ref.length == SYNTHETIC_TYPE_STRING.length)
                        || (name_ref.start == SYNTHETIC_TARGET_STRING.start && name_ref.length == SYNTHETIC_TARGET_STRING.length)
                        || (name_ref.start == SYNTHETIC_BINDING_ANNOTATION_STRING.start && name_ref.length == SYNTHETIC_BINDING_ANNOTATION_STRING.length)
                    then 1 else 0
                ) else (
                    0
                )
            ),
            Value::Record(rec_info) => (
                mut idx := 0;
                mut ok := 1;
                while idx < rec_info.count && ok == 1 do (
                    field_idx := record_value_index_by_position_no_error{
                        rec_info.head,
                        rec_info.count,
                        rec_info.has_named,
                        idx
                    };
                    if field_idx == -1 then (
                        ok = 0;
                    ) else if value_is_type_like(field_idx) == 1 then (
                        idx = idx + 1;
                    ) else (
                        ok = 0;
                    );
                    {}
                );
                ok
            ),
            Value::EnumType(enum_info) => (
                mut idx := 0;
                mut ok := 1;
                while idx < enum_info.count && ok == 1 do (
                    payload_idx := enum_info.head + idx * 2 + 1;
                    if Value::Unit := values(payload_idx).value then (
                        idx = idx + 1;
                    ) else if value_is_type_like(payload_idx) == 1 then (
                        idx = idx + 1;
                    ) else (
                        ok = 0;
                    );
                    {}
                );
                ok
            ),
            else => 0
        }
    )
);

block_contains_top_level_diverge := (list: ExpressionList) => (
    mut current := list.head;
    mut remaining := list.count;
    mut has_diverge := 0;
    while remaining > 0 && current != -1 && has_diverge == 0 do (
        expr_idx := list_nodes(current).value;
        if NodeKind::Diverge(_) := nodes(expr_idx).kind then (
            has_diverge = 1;
        ) else (
            current = list_nodes(current).next;
            remaining = remaining - 1;
        );
        {}
    );
    has_diverge
);

expression_branch_tag: (i32 -> i32) := (expr_idx: i32) => (
    if expr_idx == -1 then (
        -1
    ) else (
        nodes(expr_idx).kind |> match {
            NodeKind::Literal(lit) => (
                lit |> match {
                    ExpressionLiteral::Number(_) => 0,
                    ExpressionLiteral::Boolean(_) => 1,
                    ExpressionLiteral::Char(_) => 2,
                    ExpressionLiteral::String(_) => 3,
                    ExpressionLiteral::Target(_) => 12,
                    ExpressionLiteral::BindingAnnotation(_) => 13
                }
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then 4 else 6
            ),
            NodeKind::Diverge(_) => -2,
            NodeKind::Block(list) => (
                if list.count <= 0 || list.head == -1 then (
                    4
                ) else if block_contains_top_level_diverge(list) == 1 then (
                    -2
                ) else (
                    mut current := list.head;
                    while list_nodes(current).next != -1 do (
                        current = list_nodes(current).next;
                        {}
                    );
                    last_idx := list_nodes(current).value;
                    nodes(last_idx).kind |> match {
                        NodeKind::Literal(last_lit) => (
                            last_lit |> match {
                                ExpressionLiteral::Number(_) => 0,
                                ExpressionLiteral::Boolean(_) => 1,
                                ExpressionLiteral::Char(_) => 2,
                                ExpressionLiteral::String(_) => 3,
                                ExpressionLiteral::Target(_) => 12,
                                ExpressionLiteral::BindingAnnotation(_) => 13
                            }
                        ),
                        NodeKind::Struct(last_struct) => (
                            if is_empty_struct(last_struct.fields) == 1 then 4 else 6
                        ),
                        NodeKind::Diverge(_) => -2,
                        else => -1
                    }
                )
            ),
            else => -1
        }
    )
);

check_if_branch_type_compat := {then_expr_idx: i32, else_expr_idx: i32, span_start: i32} => (
    then_tag := expression_branch_tag(then_expr_idx);
    else_tag := expression_branch_tag(else_expr_idx);
    if then_tag == -2 || else_tag == -2 then (
        1
    ) else if then_tag == -1 || else_tag == -1 then (
        1
    ) else if then_tag == else_tag then (
        1
    ) else (
        set_error_with_code{span_start, interp_err_if_branch_type_mismatch{}};
        0
    )
);

mark_intrinsic_string_value_as_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        value := values(value_idx).value;
        if Value::String(name_ref) := value then (
            if name_ref.start < 0 then (
                if (name_ref.start == SYNTHETIC_I32_STRING.start && name_ref.length == SYNTHETIC_I32_STRING.length)
                    || (name_ref.start == SYNTHETIC_U8_STRING.start && name_ref.length == SYNTHETIC_U8_STRING.length)
                    || (name_ref.start == SYNTHETIC_BOOL_STRING.start && name_ref.length == SYNTHETIC_BOOL_STRING.length)
                    || (name_ref.start == SYNTHETIC_TYPE_STRING.start && name_ref.length == SYNTHETIC_TYPE_STRING.length)
                    || (name_ref.start == SYNTHETIC_TARGET_STRING.start && name_ref.length == SYNTHETIC_TARGET_STRING.length)
                    || (name_ref.start == SYNTHETIC_BINDING_ANNOTATION_STRING.start && name_ref.length == SYNTHETIC_BINDING_ANNOTATION_STRING.length)
                then (
                    if values(value_idx).type_value == -1 then (
                        mark_value_as_type(value_idx)
                    ) else (
                        value_idx
                    )
                ) else (
                    value_idx
                )
            ) else (
                value_idx
            )
        ) else (
            value_idx
        )
    )
);

mark_value_as_box_type := (value_idx: i32) => (
    if value_idx == -1 then (
        -1
    ) else (
        values(value_idx).is_box_type = 1;
        value_idx
    )
);

value_is_box_type_flag := (value_idx: i32) => (
    if value_idx == -1 then (
        0
    ) else (
        if values(value_idx).is_box_type == 1 then 1 else (
            if Value::Record(rec_info) := values(value_idx).value then (
                if rec_info.count == 1 && rec_info.has_named == 0 then (
                    if Value::String(name_ref) := values(rec_info.head).value then (
                        if name_ref.start == SYNTHETIC_BOX_STRING.start && name_ref.length == SYNTHETIC_BOX_STRING.length then 1 else 0
                    ) else 0
                ) else 0
            ) else 0
        )
    )
);

is_empty_struct := (fields: i32) => (
    if fields == -1 then 1 else 0
);

target_literal_value := (target: TargetLiteral) => (
    target |> match {
        TargetLiteral::JSTarget => TargetTag::Js,
        TargetLiteral::WasmTarget => TargetTag::Wasm,
        TargetLiteral::WgslTarget => TargetTag::Wgsl,
        else => TargetTag::Js
    }
);

target_literal_tag := (target: TargetLiteral) => (
    target_tag_value(target_literal_value(target))
);

target_tag_is_wgsl := (target_tag: TargetTag) => (
    target_tag |> match {
        TargetTag::Wgsl => 1,
        else => 0
    }
);

target_tags_equal := {left: TargetTag, right: TargetTag} => (
    if target_tag_value(left) == target_tag_value(right) then 1 else 0
);

binding_annotation_kind_tag := (ann: BindingAnnotationValue) => (
    ann |> match {
        BindingAnnotationValue::Mut => 0,
        BindingAnnotationValue::Export(_) => 1,
        BindingAnnotationValue::Target(_) => 2,
        BindingAnnotationValue::Wrap(_) => 3,
        else => -1
    }
);

binding_annotation_target_tag := (ann: BindingAnnotationValue) => (
    ann |> match {
        BindingAnnotationValue::Mut => -1,
        BindingAnnotationValue::Export(target) => target_tag_value(target),
        BindingAnnotationValue::Target(target) => target_tag_value(target),
        BindingAnnotationValue::Wrap(target) => target_tag_value(target),
        else => -1
    }
);

binding_annotation_equals := {left: BindingAnnotationValue, right: BindingAnnotationValue} => (
    if binding_annotation_kind_tag(left) == binding_annotation_kind_tag(right)
        && binding_annotation_target_tag(left) == binding_annotation_target_tag(right)
    then 1 else 0
);

validate_wrap_export_annotations := {value_idx: i32, export_mask: i32, wrap_mask: i32, span_start: i32} => (
    if wrap_mask == 0 then (
        1
    ) else if target_mask_is_single_target(export_mask) == 0 then (
        set_error_with_code{span_start, interp_err_wrap_requires_single_export_target{}};
        0
    ) else (
        if Value::Function(_) := values(value_idx).value then (
            1
        ) else (
            if export_mask == target_mask_wasm{} && wrap_mask == target_mask_js{} then (
                1
            ) else (
                set_error_with_code{span_start, interp_err_wrap_global_only_wasm_to_js{}};
                0
            )
        )
    )
);

binding_annotation_from_literal := (ann: BindingAnnotationLiteral) => (
    ann |> match {
        BindingAnnotationLiteral::Mut => Value::BindingAnnotation(BindingAnnotationValue::Mut),
        BindingAnnotationLiteral::Export(target) => Value::BindingAnnotation(BindingAnnotationValue::Export(target_literal_value(target))),
        BindingAnnotationLiteral::Target(target) => Value::BindingAnnotation(BindingAnnotationValue::Target(target_literal_value(target))),
        BindingAnnotationLiteral::Wrap(target) => Value::BindingAnnotation(BindingAnnotationValue::Wrap(target_literal_value(target))),
        else => Value::Unit
    }
);


eval_literal := (lit: ExpressionLiteral) => (
    lit |> match {
        ExpressionLiteral::Number(value) => Value::Number(value),
        ExpressionLiteral::Boolean(value) => Value::Boolean(value),
        ExpressionLiteral::Char(value) => Value::Char(value),
        ExpressionLiteral::String(value) => Value::String(value),
        ExpressionLiteral::Target(value) => Value::Target(target_literal_value(value)),
        ExpressionLiteral::BindingAnnotation(value) => binding_annotation_from_literal(value),
        else => Value::Unit
    }
);

enum_variant_name_matches := {enum_head: i32, enum_count: i32, variant_idx: i32, name_start: i32, name_length: i32} => (
    if enum_head < 0 || enum_count <= 0 then (
        0
    ) else if variant_idx < enum_head || variant_idx >= enum_head + enum_count * 2 then (
        0
    ) else (
        if Value::String(stored_name) := values(variant_idx).value then (
            string_ref_equals_raw{
                stored_name.start,
                stored_name.length,
                name_start,
                name_length
            }
        ) else (
            0
        )
    )
);

enum_type_matches := {left_head: i32, left_count: i32, right_head: i32, right_count: i32} => (
    if left_head < 0 || right_head < 0 then (
        0
    ) else if left_count != right_count then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < left_count do (
            left_name_idx := left_head + idx * 2;
            right_name_idx := right_head + idx * 2;
            if Value::String(left_name) := values(left_name_idx).value then (
                if Value::String(right_name) := values(right_name_idx).value then (
                    if string_ref_equals{left_name, right_name} == 0 then (
                        ok = 0;
                        idx = left_count;
                    ) else (
                        left_payload_idx := left_head + idx * 2 + 1;
                        right_payload_idx := right_head + idx * 2 + 1;
                        mut left_has := 0;
                        mut right_has := 0;
                        if Value::Unit := values(left_payload_idx).value then (
                            left_has = 0;
                        ) else (
                            left_has = 1;
                        );
                        if Value::Unit := values(right_payload_idx).value then (
                            right_has = 0;
                        ) else (
                            right_has = 1;
                        );
                        if left_has != right_has then (
                            ok = 0;
                            idx = left_count;
                        ) else if left_has == 1 then (
                            if type_values_equal{left_payload_idx, right_payload_idx} == 0 then (
                                ok = 0;
                                idx = left_count;
                            ) else (
                                idx = idx + 1;
                            )
                        ) else (
                            idx = idx + 1;
                        );
                    )
                ) else (
                    ok = 0;
                    idx = left_count;
                )
            ) else (
                ok = 0;
                idx = left_count;
            );
            {}
        );
        ok
    )
);

enum_record_payloads_are_types := {enum_head: i32, enum_count: i32} => (
    if enum_head < 0 || enum_count < 0 then (
        0
    ) else (
        mut idx := 0;
        mut ok := 1;
        while idx < enum_count do (
            payload_idx := enum_head + idx * 2 + 1;
            payload_ok := values(payload_idx).value |> match {
                Value::Number(_) => 0,
                Value::Boolean(_) => 0,
                Value::Char(_) => 0,
                else => 1
            };
            if payload_ok == 0 then (
                ok = 0;
                idx = enum_count;
            ) else (
                idx = idx + 1;
            );
            {}
        );
        ok
    )
);

enum_value_matches_pattern_type := {enum_type_expr: i32, enum_head: i32, enum_count: i32, span_start: i32} => (
    expected_idx := eval_expression(enum_type_expr);
    if expected_idx == -1 then (
        -1
    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
        -1
    ) else (
        if Value::EnumType(expected_enum) := values(expected_idx).value then (
            enum_type_matches{
                enum_head,
                enum_count,
                expected_enum.head,
                expected_enum.count
            }
        ) else (
            set_error(span_start);
            -1
        )
    )
);

string_ref_equals_synthetic := {synthetic_start: i32, synthetic_len: i32, input_start: i32, input_len: i32} => (
    if input_start < 0 then 0 else if synthetic_len != input_len then 0 else (
        input_ref := make_string_ref{input_start, input_len};
        if synthetic_start == SYNTHETIC_MUT_STRING.start then (
            string_ref_is_mut(input_ref)
        ) else if synthetic_start == SYNTHETIC_OPTION_STRING.start then (
            string_ref_is_option(input_ref)
        ) else if synthetic_start == SYNTHETIC_SOME_STRING.start then (
            string_ref_is_some(input_ref)
        ) else if synthetic_start == SYNTHETIC_NONE_STRING.start then (
            string_ref_is_none(input_ref)
        ) else if synthetic_start == SYNTHETIC_ITER_TY_STRING.start then (
            string_ref_is_iter_ty(input_ref)
        ) else if synthetic_start == SYNTHETIC_NEXT_STRING.start then (
            string_ref_is_next(input_ref)
        ) else if synthetic_start == SYNTHETIC_FOR_ITER_STRING.start then (
            string_ref_is_for_iter(input_ref)
        ) else if synthetic_start == SYNTHETIC_CURRENT_STRING.start then (
            string_ref_is_current(input_ref)
        ) else if synthetic_start == SYNTHETIC_END_STRING.start then (
            string_ref_is_end(input_ref)
        ) else if synthetic_start == SYNTHETIC_RANGE_STRING.start then (
            string_ref_is_range(input_ref)
        ) else if synthetic_start == SYNTHETIC_BOX_STRING.start then (
            string_ref_matches_3{input_ref, 'b', 'o', 'x'}
        ) else if synthetic_start == SYNTHETIC_I32_STRING.start then (
            string_ref_is_i32(input_ref)
        ) else if synthetic_start == SYNTHETIC_U8_STRING.start then (
            string_ref_is_u8(input_ref)
        ) else if synthetic_start == SYNTHETIC_BOOL_STRING.start then (
            string_ref_is_bool(input_ref)
        ) else if synthetic_start == SYNTHETIC_TYPE_STRING.start then (
            string_ref_is_type(input_ref)
        ) else if synthetic_start == SYNTHETIC_TARGET_STRING.start then (
            string_ref_is_target(input_ref)
        ) else if synthetic_start == SYNTHETIC_BINDING_ANNOTATION_STRING.start then (
            string_ref_is_binding_annotation(input_ref)
        ) else if synthetic_start == SYNTHETIC_JS_STRING.start then (
            string_ref_is_js(input_ref)
        ) else if synthetic_start == SYNTHETIC_WASM_STRING.start then (
            string_ref_is_wasm(input_ref)
        ) else if synthetic_start == SYNTHETIC_WGSL_STRING.start then (
            string_ref_is_wgsl(input_ref)
        ) else if synthetic_start == SYNTHETIC_OP_ADD_STRING.start then (
            string_ref_matches_1{input_ref, '+'}
        ) else if synthetic_start == SYNTHETIC_OP_SUBTRACT_STRING.start then (
            string_ref_matches_1{input_ref, '-'}
        ) else if synthetic_start == SYNTHETIC_OP_MULTIPLY_STRING.start then (
            string_ref_matches_1{input_ref, '*'}
        ) else if synthetic_start == SYNTHETIC_OP_DIVIDE_STRING.start then (
            string_ref_matches_1{input_ref, '/'}
        ) else if synthetic_start == SYNTHETIC_OP_EQUAL_STRING.start then (
            string_ref_matches_2{input_ref, '=', '='}
        ) else if synthetic_start == SYNTHETIC_OP_NOT_EQUAL_STRING.start then (
            string_ref_matches_2{input_ref, '!', '='}
        ) else if synthetic_start == SYNTHETIC_OP_LESS_THAN_STRING.start then (
            string_ref_matches_1{input_ref, '<'}
        ) else if synthetic_start == SYNTHETIC_OP_GREATER_THAN_STRING.start then (
            string_ref_matches_1{input_ref, '>'}
        ) else if synthetic_start == SYNTHETIC_OP_LESS_THAN_OR_EQUAL_STRING.start then (
            string_ref_matches_2{input_ref, '<', '='}
        ) else if synthetic_start == SYNTHETIC_OP_GREATER_THAN_OR_EQUAL_STRING.start then (
            string_ref_matches_2{input_ref, '>', '='}
        ) else if synthetic_start == SYNTHETIC_OP_RANGE_STRING.start then (
            string_ref_matches_2{input_ref, '.', '.'}
        ) else if synthetic_start == SYNTHETIC_OP_AND_STRING.start then (
            string_ref_matches_2{input_ref, '&', '&'}
        ) else if synthetic_start == SYNTHETIC_OP_OR_STRING.start then (
            string_ref_matches_2{input_ref, '|', '|'}
        ) else if synthetic_start == SYNTHETIC_OP_XOR_STRING.start then (
            string_ref_matches_1{input_ref, '^'}
        ) else (
            0
        )
    )
);

span_is_underscore := {start: i32, length: i32} => (
    string_ref_is_underscore(make_string_ref{start, length})
);

span_is_else := {start: i32, length: i32} => (
    string_ref_is_else(make_string_ref{start, length})
);

add_binding_if_named := {start: i32, length: i32, value_idx: i32, is_mut: i32} => (
    if length <= 0 then (
        binding_state.count
    ) else if span_is_underscore{start, length} == 1 then (
        binding_state.count
    ) else if span_is_else{start, length} == 1 then (
        binding_state.count
    ) else (
        add_binding{start, length, value_idx, is_mut}
    )
);

binding_target_mask_update := (mask: i32) => (
    if binding_target_state.acc_mask == -1 then (
        binding_target_state.acc_mask = mask;
        0
    ) else (
        binding_target_state.acc_mask = target_mask_and{binding_target_state.acc_mask, mask};
        0
    );
    1
);

binding_pattern_target_mask_expr := {pattern_expr: i32, passed_mask: i32} => (
    if pattern_expr == -1 then 1 else (
        nodes(pattern_expr).kind |> match {
            NodeKind::Identifier(_) => binding_target_mask_update(passed_mask),
            NodeKind::Literal(_) => 1,
            NodeKind::Struct(info) => (
                mut current := info.fields;
                while current != -1 do (
                    field_node := list_nodes(current).value;
                    if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                        binding_pattern_target_mask_expr{field_binding.expr, passed_mask};
                        if value_state.error != -1 then (
                            current = -1;
                        ) else (
                            current = list_nodes(current).next;
                        )
                    ) else (
                        set_error(nodes(field_node).span.start);
                        current = -1;
                    );
                    {}
                );
                1
            ),
            NodeKind::Operation(op) => (
                if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                    binding_pattern_target_mask_expr{op.left, passed_mask}
                ) else (
                    1
                )
            ),
            NodeKind::TypePropertyAccess(_) => 1,
            NodeKind::FunctionCall(call) => (
                if NodeKind::TypePropertyAccess(_) := nodes(call.function).kind then (
                    binding_pattern_target_mask_expr{call.argument, passed_mask}
                ) else (
                    annotations := extract_binding_annotations(call.function);
                    if resolve_annotation_flags(annotations) == 0 then 0 else (
                        combined_mask := target_mask_or{passed_mask, annotation_temp.target_mask};
                        binding_pattern_target_mask_expr{call.argument, combined_mask}
                    )
                )
            ),
            else => 1
        }
    )
);

binding_pattern_target_mask := (pattern: BindingPattern) => (
    binding_target_state.acc_mask = -1;
    pattern |> match {
        BindingPattern::Identifier(_) => binding_target_mask_update(0),
        BindingPattern::Literal(_) => 1,
        BindingPattern::Struct(info) => (
            mut current := info.fields;
            while current != -1 do (
                field_node := list_nodes(current).value;
                if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                    binding_pattern_target_mask_expr{field_binding.expr, 0};
                    if value_state.error != -1 then (
                        current = -1;
                    ) else (
                        current = list_nodes(current).next;
                    )
                ) else (
                    set_error(nodes(field_node).span.start);
                    current = -1;
                );
                {}
            );
            1
        ),
        BindingPattern::EnumVariant(info) => (
            if info.payload == -1 then 1 else binding_pattern_target_mask_expr{info.payload, 0}
        ),
        BindingPattern::TypeHint(info) => binding_pattern_target_mask_expr{info.pattern, 0},
        BindingPattern::Annotated(info) => (
            if resolve_annotation_flags(info.annotations) == 0 then 0 else (
                binding_pattern_target_mask_expr{info.pattern, annotation_temp.target_mask}
            )
        ),
        else => 1
    };
    if value_state.error != -1 then -1 else (
        if binding_target_state.acc_mask == -1 then 0 else binding_target_state.acc_mask
    )
);

bind_payload_pattern := {payload_expr: i32, payload_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    mut payload_mut := inherit_mut;
    nodes(payload_expr).kind |> match {
        NodeKind::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.start, info.name.length, payload_idx, payload_mut};
            if bind_idx == -1 then (
                0
            ) else (
                bindings(bind_idx).target_mask = inherit_target_mask;
                bindings(bind_idx).export_mask = inherit_export_mask;
                bindings(bind_idx).wrap_mask = inherit_wrap_mask;
                1
            )
        ),
        NodeKind::Literal(literal) => (
            payload_value := values(payload_idx).value;
            literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := payload_value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := payload_value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        NodeKind::Operation(op) => (
            if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                bind_payload_pattern{op.left, payload_idx, payload_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
            ) else (
                0
            )
        ),
        else => 0
    }
);

bind_struct_pattern := {fields_head: i32, value_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    if fields_head == -1 then (
        if Value::Unit := values(value_idx).value then (
            1
        ) else if Value::Record(rec_info) := values(value_idx).value then (
            if rec_info.count == 0 then 1 else 0
        ) else (
            0
        )
    ) else if Value::Record(rec_info) := values(value_idx).value then (
        start_count := binding_state.count;
        mut current := fields_head;
        mut ok := 1;
        mut positional_idx := 0;
        while current != -1 && ok == 1 do (
            field_node := list_nodes(current).value;
            if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                mut field_name := EMPTY_STRING;
                field_binding.pattern |> match {
                    BindingPattern::Identifier(id) => (field_name = id.name.name),
                    else => (field_name = EMPTY_STRING)
                };
                mut field_value_idx := -1;
                if field_name.length <= 0 then (
                    field_value_idx = record_value_index_by_position_no_error{
                        rec_info.head,
                        rec_info.count,
                        rec_info.has_named,
                        positional_idx
                    };
                    positional_idx = positional_idx + 1;
                ) else (
                    field_value_idx = record_find_field_index_no_error{
                        rec_info.head,
                        rec_info.count,
                        rec_info.has_named,
                        field_name.start,
                        field_name.length
                    };
                );
                if field_value_idx == -1 then (
                    missing_span := if field_name.start >= 0 then field_name.start else nodes(field_node).span.start;
                    set_error_with_code{missing_span, interp_err_missing_field{}};
                    ok = 0;
                ) else (
                    if bind_pattern_expr{field_binding.expr, field_value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask} == 0 then (
                        ok = 0;
                    ) else (
                        current = list_nodes(current).next;
                    )
                )
            ) else (
                ok = 0;
            );
            {}
        );
        if ok == 0 then (
            binding_state.count = start_count;
            0
        ) else (
            1
        )
    ) else (
        0
    )
);

bind_pattern_expr := {pattern_expr: i32, value_idx: i32, inherit_mut: i32, inherit_target_mask: i32, inherit_export_mask: i32, inherit_wrap_mask: i32} => (
    nodes(pattern_expr).kind |> match {
        NodeKind::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.start, info.name.length, value_idx, inherit_mut};
            if bind_idx >= 0 then (
                bindings(bind_idx).target_mask = inherit_target_mask;
                bindings(bind_idx).export_mask = inherit_export_mask;
                bindings(bind_idx).wrap_mask = inherit_wrap_mask;
                0
            ) else 0;
            if values(value_idx).type_value != -1 then (
                if info.name.length > 0 && span_is_underscore{info.name.start, info.name.length} == 0 && span_is_else{info.name.start, info.name.length} == 0 then (
                    if bind_idx >= 0 then (
                        bindings(bind_idx).type_value = values(value_idx).type_value;
                        0
                    ) else 0
                ) else 0
            ) else 0;
            if bind_idx == -1 then 0 else 1
        ),
        NodeKind::Literal(literal) => (
            value := values(value_idx).value;
            literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        NodeKind::Struct(info) => bind_struct_pattern{info.fields, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask},
        NodeKind::Operation(op) => (
            if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                type_idx := eval_expression(op.right);
                if type_idx == -1 then (
                    0
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    0
                ) else (
                    resolve_binding_from_expr(op.left);
                    name_ok := binding_temp.ok;
                    name_start := binding_temp.start;
                    name_len := binding_temp.length;
                    matched := bind_pattern_expr{op.left, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask};
                    if matched == 1 && name_ok == 1 then (
                        bind_name := make_string_ref{name_start, name_len};
                        bind_idx := find_binding_index(bind_name);
                        if bind_idx != -1 then (
                            existing_type := values(value_idx).type_value;
                            if existing_type == -1 then (
                                bindings(bind_idx).type_value = type_idx;
                                values(value_idx).type_value = type_idx;
                                0
                            ) else (
                                bindings(bind_idx).type_value = existing_type;
                                0
                            )
                        ) else (
                            0
                        )
                    ) else (
                        0
                    );
                    matched
                )
            ) else (
                0
            )
        ),
        NodeKind::TypePropertyAccess(info: TypePropertyAccessInfo) => (
            if Value::Enum(enum_info) := values(value_idx).value then (
                type_matches := enum_value_matches_pattern_type{
                    info.object,
                    enum_info.enum_head,
                    enum_info.enum_count,
                    nodes(pattern_expr).span.start
                };
                if type_matches == -1 then (
                    0
                ) else if type_matches == 0 then (
                    0
                ) else (
                    if enum_variant_name_matches{
                        enum_info.enum_head,
                        enum_info.enum_count,
                        enum_info.variant_idx,
                        info.property.start,
                        info.property.length
                    } == 1 then (
                        if enum_info.payload == -1 then 1 else 0
                    ) else (
                        0
                    )
                )
            ) else (
                0
            )
        ),
        NodeKind::FunctionCall(call) => (
            if NodeKind::TypePropertyAccess(access) := nodes(call.function).kind then (
                if Value::Enum(enum_info) := values(value_idx).value then (
                    type_matches := enum_value_matches_pattern_type{
                        access.object,
                        enum_info.enum_head,
                        enum_info.enum_count,
                        nodes(pattern_expr).span.start
                    };
                    if type_matches == -1 then (
                        0
                    ) else if type_matches == 0 then (
                        0
                    ) else (
                        if enum_variant_name_matches{
                            enum_info.enum_head,
                            enum_info.enum_count,
                            enum_info.variant_idx,
                            access.property.start,
                            access.property.length
                        } == 1 then (
                            if enum_info.payload == -1 then 0 else (
                                bind_payload_pattern{call.argument, enum_info.payload, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
                            )
                        ) else (
                            0
                        )
                    )
                ) else (
                    0
                )
            ) else (
                annotations := extract_binding_annotations(call.function);
                if resolve_annotation_flags(annotations) == 0 then 0 else (
                    mut_flag := if annotation_temp.is_mut == 1 || inherit_mut == 1 then 1 else 0;
                    combined_mask := target_mask_or{inherit_target_mask, annotation_temp.target_mask};
                    combined_export_mask := target_mask_or{inherit_export_mask, annotation_temp.export_mask};
                    combined_wrap_mask := target_mask_or{inherit_wrap_mask, annotation_temp.wrap_mask};
                    if validate_wrap_export_annotations{
                        value_idx,
                        combined_export_mask,
                        combined_wrap_mask,
                        nodes(pattern_expr).span.start
                    } == 0 then (
                        0
                    ) else (
                        bind_pattern_expr{call.argument, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                    )
                )
            )
        ),
        else => 0
    }
);

bind_pattern_simple: (BindingPattern -> i32) := (pattern: BindingPattern) => (
    value_idx := bind_pattern_state.value_idx;
    inherit_mut := bind_pattern_state.inherit_mut;
    inherit_target_mask := bind_pattern_state.inherit_target_mask;
    inherit_export_mask := bind_pattern_state.inherit_export_mask;
    inherit_wrap_mask := bind_pattern_state.inherit_wrap_mask;
    start_count := binding_state.count;
    matched := pattern |> match {
        BindingPattern::Annotated(info) => (
            if resolve_annotation_flags(info.annotations) == 0 then (
                0
            ) else (
                mut_flag := if annotation_temp.is_mut == 1 || inherit_mut == 1 then 1 else 0;
                combined_mask := target_mask_or{inherit_target_mask, annotation_temp.target_mask};
                combined_export_mask := target_mask_or{inherit_export_mask, annotation_temp.export_mask};
                combined_wrap_mask := target_mask_or{inherit_wrap_mask, annotation_temp.wrap_mask};
                if validate_wrap_export_annotations{
                    value_idx,
                    combined_export_mask,
                    combined_wrap_mask,
                    nodes(info.pattern).span.start
                } == 0 then (
                    0
                ) else (
                    if NodeKind::Operation(op) := nodes(info.pattern).kind then (
                        if op_is1{op.operator.start, op.operator.length, ':'} == 1 then (
                            type_idx := eval_expression(op.right);
                            if type_idx == -1 then (
                                0
                            ) else (
                                if flow_kind_is_none(flow_state.kind) == 0 then (
                                    0
                                ) else (
                                    resolve_binding_from_expr(op.left);
                                    name_ok := binding_temp.ok;
                                    name_start := binding_temp.start;
                                    name_len := binding_temp.length;
                                    matched := bind_pattern_expr{op.left, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask};
                                    if matched == 1 && name_ok == 1 then (
                                        bind_name := make_string_ref{name_start, name_len};
                                        bind_idx := find_binding_index(bind_name);
                                        if bind_idx != -1 then (
                                            existing_type := values(value_idx).type_value;
                                            if existing_type == -1 then (
                                                bindings(bind_idx).type_value = type_idx;
                                                values(value_idx).type_value = type_idx;
                                                0
                                            ) else (
                                                bindings(bind_idx).type_value = existing_type;
                                                0
                                            )
                                        ) else (
                                            0
                                        )
                                    ) else (
                                        0
                                    );
                                    matched
                                )
                            )
                        ) else (
                            bind_pattern_expr{info.pattern, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                        )
                    ) else (
                        bind_pattern_expr{info.pattern, value_idx, mut_flag, combined_mask, combined_export_mask, combined_wrap_mask}
                    )
                )
            )
        ),
        BindingPattern::TypeHint(info) => (
            mut type_expr_idx := info.type_expr;
            mut trait_expr_idx := -1;
            mut type_idx := -1;
            mut used_precomputed_type := 0;
            if NodeKind::AttachImplementation(attach_info) := nodes(info.type_expr).kind then (
                if NodeKind::Struct(_) := nodes(attach_info.implementation).kind then (
                    {}
                ) else (
                    candidate_type_idx := eval_expression(attach_info.type_expr);
                    if candidate_type_idx == -1 then (
                        type_idx = -1;
                        used_precomputed_type = 1;
                        {}
                    ) else (
                        if flow_kind_is_none(flow_state.kind) == 0 then (
                            type_idx = -1;
                            used_precomputed_type = 1;
                            {}
                        ) else (
                            if value_is_type_value(candidate_type_idx) == 1 then (
                                type_expr_idx = attach_info.type_expr;
                                trait_expr_idx = attach_info.implementation;
                                type_idx = candidate_type_idx;
                                used_precomputed_type = 1;
                                {}
                            ) else (
                                {}
                            );
                            {}
                        );
                        {}
                    );
                    {}
                )
            ) else (
                {}
            );
            if used_precomputed_type == 0 then (
                type_idx = eval_expression(type_expr_idx);
                {}
            ) else (
                {}
            );
            if type_idx == -1 then (
                0
            ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                0
            ) else if trait_expr_idx != -1 && ensure_trait_requirements{value_idx, trait_expr_idx, nodes(info.type_expr).span.start} == 0 then (
                0
            ) else (
                resolve_binding_from_expr(info.pattern);
                name_ok := binding_temp.ok;
                name_start := binding_temp.start;
                name_len := binding_temp.length;
                matched := bind_pattern_expr{info.pattern, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask};
                if matched == 1 && name_ok == 1 then (
                    bind_name := make_string_ref{name_start, name_len};
                    bind_idx := find_binding_index(bind_name);
                    if bind_idx != -1 then (
                        existing_type := values(value_idx).type_value;
                        bindings(bind_idx).type_value = type_idx;
                        if existing_type == -1 then (
                            values(value_idx).type_value = type_idx;
                            0
                        ) else (
                            0
                        )
                    ) else (
                        0
                    )
                ) else (
                    0
                );
                matched
            )
        ),
        BindingPattern::Identifier(info) => (
            bind_idx := add_binding_if_named{info.name.name.start, info.name.name.length, value_idx, inherit_mut};
            if values(value_idx).type_value != -1 then (
                if info.name.name.length > 0 && span_is_underscore{info.name.name.start, info.name.name.length} == 0 && span_is_else{info.name.name.start, info.name.name.length} == 0 then (
                    if bind_idx >= 0 then (
                        bindings(bind_idx).type_value = values(value_idx).type_value;
                        0
                    ) else 0
                ) else 0
            ) else 0;
            if bind_idx == -1 then 0 else 1
        ),
        BindingPattern::Literal(info) => (
            value := values(value_idx).value;
            info.literal |> match {
                ExpressionLiteral::Number(expected) => (
                    if Value::Number(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Boolean(expected) => (
                    if Value::Boolean(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::Char(expected) => (
                    if Value::Char(actual) := value then if actual == expected then 1 else 0 else 0
                ),
                ExpressionLiteral::String(expected) => (
                    if Value::String(actual) := value then (
                        if string_ref_equals_raw{
                            actual.start,
                            actual.length,
                            expected.start,
                            expected.length
                        } == 1 then 1 else 0
                    ) else 0
                ),
                else => 0
            }
        ),
        BindingPattern::EnumVariant(info) => (
            if Value::Enum(enum_info) := values(value_idx).value then (
                type_matches := enum_value_matches_pattern_type{
                    info.enum_type,
                    enum_info.enum_head,
                    enum_info.enum_count,
                    info.span.start
                };
                if type_matches == -1 then (
                    0
                ) else if type_matches == 0 then (
                    0
                ) else (
                    if enum_variant_name_matches{
                        enum_info.enum_head,
                        enum_info.enum_count,
                        enum_info.variant_idx,
                        info.variant.name.start,
                        info.variant.name.length
                    } == 1 then (
                        if info.payload == -1 then (
                            if enum_info.payload == -1 then 1 else 0
                        ) else (
                            if enum_info.payload == -1 then 0 else (
                                bind_payload_pattern{info.payload, enum_info.payload, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask}
                            )
                        )
                    ) else (
                        0
                    )
                )
            ) else (
                0
            )
        ),
        BindingPattern::Struct(info) => bind_struct_pattern{info.fields, value_idx, inherit_mut, inherit_target_mask, inherit_export_mask, inherit_wrap_mask},
        else => 0
    };
    if matched == 0 then (
        binding_state.count = start_count;
        0
    ) else (
        1
    )
);

apply_function_value := {func_idx: i32, arg_idx: i32, span_start: i32} => (
    func_val := values(func_idx).value;
    func_val |> match {
        Value::String(string_value) => (
            if Value::Number(index_value) := values(arg_idx).value then (
                if index_value < 0 || index_value >= string_value.length then (
                    set_error_with_code{span_start, interp_err_array_index_out_of_range{}};
                    -1
                ) else if string_value.start < 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    store_value(Value::Char(input(string_value.start + index_value) + 0))
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::Record(rec_info) => (
            if Value::Number(index_value) := values(arg_idx).value then (
                field_idx := record_value_index_by_position{
                    rec_info.head,
                    rec_info.count,
                    rec_info.has_named,
                    index_value,
                    span_start
                };
                if field_idx == -1 then (
                    -1
                ) else (
                    field_idx
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::Function(fn_value) => (
            if NodeKind::Function(fn_info) := nodes(fn_value.node).kind then (
                runtime_state.function_depth = runtime_state.function_depth + 1;
                enter_scope{};
                mut result_idx := -1;
                if restore_closure_bindings{fn_value.closure_head, fn_value.closure_count} == 0 then (
                    result_idx = -1;
                ) else (
                    bind_pattern_state.value_idx = arg_idx;
                    bind_pattern_state.inherit_mut = 0;
                    bind_pattern_state.inherit_target_mask = 0;
                    bind_pattern_state.inherit_export_mask = 0;
                    bind_pattern_state.inherit_wrap_mask = 0;
                    if bind_pattern_simple(fn_info.parameter) == 0 then (
                        set_error(span_start);
                        result_idx = -1;
                    ) else (
                        result_idx = eval_expression(fn_info.body);
                        if flow_kind_is_return(flow_state.kind) == 1 then (
                            result_idx = flow_state.value;
                            flow_state.kind = FlowKind::None;
                            flow_state.value = -1;
                        );
                    );
                );
                exit_scope{};
                runtime_state.function_depth = runtime_state.function_depth - 1;
                result_idx
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::EnumConstructor(enum_ctor) => (
            if enum_ctor.expects_payload == 0 then (
                store_value(Value::Enum({
                    enum_head = enum_ctor.enum_head,
                    enum_count = enum_ctor.enum_count,
                    variant_idx = enum_ctor.variant_idx,
                    payload = -1
                }))
            ) else (
                store_value(Value::Enum({
                    enum_head = enum_ctor.enum_head,
                    enum_count = enum_ctor.enum_count,
                    variant_idx = enum_ctor.variant_idx,
                    payload = arg_idx
                }))
            )
        ),
        Value::MatchFunction(match_info) => (
            mut matched := 0;
            mut result_idx := -1;
            mut branch_idx := 0;
            while branch_idx < match_info.count && matched == 0 do (
                branch_value_idx := match_info.head + branch_idx * 2 + 1;
                if Value::Function(branch_fn_value) := values(branch_value_idx).value then (
                    if NodeKind::Function(branch_fn) := nodes(branch_fn_value.node).kind then (
                        enter_scope{};
                        if restore_closure_bindings{
                            branch_fn_value.closure_head,
                            branch_fn_value.closure_count
                        } == 0 then (
                            matched = 1;
                            result_idx = -1;
                            0
                        ) else (
                            bind_pattern_state.value_idx = arg_idx;
                            bind_pattern_state.inherit_mut = 0;
                            bind_pattern_state.inherit_target_mask = 0;
                            bind_pattern_state.inherit_export_mask = 0;
                            bind_pattern_state.inherit_wrap_mask = 0;
                            if bind_pattern_simple(branch_fn.parameter) == 1 then (
                                matched = 1;
                                runtime_state.function_depth = runtime_state.function_depth + 1;
                                result_idx = eval_expression(branch_fn.body);
                                if flow_kind_is_return(flow_state.kind) == 1 then (
                                    result_idx = flow_state.value;
                                    flow_state.kind = FlowKind::None;
                                    flow_state.value = -1;
                                );
                                runtime_state.function_depth = runtime_state.function_depth - 1;
                                0
                            ) else (
                                0
                            )
                        );
                        exit_scope{};
                    ) else (
                        set_error(span_start);
                        matched = 1;
                        result_idx = -1;
                    )
                ) else (
                    set_error(span_start);
                    matched = 1;
                    result_idx = -1;
                );
                if matched == 0 then (
                    branch_idx = branch_idx + 1;
                    0
                ) else (
                    0
                );
                {}
            );
            if matched == 0 then (
                set_error_with_code{span_start, interp_err_match_no_branch{}};
                -1
            ) else (
                result_idx
            )
        ),
        Value::Builtin(builtin_id) => (
            if builtin_id == builtin_enum{} then (
                if Value::Record(rec_info) := values(arg_idx).value then (
                    if rec_info.has_named == 0 then (
                        set_error(span_start);
                        -1
                    ) else if enum_record_payloads_are_types{rec_info.head, rec_info.count} == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = rec_info.head, count = rec_info.count }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == builtin_match{} then (
                if Value::Record(rec_info) := values(arg_idx).value then (
                    store_value(Value::MatchFunction({ head = rec_info.head, count = rec_info.count }))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == builtin_option{} then (
                option_enum_idx := option_enum_from_type{arg_idx, span_start};
                if option_enum_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    option_enum_idx
                )
            ) else if builtin_id == builtin_iterator{} then (
                if runtime_state.option_enum_idx == -1 then (
                    set_error(span_start);
                    -1
                ) else (
                    type_bind_idx := find_binding_index(SYNTHETIC_TYPE_STRING);
                    if type_bind_idx == -1 then (
                        set_error(span_start);
                        -1
                    ) else (
                        start_idx := value_state.count;
                        name_idx := store_value(Value::String(SYNTHETIC_BOX_STRING));
                    if name_idx == -1 then (
                        -1
                    ) else (
                        param_idx := store_value(values(arg_idx).value);
                        if param_idx == -1 then (
                            -1
                        ) else (
                            name_idx2 := store_value(Value::String(EMPTY_STRING));
                            if name_idx2 == -1 then (
                                -1
                            ) else (
                                ret_idx := store_value(values(runtime_state.option_enum_idx).value);
                                if ret_idx == -1 then (
                                    -1
                                ) else (
                                    fn_type_idx := store_value(Value::Record({ head = start_idx, count = 2, has_named = 0 }));
                                    if fn_type_idx == -1 then (
                                        -1
                                    ) else (
                                        if mark_value_as_type(fn_type_idx) == -1 then (
                                            -1
                                        ) else (
                                        struct_start := value_state.count;
                                        name_idx3 := store_value(Value::String(SYNTHETIC_ITER_TY_STRING));
                                        if name_idx3 == -1 then (
                                            -1
                                        ) else (
                                            iter_ty_idx := copy_value(bindings(type_bind_idx).value);
                                            if iter_ty_idx == -1 then (
                                                -1
                                            ) else (
                                                name_idx4 := store_value(Value::String(SYNTHETIC_NEXT_STRING));
                                                if name_idx4 == -1 then (
                                                    -1
                                                ) else (
                                                    next_idx := store_value(values(fn_type_idx).value);
                                                    if next_idx == -1 then (
                                                        -1
                                                    ) else (
                                                        iter_idx := store_value(Value::Record({ head = struct_start, count = 2, has_named = 1 }));
                                                        if iter_idx == -1 then (
                                                            -1
                                                        ) else (
                                                            mark_value_as_type(iter_idx)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    )
                )
            ) else if builtin_id == builtin_export{} || builtin_id == builtin_target{} || builtin_id == builtin_wrap{} then (
                if Value::Target(target_tag) := values(arg_idx).value then (
                    if builtin_id == builtin_wrap{} && target_tag_is_wgsl(target_tag) == 1 then (
                        set_error(span_start);
                        -1
                    ) else (
                        annotation := if builtin_id == builtin_export{} then BindingAnnotationValue::Export(target_tag) else (
                            if builtin_id == builtin_target{} then BindingAnnotationValue::Target(target_tag) else BindingAnnotationValue::Wrap(target_tag)
                        );
                        store_value(Value::BindingAnnotation(annotation))
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == builtin_asm{} then (
                if Value::Target(target_tag) := values(arg_idx).value then (
                    store_value(Value::AsmFunction(target_tag))
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == builtin_use{} then (
                if Value::String(path_ref) := values(arg_idx).value then (
                    eval_use_from_string{path_ref, span_start}
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else if builtin_id == builtin_range_next{} then (
                if Value::Record(range_info) := values(arg_idx).value then (
                    if range_info.count < 2 then (
                        set_error(span_start);
                        -1
                    ) else (
                        current_idx := range_info.head + 1;
                        end_idx := range_info.head + 3;
                        if Value::Number(curr) := values(current_idx).value then (
                            if Value::Number(end_val) := values(end_idx).value then (
                                if curr < end_val then (
                                    payload_idx := store_value(Value::Number(curr));
                                    if payload_idx == -1 then (
                                        -1
                                    ) else (
                                        values(current_idx).value = Value::Number(curr + 1);
                                        if runtime_state.option_i32_enum_idx == -1 then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            if Value::EnumType(enum_info) := values(runtime_state.option_i32_enum_idx).value then (
                                                variant_idx := enum_info.head;
                                                store_value(Value::Enum({
                                                    enum_head = enum_info.head,
                                                    enum_count = enum_info.count,
                                                    variant_idx = variant_idx,
                                                    payload = payload_idx
                                                }))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        )
                                    )
                                ) else (
                                    if runtime_state.option_i32_enum_idx == -1 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        if Value::EnumType(enum_info) := values(runtime_state.option_i32_enum_idx).value then (
                                            variant_idx := enum_info.head + 2;
                                            store_value(Value::Enum({
                                                enum_head = enum_info.head,
                                                enum_count = enum_info.count,
                                                variant_idx = variant_idx,
                                                payload = -1
                                            }))
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                ) else (
                    set_error(span_start);
                    -1
                )
            ) else (
                set_error(span_start);
                -1
            )
        ),
        Value::IntrinsicBinaryMethod(operator) => (
            store_value(Value::IntrinsicBinaryPartial({
                operator = binary_intrinsic_operator_tag(operator),
                left = arg_idx
            }))
        ),
        Value::IntrinsicBinaryPartial(info) => (
            eval_binary_intrinsic_values{
                info.left,
                arg_idx,
                info.operator,
                span_start
            }
        ),
        Value::RangeMethod => (
            store_value(Value::RangePartial(arg_idx))
        ),
        Value::RangePartial(left_idx) => (
            eval_range_from_values{left_idx, arg_idx, span_start}
        ),
        Value::AsmFunction(target_tag) => (
            if ensure_asm_target_allowed{target_tag_value(target_tag), span_start} == 0 then (
                -1
            ) else if Value::String(code_ref) := values(arg_idx).value then (
                store_value(Value::InlineAssembly({ target = target_tag, code = code_ref }))
            ) else (
                set_error(span_start);
                -1
            )
        ),
        else => (
            set_error(span_start);
            -1
        )
    }
);

apply_impl_method := {
    object_idx: i32,
    object_expr: i32,
    property_start: i32,
    property_length: i32,
    span_start: i32
} => (
    mut type_idx := -1;
    if NodeKind::Identifier(id) := nodes(object_expr).kind then (
        bind_idx := find_binding_index(id.name);
        if bind_idx != -1 then (
            type_idx = bindings(bind_idx).type_value;
            0
        ) else 0;
        0
    ) else 0;
    if type_idx == -1 then (
        if object_idx != -1 then (
            type_idx = values(object_idx).type_value;
            0
        ) else 0
    ) else 0;
    if type_idx == -1 then (
        mut intrinsic_method_idx := lookup_intrinsic_operation_method{
            object_idx,
            property_start,
            property_length
        };
        if intrinsic_method_idx == -1 && op_is2{property_start, property_length, '.', '.'} == 1 then (
            intrinsic_method_idx = lookup_intrinsic_operation_method{
                object_idx,
                SYNTHETIC_OP_RANGE_STRING.start,
                SYNTHETIC_OP_RANGE_STRING.length
            };
            0
        ) else 0;
        if intrinsic_method_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            apply_function_value{intrinsic_method_idx, object_idx, span_start}
        )
    ) else (
        mut method_idx := impl_find_field_index{type_idx, property_start, property_length};
        if method_idx == -1 && op_is2{property_start, property_length, '.', '.'} == 1 then (
            method_idx = impl_find_field_index{
                type_idx,
                SYNTHETIC_OP_RANGE_STRING.start,
                SYNTHETIC_OP_RANGE_STRING.length
            };
            0
        ) else 0;
        if method_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            apply_function_value{method_idx, object_idx, span_start}
        )
    )
);

apply_impl_property := {object_expr: i32, object_value_idx: i32, property_start: i32, property_length: i32, span_start: i32} => (
    mut type_idx := -1;
    if NodeKind::Identifier(id) := nodes(object_expr).kind then (
        bind_idx := find_binding_index(id.name);
        if bind_idx != -1 then (
            type_idx = bindings(bind_idx).type_value;
            0
        ) else 0;
        0
    ) else 0;
    if type_idx == -1 then (
        if object_value_idx != -1 then (
            type_idx = values(object_value_idx).type_value;
            0
        ) else 0
    ) else 0;
    if type_idx == -1 then (
        intrinsic_method_idx := lookup_intrinsic_operation_method{
            object_value_idx,
            property_start,
            property_length
        };
        if intrinsic_method_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            intrinsic_method_idx
        )
    ) else (
        field_idx := impl_find_field_index{type_idx, property_start, property_length};
        if field_idx == -1 then (
            set_error(span_start);
            -1
        ) else (
            field_idx
        )
    )
);

eval_import_root := {root_idx: i32, span_start: i32} => (
    saved_binding_count := binding_state.count;
    saved_scope_count := binding_state.scope_count;
    saved_binding_target_depth := binding_target_state.depth;
    saved_binding_target_acc := binding_target_state.acc_mask;
    saved_flow_kind := flow_state.kind;
    saved_flow_value := flow_state.value;
    saved_loop_depth := runtime_state.loop_depth;
    saved_function_depth := runtime_state.function_depth;
    saved_option_enum_idx := runtime_state.option_enum_idx;
    saved_option_i32_enum_idx := runtime_state.option_i32_enum_idx;
    saved_type_value_idx := runtime_state.type_value_idx;
    saved_range_type_idx := runtime_state.range_type_idx;
    saved_bind_value := bind_pattern_state.value_idx;
    saved_bind_inherit_mut := bind_pattern_state.inherit_mut;
    saved_bind_inherit_target := bind_pattern_state.inherit_target_mask;
    saved_bind_inherit_export := bind_pattern_state.inherit_export_mask;
    saved_bind_inherit_wrap := bind_pattern_state.inherit_wrap_mask;
    saved_ann_mut := annotation_temp.is_mut;
    saved_ann_target := annotation_temp.target_mask;
    saved_ann_export := annotation_temp.export_mask;
    saved_ann_wrap := annotation_temp.wrap_mask;
    saved_temp_start := binding_temp.start;
    saved_temp_length := binding_temp.length;
    saved_temp_is_mut := binding_temp.is_mut;
    saved_temp_ok := binding_temp.ok;

    save_scope_stack(saved_scope_count);
    save_binding_target_stack(saved_binding_target_depth);

    binding_state.count = intrinsic_state.binding_count;
    binding_state.scope_count = 0;
    binding_target_state.depth = 0;
    binding_target_state.acc_mask = 0;
    flow_state.kind = FlowKind::None;
    flow_state.value = -1;
    runtime_state.loop_depth = 0;
    runtime_state.function_depth = 0;
    bind_pattern_state.value_idx = -1;
    bind_pattern_state.inherit_mut = 0;
    bind_pattern_state.inherit_target_mask = 0;
    bind_pattern_state.inherit_export_mask = 0;
    bind_pattern_state.inherit_wrap_mask = 0;
    annotation_temp.is_mut = 0;
    annotation_temp.target_mask = 0;
    annotation_temp.export_mask = 0;
    annotation_temp.wrap_mask = 0;
    binding_temp.start = 0;
    binding_temp.length = 0;
    binding_temp.is_mut = 0;
    binding_temp.ok = 0;

    mut result_idx := -1;
    if ensure_import_intrinsics{} == -1 then (
        set_error(span_start);
        0
    ) else (
        enter_scope{};
        result_idx = eval_expression(root_idx);
        if flow_kind_is_none(flow_state.kind) == 0 then (
            flow_state.kind = FlowKind::None;
            flow_state.value = -1;
            set_error(span_start);
            result_idx = -1;
            0
        ) else (
            0
        );
        exit_scope{};
        0
    );

    binding_state.count = saved_binding_count;
    binding_state.scope_count = saved_scope_count;
    restore_scope_stack(saved_scope_count);
    binding_target_state.depth = saved_binding_target_depth;
    binding_target_state.acc_mask = saved_binding_target_acc;
    restore_binding_target_stack(saved_binding_target_depth);
    flow_state.kind = saved_flow_kind;
    flow_state.value = saved_flow_value;
    runtime_state.loop_depth = saved_loop_depth;
    runtime_state.function_depth = saved_function_depth;
    runtime_state.option_enum_idx = saved_option_enum_idx;
    runtime_state.option_i32_enum_idx = saved_option_i32_enum_idx;
    runtime_state.type_value_idx = saved_type_value_idx;
    runtime_state.range_type_idx = saved_range_type_idx;
    bind_pattern_state.value_idx = saved_bind_value;
    bind_pattern_state.inherit_mut = saved_bind_inherit_mut;
    bind_pattern_state.inherit_target_mask = saved_bind_inherit_target;
    bind_pattern_state.inherit_export_mask = saved_bind_inherit_export;
    bind_pattern_state.inherit_wrap_mask = saved_bind_inherit_wrap;
    annotation_temp.is_mut = saved_ann_mut;
    annotation_temp.target_mask = saved_ann_target;
    annotation_temp.export_mask = saved_ann_export;
    annotation_temp.wrap_mask = saved_ann_wrap;
    binding_temp.start = saved_temp_start;
    binding_temp.length = saved_temp_length;
    binding_temp.is_mut = saved_temp_is_mut;
    binding_temp.ok = saved_temp_ok;

    result_idx
);

eval_expression: (i32 -> i32) := (idx: i32) => (
    if value_state.error != -1 then (
        -1
    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
        flow_state.value
    ) else (
        span_start := nodes(idx).span.start;
        nodes(idx).kind |> match {
            NodeKind::Literal(lit) => store_value(eval_literal(lit)),
            NodeKind::IntrinsicType(ty) => (
                ty |> match {
                    IntrinsicType::I32 => (
                        value_idx := store_value(Value::String(SYNTHETIC_I32_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::U8 => (
                        value_idx := store_value(Value::String(SYNTHETIC_U8_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Boolean => (
                        value_idx := store_value(Value::String(SYNTHETIC_BOOL_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Type => (
                        value_idx := store_value(Value::String(SYNTHETIC_TYPE_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::Target => (
                        value_idx := store_value(Value::String(SYNTHETIC_TARGET_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    IntrinsicType::BindingAnnotation => (
                        value_idx := store_value(Value::String(SYNTHETIC_BINDING_ANNOTATION_STRING));
                        if value_idx == -1 then -1 else mark_value_as_type(value_idx)
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Identifier(id) => (
                binding_idx := find_binding_index(id.name);
                if binding_idx == -1 then (
                    builtin := builtin_from_identifier(id.name);
                    if builtin != -1 then (
                        store_value(Value::Builtin(builtin))
                    ) else (
                        set_error_with_code{span_start, interp_err_unbound_identifier{}};
                        -1
                    )
                ) else (
                    if ensure_binding_target_access{binding_idx, span_start} == 0 then (
                        -1
                    ) else (
                        bindings(binding_idx).value
                    )
                )
            ),
            NodeKind::Binding(binding) => (
                target_mask := binding_pattern_target_mask(binding.pattern);
                if target_mask == -1 then (
                    -1
                ) else if push_binding_target_mask(target_mask) == 0 then (
                    -1
                ) else (
                    value_idx := eval_expression(binding.expr);
                    pop_binding_target_mask{};
                    if value_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        value_idx
                    ) else (
                        bind_pattern_state.value_idx = value_idx;
                        bind_pattern_state.inherit_mut = 0;
                        bind_pattern_state.inherit_target_mask = 0;
                        bind_pattern_state.inherit_export_mask = 0;
                        bind_pattern_state.inherit_wrap_mask = 0;
                        matched := bind_pattern_simple(binding.pattern);
                        if matched == 1 then (
                            store_value(Value::Boolean(1))
                        ) else (
                            store_value(Value::Boolean(0))
                        )
                    )
                )
            ),
            NodeKind::Assignment(info) => (
                value_idx := eval_expression(info.expr);
                if value_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    value_idx
                ) else (
                    info.target |> match {
                        LValue::Identifier(target_info) => (
                            idx := find_binding_index(target_info.name.name);
                            if idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{idx, span_start} == 0 then (
                                -1
                            ) else if bindings(idx).is_mut == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                bindings(idx).value = value_idx;
                                if bindings(idx).type_value != -1 then (
                                    values(value_idx).type_value = bindings(idx).type_value;
                                    0
                                ) else (
                                    0
                                );
                                value_idx
                            )
                        ),
                        LValue::TypePropertyAccess(target_info) => (
                            root_idx := resolve_lvalue_root_binding_from_expr(target_info.object);
                            if root_idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{root_idx, span_start} == 0 then (
                                -1
                            ) else if bindings(root_idx).is_mut == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                obj_idx := resolve_lvalue_expr_value_index{target_info.object, span_start};
                                if flow_kind_is_none(flow_state.kind) == 0 then (
                                    flow_state.value
                                ) else if obj_idx == -1 then (
                                    -1
                                ) else (
                                    if Value::Record(struct_info) := values(obj_idx).value then (
                                        field_idx := record_find_field_index{
                                            struct_info.head,
                                            struct_info.count,
                                            struct_info.has_named,
                                            target_info.property.start,
                                            target_info.property.length,
                                            span_start
                                        };
                                        if field_idx == -1 then (
                                            -1
                                        ) else (
                                            values(field_idx).value = values(value_idx).value;
                                            values(field_idx).type_value = values(value_idx).type_value;
                                            values(field_idx).is_box_type = values(value_idx).is_box_type;
                                            value_idx
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                )
                            )
                        ),
                        LValue::ArrayIndex(target_info) => (
                            root_idx := resolve_lvalue_root_binding_from_expr(target_info.array);
                            if root_idx == -1 then (
                                set_error(span_start);
                                -1
                            ) else if ensure_binding_target_access{root_idx, span_start} == 0 then (
                                -1
                            ) else if bindings(root_idx).is_mut == 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                arr_idx := resolve_lvalue_expr_value_index{target_info.array, span_start};
                                if flow_kind_is_none(flow_state.kind) == 0 then (
                                    flow_state.value
                                ) else if arr_idx == -1 then (
                                    -1
                                ) else (
                                    index_idx := eval_expression(target_info.index);
                                    if index_idx == -1 then (
                                        -1
                                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                                        flow_state.value
                                    ) else (
                                        if Value::Number(index_value) := values(index_idx).value then (
                                            if Value::Record(struct_info) := values(arr_idx).value then (
                                                arr_idx2 := if struct_info.has_named == -1 then (
                                                    materialize_repeated_record{arr_idx, span_start}
                                                ) else (
                                                    arr_idx
                                                );
                                                if arr_idx2 == -1 then (
                                                    -1
                                                ) else (
                                                    if Value::Record(struct_info2) := values(arr_idx2).value then (
                                                        field_idx := record_value_index_by_position{
                                                            struct_info2.head,
                                                            struct_info2.count,
                                                            struct_info2.has_named,
                                                            index_value,
                                                            span_start
                                                        };
                                                        if field_idx == -1 then (
                                                            -1
                                                        ) else (
                                                            values(field_idx).value = values(value_idx).value;
                                                            values(field_idx).type_value = values(value_idx).type_value;
                                                            values(field_idx).is_box_type = values(value_idx).is_box_type;
                                                            value_idx
                                                        )
                                                    ) else (
                                                        set_error(span_start);
                                                        -1
                                                    )
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    )
                                )
                            )
                        ),
                        else => (
                            set_error(span_start);
                            -1
                        )
                    }
                )
            ),
            NodeKind::Function(_) => (
                closure_info := capture_closure_bindings{};
                if value_state.error != -1 then (
                    -1
                ) else (
                    store_value(Value::Function({
                        node = idx,
                        closure_head = closure_info.head,
                        closure_count = closure_info.count
                    }))
                )
            ),
            NodeKind::BoxType(inner_idx) => (
                inner_value_idx := eval_expression(inner_idx);
                if inner_value_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    inner_value_idx
                ) else if value_is_type_like(inner_value_idx) == 0 then (
                    set_error(span_start);
                    -1
                ) else if value_is_box_type_flag(inner_value_idx) == 1 then (
                    set_error(span_start);
                    -1
                ) else (
                    start_idx := value_state.count;
                    name_idx := store_value(Value::String(SYNTHETIC_BOX_STRING));
                    if name_idx == -1 then (
                        -1
                    ) else (
                        val_idx := store_value(values(inner_value_idx).value);
                        if val_idx == -1 then (
                            -1
                        ) else (
                            box_idx := store_value(Value::Record({ head = start_idx, count = 1, has_named = 0 }));
                            if box_idx == -1 then (
                                -1
                            ) else (
                                mark_value_as_box_type(box_idx);
                                mark_value_as_type(box_idx)
                            )
                        )
                    )
                )
            ),
            NodeKind::FunctionType(info) => (
                param_value_idx := eval_expression(info.parameter);
                if param_value_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    param_value_idx
                ) else if value_is_type_like(param_value_idx) == 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    ret_value_idx := eval_expression(info.return_type);
                    if ret_value_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        ret_value_idx
                    ) else if value_is_type_like(ret_value_idx) == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        start_idx := value_state.count;
                        name_idx := store_value(Value::String(EMPTY_STRING));
                        if name_idx == -1 then (
                            -1
                        ) else (
                            param_idx := store_value(values(param_value_idx).value);
                            if param_idx == -1 then (
                                -1
                            ) else (
                                name_idx2 := store_value(Value::String(EMPTY_STRING));
                                if name_idx2 == -1 then (
                                    -1
                                ) else (
                                    ret_idx := store_value(values(ret_value_idx).value);
                                    if ret_idx == -1 then (
                                        -1
                                    ) else (
                                        fn_type_idx := store_value(Value::Record({ head = start_idx, count = 2, has_named = 0 }));
                                        if fn_type_idx == -1 then (
                                            -1
                                        ) else (
                                            mark_value_as_type(fn_type_idx)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ),
            NodeKind::FunctionCall(info) => (
                if NodeKind::TypePropertyAccess(access) := nodes(info.function).kind then (
                    obj_idx := eval_expression(access.object);
                    if obj_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        obj_idx
                    ) else (
                        if info.argument == access.object then (
                            obj_val := values(obj_idx).value;
                            if Value::Record(struct_info) := obj_val then (
                                field_idx := record_find_field_index_no_error{
                                    struct_info.head,
                                    struct_info.count,
                                    struct_info.has_named,
                                    access.property.start,
                                    access.property.length
                                };
                                if field_idx != -1 then (
                                    copy_value(field_idx)
                                ) else (
                                    apply_impl_method{
                                        obj_idx,
                                        access.object,
                                        access.property.start,
                                        access.property.length,
                                        span_start
                                    }
                                )
                            ) else (
                                apply_impl_method{
                                    obj_idx,
                                    access.object,
                                    access.property.start,
                                    access.property.length,
                                    span_start
                                }
                            )
                        ) else (
                            obj_val := values(obj_idx).value;
                            if Value::EnumType(enum_info) := obj_val then (
                                payload_idx := record_find_field_index_no_error{
                                    enum_info.head,
                                    enum_info.count,
                                    1,
                                    access.property.start,
                                    access.property.length
                                };
                                if payload_idx == -1 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    variant_idx := payload_idx - 1;
                                    expects_payload := if Value::Unit := values(payload_idx).value then 0 else 1;
                                    if expects_payload == 0 then (
                                        store_value(Value::Enum({
                                            enum_head = enum_info.head,
                                            enum_count = enum_info.count,
                                            variant_idx = variant_idx,
                                            payload = -1
                                        }))
                                    ) else (
                                        payload_value_idx := eval_expression(info.argument);
                                        if payload_value_idx == -1 then (
                                            -1
                                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                                            payload_value_idx
                                        ) else (
                                            store_value(Value::Enum({
                                                enum_head = enum_info.head,
                                                enum_count = enum_info.count,
                                                variant_idx = variant_idx,
                                                payload = payload_value_idx
                                            }))
                                        )
                                    )
                                )
                            ) else (
                                prop_idx := if Value::Record(struct_info) := obj_val then (
                                    field_idx := record_find_field_index_no_error{
                                        struct_info.head,
                                        struct_info.count,
                                        struct_info.has_named,
                                        access.property.start,
                                        access.property.length
                                    };
                                    if field_idx == -1 then (
                                        apply_impl_property{
                                            access.object,
                                            obj_idx,
                                            access.property.start,
                                            access.property.length,
                                            span_start
                                        }
                                    ) else (
                                        field_idx
                                    )
                                ) else (
                                    apply_impl_property{
                                        access.object,
                                        obj_idx,
                                        access.property.start,
                                        access.property.length,
                                        span_start
                                    }
                                );
                                if prop_idx == -1 then (
                                    -1
                                ) else (
                                    arg_idx := eval_expression(info.argument);
                                    if arg_idx == -1 then (
                                        -1
                                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                                        arg_idx
                                    ) else (
                                        apply_function_value{prop_idx, arg_idx, span_start}
                                    )
                                )
                            )
                        )
                    )
                ) else (
                    func_idx := eval_expression(info.function);
                    if func_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        func_idx
                    ) else (
                        arg_idx := eval_expression(info.argument);
                        if arg_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            arg_idx
                        ) else (
                            apply_function_value{func_idx, arg_idx, span_start}
                        )
                    )
                )
            ),
            NodeKind::AttachImplementation(info) => (
                type_idx := eval_expression(info.type_expr);
                if type_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    type_idx
                ) else (
                    impl_idx := eval_expression(info.implementation);
                    if impl_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        impl_idx
                    ) else (
                        if Value::Record(_) := values(impl_idx).value then (
                            if impl_add{type_idx, impl_idx} == -1 then (
                                -1
                            ) else (
                                type_idx
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::IntrinsicOperation(info) => (
                info |> match {
                    IntrinsicOperation::Binary(bin) => (
                        left_idx := eval_expression(bin.left);
                        if left_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            left_idx
                        ) else (
                            right_idx := eval_expression(bin.right);
                            if right_idx == -1 then (
                                -1
                            ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                                right_idx
                            ) else (
                                left := values(left_idx).value;
                                right := values(right_idx).value;
                                bin.operator |> match {
                                    BinaryIntrinsicOperator::I32Add => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv + rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Subtract => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv - rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Multiply => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Number(lv * rv))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Divide => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                if rv == 0 then (
                                                    set_error(span_start);
                                                    -1
                                                ) else (
                                                    store_value(Value::Number(lv / rv))
                                                )
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32Equal => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv == rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32NotEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv < rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThan => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv > rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32LessThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv <= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::I32GreaterThanOrEqual => (
                                        if Value::Number(lv) := left then (
                                            if Value::Number(rv) := right then (
                                                store_value(Value::Boolean(if lv >= rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanAnd => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 && rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanOr => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv == 1 || rv == 1 then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    BinaryIntrinsicOperator::BooleanXor => (
                                        if Value::Boolean(lv) := left then (
                                            if Value::Boolean(rv) := right then (
                                                store_value(Value::Boolean(if lv != rv then 1 else 0))
                                            ) else (
                                                set_error(span_start);
                                                -1
                                            )
                                        ) else (
                                            set_error(span_start);
                                            -1
                                        )
                                    ),
                                    else => (
                                        set_error(span_start);
                                        -1
                                    )
                                }
                            )
                        )
                    ),
                    IntrinsicOperation::Unary(unary) => (
                        operand_idx := eval_expression(unary.operand);
                        if operand_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            operand_idx
                        ) else (
                            unary.operator |> match {
                                UnaryIntrinsicOperator::BooleanNot => (
                                    if Value::Boolean(flag) := values(operand_idx).value then (
                                        store_value(Value::Boolean(if flag == 1 then 0 else 1))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::EnumFromStruct => (
                                    if Value::Record(rec_info) := values(operand_idx).value then (
                                        if rec_info.has_named == 0 then (
                                            set_error(span_start);
                                            -1
                                        ) else if enum_record_payloads_are_types{rec_info.head, rec_info.count} == 0 then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            enum_idx := store_value(Value::EnumType({ head = rec_info.head, count = rec_info.count }));
                                            if enum_idx == -1 then (
                                                -1
                                            ) else (
                                                mark_value_as_type(enum_idx)
                                            )
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::MatchFromStruct => (
                                    if Value::Record(rec_info) := values(operand_idx).value then (
                                        store_value(Value::MatchFunction({ head = rec_info.head, count = rec_info.count }))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::UseFromString => (
                                    if Value::String(path_ref) := values(operand_idx).value then (
                                        eval_use_from_string{path_ref, span_start}
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BoxFromType => (
                                    if value_is_type_like(operand_idx) == 0 then (
                                        set_error(span_start);
                                        -1
                                    ) else if value_is_box_type_flag(operand_idx) == 1 then (
                                        set_error(span_start);
                                        -1
                                    ) else (
                                        start_idx := value_state.count;
                                        name_idx := store_value(Value::String(EMPTY_STRING));
                                        if name_idx == -1 then (
                                            -1
                                        ) else (
                                            val_idx := store_value(values(operand_idx).value);
                                            if val_idx == -1 then (
                                                -1
                                            ) else (
                                                box_idx := store_value(Value::Record({ head = start_idx, count = 1, has_named = 0 }));
                                                if box_idx == -1 then (
                                                    -1
                                                ) else (
                                                    mark_value_as_box_type(box_idx);
                                                    mark_value_as_type(box_idx)
                                                )
                                            )
                                        )
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationExportFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx).value then (
                                        store_value(Value::BindingAnnotation(BindingAnnotationValue::Export(target_tag)))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationTargetFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx).value then (
                                        store_value(Value::BindingAnnotation(BindingAnnotationValue::Target(target_tag)))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::BindingAnnotationWrapFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx).value then (
                                        if target_tag_is_wgsl(target_tag) == 1 then (
                                            set_error(span_start);
                                            -1
                                        ) else (
                                            store_value(Value::BindingAnnotation(BindingAnnotationValue::Wrap(target_tag)))
                                        )
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                UnaryIntrinsicOperator::AssemblyFromTarget => (
                                    if Value::Target(target_tag) := values(operand_idx).value then (
                                        store_value(Value::AsmFunction(target_tag))
                                    ) else (
                                        set_error(span_start);
                                        -1
                                    )
                                ),
                                else => (
                                    set_error(span_start);
                                    -1
                                )
                            }
                        )
                    ),
                    IntrinsicOperation::InlineAssembly(info) => (
                        code_idx := eval_expression(info.code);
                        if code_idx == -1 then (
                            -1
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            code_idx
                        ) else (
                            target_tag := target_literal_value(info.target);
                            if ensure_asm_target_allowed{target_tag_value(target_tag), span_start} == 0 then (
                                -1
                            ) else if Value::String(code_ref) := values(code_idx).value then (
                                store_value(Value::InlineAssembly({
                                    target = target_tag,
                                    code = code_ref
                                }))
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        )
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::Operation(info) => (
                left_idx := eval_expression(info.left);
                if left_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    left_idx
                ) else (
                    right_idx := eval_expression(info.right);
                    if right_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        right_idx
                    ) else (
                        if op_is2{info.operator.start, info.operator.length, '.', '.'} == 1 then (
                            eval_range_from_values{left_idx, right_idx, span_start}
                        ) else (
                            self_call_idx := eval_operation_self_call{
                                info.left,
                                left_idx,
                                info.operator.start,
                                info.operator.length,
                                span_start
                            };
                            if self_call_idx == -1 then (
                                -1
                            ) else (
                                apply_function_value{self_call_idx, right_idx, span_start}
                            )
                        )
                    )
                )
            ),
            NodeKind::If(info) => (
                cond_idx := eval_expression(info.condition);
                if cond_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    cond_idx
                ) else (
                    cond_value := values(cond_idx).value;
                    if Value::Boolean(flag) := cond_value then (
                        if check_if_branch_type_compat{
                            info.then_branch,
                            info.else_branch,
                            span_start
                        } == 0 then (
                            -1
                        ) else if flag == 1 then (
                            eval_expression(info.then_branch)
                        ) else (
                            eval_expression(info.else_branch)
                        )
                    ) else (
                        set_error(span_start);
                        -1
                    )
                )
            ),
            NodeKind::Block(list) => (
                enter_scope{};
                mut current := list.head;
                mut count := 0;
                mut last_idx: i32 := store_value(Value::Unit);
                while count < list.count && current != -1 do (
                    last_idx = eval_expression(list_nodes(current).value);
                    if value_state.error != -1 || flow_kind_is_none(flow_state.kind) == 0 then (
                        current = -1;
                        0
                    ) else (
                        current = list_nodes(current).next;
                        count = count + 1;
                        0
                    );
                    {}
                );
                exit_scope{};
                last_idx
            ),
            NodeKind::Loop(info) => (
                runtime_state.loop_depth = runtime_state.loop_depth + 1;
                mut last_idx := store_value(Value::Unit);
                mut done := 0;
                while done == 0 do (
                    last_idx = eval_expression(info.body);
                    if value_state.error != -1 then (
                        done = 1;
                        0
                    ) else if flow_kind_is_break(flow_state.kind) == 1 then (
                        last_idx = flow_state.value;
                        flow_state.kind = FlowKind::None;
                        flow_state.value = -1;
                        done = 1;
                        0
                    ) else if flow_kind_is_return(flow_state.kind) == 1 then (
                        done = 1;
                        0
                    ) else (
                        0
                    );
                    {}
                );
                runtime_state.loop_depth = runtime_state.loop_depth - 1;
                last_idx
            ),
            NodeKind::Diverge(info) => (
                info.divergance_type |> match {
                    DivergeExpressionType::Break => (
                        if runtime_state.loop_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FlowKind::Break;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    DivergeExpressionType::Return => (
                        if runtime_state.function_depth <= 0 then (
                            set_error(span_start);
                            -1
                        ) else (
                            value_idx := eval_expression(info.value);
                            if value_idx == -1 then (
                                -1
                            ) else (
                                flow_state.kind = FlowKind::Return;
                                flow_state.value = value_idx;
                                value_idx
                            )
                        )
                    ),
                    else => (
                        set_error(span_start);
                        -1
                    )
                }
            ),
            NodeKind::EnumType(info) => (
                mut current := info.variants;
                mut temp_head := -1;
                mut temp_tail := -1;
                mut last_idx := -1;
                mut type_ok := 1;
                while current != -1 do (
                    variant_node := list_nodes(current).value;
                    if NodeKind::Binding(variant_binding) := nodes(variant_node).kind then (
                        last_idx = eval_expression(variant_binding.expr);
                        if last_idx == -1 then (
                            current = -1;
                        ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                            current = -1;
                        ) else if value_is_type_like(last_idx) == 0 then (
                            type_ok = 0;
                            current = -1;
                        ) else (
                            temp_node := new_list_node{last_idx, -1};
                            if temp_node == -1 then (
                                current = -1;
                            ) else (
                                if temp_head == -1 then (
                                    temp_head = temp_node;
                                ) else (
                                    list_nodes(temp_tail).next = temp_node;
                                );
                                temp_tail = temp_node;
                                current = list_nodes(current).next;
                            )
                        )
                    ) else (
                        set_error(span_start);
                        current = -1;
                    );
                    {}
                );
                if value_state.error != -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    last_idx
                ) else if type_ok == 0 then (
                    set_error(span_start);
                    -1
                ) else (
                    start_idx := value_state.count;
                    mut count := 0;
                    current = info.variants;
                    mut temp_current := temp_head;
                    while current != -1 && temp_current != -1 do (
                        variant_node := list_nodes(current).value;
                        if NodeKind::Binding(variant_binding) := nodes(variant_node).kind then (
                            mut variant_name := EMPTY_STRING;
                            variant_binding.pattern |> match {
                                BindingPattern::Identifier(id) => (variant_name = id.name.name),
                                else => (variant_name = EMPTY_STRING)
                            };
                            if variant_name.length <= 0 then (
                                set_error(span_start);
                                current = -1;
                                temp_current = -1;
                            ) else (
                                name_idx := store_value(Value::String(variant_name));
                                if name_idx == -1 then (
                                    current = -1;
                                    temp_current = -1;
                                ) else (
                                    source_idx := list_nodes(temp_current).value;
                                    val_idx := copy_value(source_idx);
                                    if val_idx == -1 then (
                                        current = -1;
                                        temp_current = -1;
                                    ) else (
                                        normalized_val_idx := mark_intrinsic_string_value_as_type(val_idx);
                                        if normalized_val_idx == -1 then (
                                            current = -1;
                                            temp_current = -1;
                                        ) else (
                                        count = count + 1;
                                        current = list_nodes(current).next;
                                        temp_current = list_nodes(temp_current).next;
                                        )
                                    )
                                )
                            )
                        ) else (
                            set_error(span_start);
                            current = -1;
                            temp_current = -1;
                        );
                        {}
                    );
                    if value_state.error != -1 then (
                        -1
                    ) else (
                        enum_idx := store_value(Value::EnumType({ head = start_idx, count = count }));
                        if enum_idx == -1 then (
                            -1
                        ) else (
                            mark_value_as_type(enum_idx)
                        )
                    )
                )
            ),
            NodeKind::Match(info) => (
                value_idx := eval_expression(info.value);
                if value_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    value_idx
                ) else (
                    mut matched := 0;
                    mut result_idx := -1;
                    mut current := info.branches;
                    while current != -1 && matched == 0 do (
                        branch_node := list_nodes(current).value;
                        if NodeKind::Binding(branch_binding) := nodes(branch_node).kind then (
                            enter_scope{};
                            bind_pattern_state.value_idx = value_idx;
                            bind_pattern_state.inherit_mut = 0;
                            bind_pattern_state.inherit_target_mask = 0;
                            bind_pattern_state.inherit_export_mask = 0;
                            bind_pattern_state.inherit_wrap_mask = 0;
                            if bind_pattern_simple(branch_binding.pattern) == 1 then (
                                matched = 1;
                                result_idx = eval_expression(branch_binding.expr);
                                0
                            ) else (
                                0
                            );
                            exit_scope{};
                        ) else (
                            set_error(span_start);
                            matched = 1;
                            result_idx = -1;
                        );
                        if matched == 0 then (
                            current = list_nodes(current).next;
                            0
                        ) else (
                            0
                        );
                        {}
                    );
                    if matched == 0 then (
                        set_error_with_code{span_start, interp_err_match_no_branch{}};
                        -1
                    ) else (
                        result_idx
                    )
                )
            ),
            NodeKind::EnumValue(info) => (
                enum_idx := eval_expression(info.enum_type);
                if enum_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    enum_idx
                ) else (
                    payload_idx := eval_expression(info.payload);
                    if payload_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        payload_idx
                    ) else (
                        if Value::EnumType(enum_info) := values(enum_idx).value then (
                            payload_slot := record_find_field_index_no_error{
                                enum_info.head,
                                enum_info.count,
                                1,
                                info.variant.name.start,
                                info.variant.name.length
                            };
                            if payload_slot == -1 then (
                                set_error(span_start);
                                -1
                            ) else (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    payload = payload_idx
                                }))
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::EnumConstructor(info) => (
                enum_idx := eval_expression(info.enum_type);
                if enum_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    enum_idx
                ) else (
                    payload_type_idx := eval_expression(info.payload_type);
                    if payload_type_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        payload_type_idx
                    ) else if value_is_type_like(payload_type_idx) == 0 then (
                        set_error(span_start);
                        -1
                    ) else (
                        if Value::EnumType(enum_info) := values(enum_idx).value then (
                            expects_payload := if Value::Unit := values(payload_type_idx).value then 0 else 1;
                            payload_slot := record_find_field_index_no_error{
                                enum_info.head,
                                enum_info.count,
                                1,
                                info.variant.name.start,
                                info.variant.name.length
                            };
                            if payload_slot == -1 then (
                                set_error(span_start);
                                -1
                            ) else if expects_payload == 0 then (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    payload = -1
                                }))
                            ) else (
                                store_value(Value::EnumConstructor({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = payload_slot - 1,
                                    expects_payload = 1
                                }))
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::ArrayIndex(info) => (
                array_idx := eval_expression(info.array);
                if array_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    array_idx
                ) else (
                    index_idx := eval_expression(info.index);
                    if index_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        index_idx
                    ) else (
                        if Value::Number(index_value) := values(index_idx).value then (
                            if Value::String(string_value) := values(array_idx).value then (
                                if index_value < 0 || index_value >= string_value.length then (
                                    set_error_with_code{span_start, interp_err_array_index_out_of_range{}};
                                    -1
                                ) else if string_value.start < 0 then (
                                    set_error(span_start);
                                    -1
                                ) else (
                                    store_value(Value::Char(input(string_value.start + index_value) + 0))
                                )
                            ) else if Value::Record(struct_info) := values(array_idx).value then (
                                field_idx := record_value_index_by_position{
                                    struct_info.head,
                                    struct_info.count,
                                    struct_info.has_named,
                                    index_value,
                                    span_start
                                };
                                if field_idx == -1 then (
                                    -1
                                ) else (
                                    field_idx
                                )
                            ) else (
                                set_error(span_start);
                                -1
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::TypePropertyAccess(info: TypePropertyAccessInfo) => (
                obj_idx := eval_expression(info.object);
                if obj_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    obj_idx
                ) else (
                    obj_val := values(obj_idx).value;
                    if Value::EnumType(enum_info) := obj_val then (
                        payload_idx := record_find_field_index_no_error{
                            enum_info.head,
                            enum_info.count,
                            1,
                            info.property.start,
                            info.property.length
                        };
                        if payload_idx == -1 then (
                            set_error(span_start);
                            -1
                        ) else (
                            variant_idx := payload_idx - 1;
                            expects_payload := if Value::Unit := values(payload_idx).value then 0 else 1;
                            if expects_payload == 0 then (
                                store_value(Value::Enum({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = variant_idx,
                                    payload = -1
                                }))
                            ) else (
                                store_value(Value::EnumConstructor({
                                    enum_head = enum_info.head,
                                    enum_count = enum_info.count,
                                    variant_idx = variant_idx,
                                    expects_payload = 1
                                }))
                            )
                        )
                    ) else if Value::Record(struct_info) := obj_val then (
                        field_idx := record_find_field_index_no_error{
                            struct_info.head,
                            struct_info.count,
                            struct_info.has_named,
                            info.property.start,
                            info.property.length
                        };
                        if field_idx == -1 then (
                            apply_impl_property{
                                info.object,
                                obj_idx,
                                info.property.start,
                                info.property.length,
                                span_start
                            }
                        ) else (
                            copied_idx := copy_value(field_idx);
                            if copied_idx == -1 then (
                                -1
                            ) else (
                                copied_val := values(copied_idx).value;
                                if Value::String(name_ref) := copied_val then (
                                    if name_ref.start < 0 then (
                                        if (name_ref.start == SYNTHETIC_I32_STRING.start && name_ref.length == SYNTHETIC_I32_STRING.length)
                                            || (name_ref.start == SYNTHETIC_U8_STRING.start && name_ref.length == SYNTHETIC_U8_STRING.length)
                                            || (name_ref.start == SYNTHETIC_BOOL_STRING.start && name_ref.length == SYNTHETIC_BOOL_STRING.length)
                                            || (name_ref.start == SYNTHETIC_TYPE_STRING.start && name_ref.length == SYNTHETIC_TYPE_STRING.length)
                                        then (
                                            if mark_value_as_type(copied_idx) == -1 then (
                                                -1
                                            ) else (
                                                copied_idx
                                            )
                                        ) else (
                                            copied_idx
                                        )
                                    ) else (
                                        copied_idx
                                    )
                                ) else (
                                    copied_idx
                                )
                            )
                        )
                    ) else (
                        apply_impl_property{
                            info.object,
                            obj_idx,
                            info.property.start,
                            info.property.length,
                            span_start
                        }
                    )
                )
            ),
            NodeKind::ArrayRepeat(info) => (
                value_idx := eval_expression(info.value);
                if value_idx == -1 then (
                    -1
                ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                    value_idx
                ) else (
                    count_idx := eval_expression(info.count);
                    if count_idx == -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        count_idx
                    ) else (
                        if Value::Number(count_value) := values(count_idx).value then (
                            if count_value < 0 then (
                                set_error(span_start);
                                -1
                            ) else (
                                if count_value == 0 then (
                                    array_idx := store_value(Value::Record({ head = value_state.count, count = 0, has_named = 0 }));
                                    if array_idx == -1 then (
                                        -1
                                    ) else if value_is_type_like(value_idx) == 1 then (
                                        mark_value_as_type(array_idx)
                                    ) else (
                                        array_idx
                                    )
                                ) else (
                                    start_idx := value_state.count;
                                    name_idx := store_value(Value::String(EMPTY_STRING));
                                    if name_idx == -1 then (
                                        -1
                                    ) else (
                                        val_idx := store_value(values(value_idx).value);
                                        if val_idx == -1 then (
                                            -1
                                        ) else (
                                            array_idx := store_value(Value::Record({ head = start_idx, count = count_value, has_named = -1 }));
                                            if array_idx == -1 then (
                                                -1
                                            ) else if value_is_type_like(value_idx) == 1 then (
                                                mark_value_as_type(array_idx)
                                            ) else (
                                                array_idx
                                            )
                                        )
                                    )
                                )
                            )
                        ) else (
                            set_error(span_start);
                            -1
                        )
                    )
                )
            ),
            NodeKind::Struct(info) => (
                if is_empty_struct(info.fields) == 1 then (
                    unit_idx := store_value(Value::Unit);
                    if unit_idx == -1 then (
                        -1
                    ) else (
                        mark_value_as_type(unit_idx)
                    )
                ) else (
                    mut current := info.fields;
                    mut temp_head := -1;
                    mut temp_tail := -1;
                    mut last_idx := -1;
                    mut struct_is_type := 1;
                    while current != -1 do (
                        field_node := list_nodes(current).value;
                        if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                            last_idx = eval_expression(field_binding.expr);
                            if last_idx == -1 then (
                                current = -1;
                            ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                                current = -1;
                            ) else (
                                if value_is_type_like(last_idx) == 0 then (
                                    struct_is_type = 0;
                                    0
                                ) else (
                                    0
                                );
                                temp_node := new_list_node{last_idx, -1};
                                if temp_node == -1 then (
                                    current = -1;
                                ) else (
                                    if temp_head == -1 then (
                                        temp_head = temp_node;
                                    ) else (
                                        list_nodes(temp_tail).next = temp_node;
                                    );
                                    temp_tail = temp_node;
                                    current = list_nodes(current).next;
                                )
                            )
                        ) else (
                            set_error(span_start);
                            current = -1;
                        );
                        {}
                    );
                    if value_state.error != -1 then (
                        -1
                    ) else if flow_kind_is_none(flow_state.kind) == 0 then (
                        last_idx
                    ) else (
                        start_idx := value_state.count;
                        mut count := 0;
                        mut has_named := 0;
                        current = info.fields;
                        mut temp_current := temp_head;
                        while current != -1 && temp_current != -1 do (
                            field_node := list_nodes(current).value;
                            if NodeKind::Binding(field_binding) := nodes(field_node).kind then (
                                mut field_name := EMPTY_STRING;
                                field_binding.pattern |> match {
                                    BindingPattern::Identifier(id) => (field_name = id.name.name),
                                    else => (field_name = EMPTY_STRING)
                                };
                                if field_name.length > 0 then (
                                    has_named = 1;
                                    0
                                ) else (
                                    0
                                );
                                name_idx := store_value(Value::String(field_name));
                                if name_idx == -1 then (
                                    current = -1;
                                    temp_current = -1;
                                ) else (
                                    source_idx := list_nodes(temp_current).value;
                                    val_idx := copy_value(source_idx);
                                    if val_idx == -1 then (
                                        current = -1;
                                        temp_current = -1;
                                    ) else (
                                        normalized_val_idx := mark_intrinsic_string_value_as_type(val_idx);
                                        if normalized_val_idx == -1 then (
                                            current = -1;
                                            temp_current = -1;
                                        ) else (
                                        count = count + 1;
                                        current = list_nodes(current).next;
                                        temp_current = list_nodes(temp_current).next;
                                        )
                                    )
                                )
                            ) else (
                                set_error(span_start);
                                current = -1;
                                temp_current = -1;
                            );
                            {}
                        );
                        if value_state.error != -1 then (
                            -1
                        ) else (
                            struct_idx := store_value(Value::Record({ head = start_idx, count = count, has_named = has_named }));
                            if struct_idx == -1 then (
                                -1
                            ) else if struct_is_type == 1 then (
                                mark_value_as_type(struct_idx)
                            ) else (
                                struct_idx
                            )
                        )
                    )
                )
            ),
            else => (
                set_error(span_start);
                -1
            )
        }
    )
);

value_tag := (value: Value) => (
    value |> match {
        Value::Number(_) => 0,
        Value::Boolean(_) => 1,
        Value::Char(_) => 2,
        Value::String(_) => 3,
        Value::Unit => 4,
        Value::Function(_) => 5,
        Value::Record(_) => 6,
        Value::Builtin(_) => 7,
        Value::EnumType(_) => 8,
        Value::EnumConstructor(_) => 9,
        Value::Enum(_) => 10,
        Value::MatchFunction(_) => 11,
        Value::Target(_) => 12,
        Value::BindingAnnotation(_) => 13,
        Value::AsmFunction(_) => 14,
        Value::InlineAssembly(_) => 15,
        else => -1
    }
);

(export wasm) interpret := (root: i32) => (
    reset_interpreter{};
    enter_scope{};
    init_last := init_intrinsic_context{};
    debug_state.init_binding_count = intrinsic_state.binding_count;
    if init_last < 0 then (
        set_error(0);
        exit_scope{};
        -1
    ) else (
        mut result_idx := -1;
        if NodeKind::Block(list) := nodes(root).kind then (
            mut current := list.head;
            mut count := 0;
            result_idx = store_value(Value::Unit);
            while count < list.count && current != -1 do (
                result_idx = eval_expression(list_nodes(current).value);
                if value_state.error != -1 || flow_kind_is_none(flow_state.kind) == 0 then (
                    current = -1;
                    0
                ) else (
                    current = list_nodes(current).next;
                    count = count + 1;
                    0
                );
                {}
            );
            0
        ) else (
            result_idx = eval_expression(root);
            0
        );
        if value_state.error != -1 then (
            debug_state.error_binding_count = binding_state.count;
            exit_scope{};
            -1
        ) else result_idx
    )
);

(export wasm) get_interp_error := {} => (
    value_state.error
);

(export wasm) get_interp_error_code := {} => (
    value_state.error_code
);

(export wasm) get_value_tag := (idx: i32) => (
    value_tag(values(idx).value)
);

(export wasm) get_value_number := (idx: i32) => (
    if Value::Number(value) := values(idx).value then value else 0
);

(export wasm) get_value_boolean := (idx: i32) => (
    if Value::Boolean(value) := values(idx).value then value else 0
);

(export wasm) get_value_char := (idx: i32) => (
    if Value::Char(value) := values(idx).value then value else 0
);

(export wasm) get_value_string_start := (idx: i32) => (
    if Value::String(value) := values(idx).value then value.start else -1
);

(export wasm) get_value_string_length := (idx: i32) => (
    if Value::String(value) := values(idx).value then value.length else 0
);

(export wasm) get_value_function_node := (idx: i32) => (
    if Value::Function(value) := values(idx).value then value.node else -1
);

(export wasm) get_value_enum_variant_name_start := (idx: i32) => (
    if Value::Enum(value) := values(idx).value then (
        if Value::String(name) := values(value.variant_idx).value then name.start else -1
    ) else (
        -1
    )
);

(export wasm) get_value_enum_variant_name_length := (idx: i32) => (
    if Value::Enum(value) := values(idx).value then (
        if Value::String(name) := values(value.variant_idx).value then name.length else 0
    ) else (
        0
    )
);

(export wasm) get_value_enum_payload := (idx: i32) => (
    if Value::Enum(value) := values(idx).value then value.payload else -1
);

(export wasm) get_binding_count := {} => (
    binding_state.count
);

(export wasm) get_value_count := {} => (
    value_state.count
);

(export wasm) get_binding_name_start := (idx: i32) => (
    bindings(idx).name_start
);

(export wasm) get_binding_name_length := (idx: i32) => (
    bindings(idx).name_length
);

(export wasm) get_binding_is_mut := (idx: i32) => (
    bindings(idx).is_mut
);

(export wasm) get_binding_target_mask := (idx: i32) => (
    bindings(idx).target_mask
);

(export wasm) get_binding_export_mask := (idx: i32) => (
    bindings(idx).export_mask
);

(export wasm) get_binding_wrap_mask := (idx: i32) => (
    bindings(idx).wrap_mask
);

(export wasm) get_intrinsic_binding_count := {} => (
    intrinsic_state.binding_count
);

(export wasm) get_debug_error_binding_count := {} => (
    debug_state.error_binding_count
);

(export wasm) get_debug_init_binding_count := {} => (
    debug_state.init_binding_count
);

(export wasm) get_binding_value := (idx: i32) => (
    bindings(idx).value
);

(export wasm) get_binding_type_value := (idx: i32) => (
    bindings(idx).type_value
);

(export wasm) get_value_type_value := (idx: i32) => (
    values(idx).type_value
);

(export wasm) get_runtime_type_value_idx := {} => (
    runtime_state.type_value_idx
);
